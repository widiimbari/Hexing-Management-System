
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model area_list
 * 
 */
export type area_list = $Result.DefaultSelection<Prisma.$area_listPayload>
/**
 * Model attachment
 * 
 */
export type attachment = $Result.DefaultSelection<Prisma.$attachmentPayload>
/**
 * Model attachment2
 * 
 */
export type attachment2 = $Result.DefaultSelection<Prisma.$attachment2Payload>
/**
 * Model box
 * 
 */
export type box = $Result.DefaultSelection<Prisma.$boxPayload>
/**
 * Model config
 * 
 */
export type config = $Result.DefaultSelection<Prisma.$configPayload>
/**
 * Model defect_list
 * 
 */
export type defect_list = $Result.DefaultSelection<Prisma.$defect_listPayload>
/**
 * Model fct_notpass
 * 
 */
export type fct_notpass = $Result.DefaultSelection<Prisma.$fct_notpassPayload>
/**
 * Model fct_pass
 * 
 */
export type fct_pass = $Result.DefaultSelection<Prisma.$fct_passPayload>
/**
 * Model fct_temp
 * 
 */
export type fct_temp = $Result.DefaultSelection<Prisma.$fct_tempPayload>
/**
 * Model filestore_file
 * 
 */
export type filestore_file = $Result.DefaultSelection<Prisma.$filestore_filePayload>
/**
 * Model filestore_type
 * 
 */
export type filestore_type = $Result.DefaultSelection<Prisma.$filestore_typePayload>
/**
 * Model filestore_volume
 * 
 */
export type filestore_volume = $Result.DefaultSelection<Prisma.$filestore_volumePayload>
/**
 * Model audit_logs
 * 
 */
export type audit_logs = $Result.DefaultSelection<Prisma.$audit_logsPayload>
/**
 * Model logs_edit
 * 
 */
export type logs_edit = $Result.DefaultSelection<Prisma.$logs_editPayload>
/**
 * Model meter_type
 * 
 */
export type meter_type = $Result.DefaultSelection<Prisma.$meter_typePayload>
/**
 * Model module_list
 * 
 */
export type module_list = $Result.DefaultSelection<Prisma.$module_listPayload>
/**
 * Model order_num
 * 
 */
export type order_num = $Result.DefaultSelection<Prisma.$order_numPayload>
/**
 * Model out_110
 * 
 */
export type out_110 = $Result.DefaultSelection<Prisma.$out_110Payload>
/**
 * Model output_target
 * 
 */
export type output_target = $Result.DefaultSelection<Prisma.$output_targetPayload>
/**
 * Model output_temp
 * 
 */
export type output_temp = $Result.DefaultSelection<Prisma.$output_tempPayload>
/**
 * Model pallete
 * 
 */
export type pallete = $Result.DefaultSelection<Prisma.$palletePayload>
/**
 * Model pln_code
 * 
 */
export type pln_code = $Result.DefaultSelection<Prisma.$pln_codePayload>
/**
 * Model product
 * 
 */
export type product = $Result.DefaultSelection<Prisma.$productPayload>
/**
 * Model production_ng
 * 
 */
export type production_ng = $Result.DefaultSelection<Prisma.$production_ngPayload>
/**
 * Model productionorder
 * 
 */
export type productionorder = $Result.DefaultSelection<Prisma.$productionorderPayload>
/**
 * Model receive_110
 * 
 */
export type receive_110 = $Result.DefaultSelection<Prisma.$receive_110Payload>
/**
 * Model rework_amr
 * 
 */
export type rework_amr = $Result.DefaultSelection<Prisma.$rework_amrPayload>
/**
 * Model rework_box
 * 
 */
export type rework_box = $Result.DefaultSelection<Prisma.$rework_boxPayload>
/**
 * Model rework_hxe110
 * 
 */
export type rework_hxe110 = $Result.DefaultSelection<Prisma.$rework_hxe110Payload>
/**
 * Model rework_pallete
 * 
 */
export type rework_pallete = $Result.DefaultSelection<Prisma.$rework_palletePayload>
/**
 * Model serial_check
 * 
 */
export type serial_check = $Result.DefaultSelection<Prisma.$serial_checkPayload>
/**
 * Model tahun_garansi
 * 
 */
export type tahun_garansi = $Result.DefaultSelection<Prisma.$tahun_garansiPayload>
/**
 * Model temp_indicator
 * 
 */
export type temp_indicator = $Result.DefaultSelection<Prisma.$temp_indicatorPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const filestore_file_deleted: {
  Y: 'Y',
  N: 'N'
};

export type filestore_file_deleted = (typeof filestore_file_deleted)[keyof typeof filestore_file_deleted]


export const filestore_volume_enabled: {
  Y: 'Y',
  N: 'N'
};

export type filestore_volume_enabled = (typeof filestore_volume_enabled)[keyof typeof filestore_volume_enabled]


export const meter_type_card_validation: {
  Yes: 'Yes',
  No: 'No'
};

export type meter_type_card_validation = (typeof meter_type_card_validation)[keyof typeof meter_type_card_validation]


export const meter_type_validation_type: {
  Barcode: 'Barcode',
  QR: 'QR'
};

export type meter_type_validation_type = (typeof meter_type_validation_type)[keyof typeof meter_type_validation_type]


export const meter_type_daily_reset: {
  Yes: 'Yes',
  No: 'No'
};

export type meter_type_daily_reset = (typeof meter_type_daily_reset)[keyof typeof meter_type_daily_reset]


export const meter_type_numeric_only: {
  Yes: 'Yes',
  No: 'No'
};

export type meter_type_numeric_only = (typeof meter_type_numeric_only)[keyof typeof meter_type_numeric_only]


export const meter_type_surpass_target: {
  Yes: 'Yes',
  No: 'No'
};

export type meter_type_surpass_target = (typeof meter_type_surpass_target)[keyof typeof meter_type_surpass_target]


export const meter_type_run_by_sequence: {
  Yes: 'Yes',
  No: 'No'
};

export type meter_type_run_by_sequence = (typeof meter_type_run_by_sequence)[keyof typeof meter_type_run_by_sequence]


export const receive_110_result: {
  OK: 'OK',
  NG: 'NG'
};

export type receive_110_result = (typeof receive_110_result)[keyof typeof receive_110_result]


export const temp_indicator_status: {
  IN: 'IN',
  OUT: 'OUT'
};

export type temp_indicator_status = (typeof temp_indicator_status)[keyof typeof temp_indicator_status]

}

export type filestore_file_deleted = $Enums.filestore_file_deleted

export const filestore_file_deleted: typeof $Enums.filestore_file_deleted

export type filestore_volume_enabled = $Enums.filestore_volume_enabled

export const filestore_volume_enabled: typeof $Enums.filestore_volume_enabled

export type meter_type_card_validation = $Enums.meter_type_card_validation

export const meter_type_card_validation: typeof $Enums.meter_type_card_validation

export type meter_type_validation_type = $Enums.meter_type_validation_type

export const meter_type_validation_type: typeof $Enums.meter_type_validation_type

export type meter_type_daily_reset = $Enums.meter_type_daily_reset

export const meter_type_daily_reset: typeof $Enums.meter_type_daily_reset

export type meter_type_numeric_only = $Enums.meter_type_numeric_only

export const meter_type_numeric_only: typeof $Enums.meter_type_numeric_only

export type meter_type_surpass_target = $Enums.meter_type_surpass_target

export const meter_type_surpass_target: typeof $Enums.meter_type_surpass_target

export type meter_type_run_by_sequence = $Enums.meter_type_run_by_sequence

export const meter_type_run_by_sequence: typeof $Enums.meter_type_run_by_sequence

export type receive_110_result = $Enums.receive_110_result

export const receive_110_result: typeof $Enums.receive_110_result

export type temp_indicator_status = $Enums.temp_indicator_status

export const temp_indicator_status: typeof $Enums.temp_indicator_status

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Area_lists
 * const area_lists = await prisma.area_list.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Area_lists
   * const area_lists = await prisma.area_list.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.area_list`: Exposes CRUD operations for the **area_list** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Area_lists
    * const area_lists = await prisma.area_list.findMany()
    * ```
    */
  get area_list(): Prisma.area_listDelegate<ExtArgs>;

  /**
   * `prisma.attachment`: Exposes CRUD operations for the **attachment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Attachments
    * const attachments = await prisma.attachment.findMany()
    * ```
    */
  get attachment(): Prisma.attachmentDelegate<ExtArgs>;

  /**
   * `prisma.attachment2`: Exposes CRUD operations for the **attachment2** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Attachment2s
    * const attachment2s = await prisma.attachment2.findMany()
    * ```
    */
  get attachment2(): Prisma.attachment2Delegate<ExtArgs>;

  /**
   * `prisma.box`: Exposes CRUD operations for the **box** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Boxes
    * const boxes = await prisma.box.findMany()
    * ```
    */
  get box(): Prisma.boxDelegate<ExtArgs>;

  /**
   * `prisma.config`: Exposes CRUD operations for the **config** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Configs
    * const configs = await prisma.config.findMany()
    * ```
    */
  get config(): Prisma.configDelegate<ExtArgs>;

  /**
   * `prisma.defect_list`: Exposes CRUD operations for the **defect_list** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Defect_lists
    * const defect_lists = await prisma.defect_list.findMany()
    * ```
    */
  get defect_list(): Prisma.defect_listDelegate<ExtArgs>;

  /**
   * `prisma.fct_notpass`: Exposes CRUD operations for the **fct_notpass** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Fct_notpasses
    * const fct_notpasses = await prisma.fct_notpass.findMany()
    * ```
    */
  get fct_notpass(): Prisma.fct_notpassDelegate<ExtArgs>;

  /**
   * `prisma.fct_pass`: Exposes CRUD operations for the **fct_pass** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Fct_passes
    * const fct_passes = await prisma.fct_pass.findMany()
    * ```
    */
  get fct_pass(): Prisma.fct_passDelegate<ExtArgs>;

  /**
   * `prisma.fct_temp`: Exposes CRUD operations for the **fct_temp** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Fct_temps
    * const fct_temps = await prisma.fct_temp.findMany()
    * ```
    */
  get fct_temp(): Prisma.fct_tempDelegate<ExtArgs>;

  /**
   * `prisma.filestore_file`: Exposes CRUD operations for the **filestore_file** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Filestore_files
    * const filestore_files = await prisma.filestore_file.findMany()
    * ```
    */
  get filestore_file(): Prisma.filestore_fileDelegate<ExtArgs>;

  /**
   * `prisma.filestore_type`: Exposes CRUD operations for the **filestore_type** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Filestore_types
    * const filestore_types = await prisma.filestore_type.findMany()
    * ```
    */
  get filestore_type(): Prisma.filestore_typeDelegate<ExtArgs>;

  /**
   * `prisma.filestore_volume`: Exposes CRUD operations for the **filestore_volume** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Filestore_volumes
    * const filestore_volumes = await prisma.filestore_volume.findMany()
    * ```
    */
  get filestore_volume(): Prisma.filestore_volumeDelegate<ExtArgs>;

  /**
   * `prisma.audit_logs`: Exposes CRUD operations for the **audit_logs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Audit_logs
    * const audit_logs = await prisma.audit_logs.findMany()
    * ```
    */
  get audit_logs(): Prisma.audit_logsDelegate<ExtArgs>;

  /**
   * `prisma.logs_edit`: Exposes CRUD operations for the **logs_edit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Logs_edits
    * const logs_edits = await prisma.logs_edit.findMany()
    * ```
    */
  get logs_edit(): Prisma.logs_editDelegate<ExtArgs>;

  /**
   * `prisma.meter_type`: Exposes CRUD operations for the **meter_type** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Meter_types
    * const meter_types = await prisma.meter_type.findMany()
    * ```
    */
  get meter_type(): Prisma.meter_typeDelegate<ExtArgs>;

  /**
   * `prisma.module_list`: Exposes CRUD operations for the **module_list** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Module_lists
    * const module_lists = await prisma.module_list.findMany()
    * ```
    */
  get module_list(): Prisma.module_listDelegate<ExtArgs>;

  /**
   * `prisma.order_num`: Exposes CRUD operations for the **order_num** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Order_nums
    * const order_nums = await prisma.order_num.findMany()
    * ```
    */
  get order_num(): Prisma.order_numDelegate<ExtArgs>;

  /**
   * `prisma.out_110`: Exposes CRUD operations for the **out_110** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Out_110s
    * const out_110s = await prisma.out_110.findMany()
    * ```
    */
  get out_110(): Prisma.out_110Delegate<ExtArgs>;

  /**
   * `prisma.output_target`: Exposes CRUD operations for the **output_target** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Output_targets
    * const output_targets = await prisma.output_target.findMany()
    * ```
    */
  get output_target(): Prisma.output_targetDelegate<ExtArgs>;

  /**
   * `prisma.output_temp`: Exposes CRUD operations for the **output_temp** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Output_temps
    * const output_temps = await prisma.output_temp.findMany()
    * ```
    */
  get output_temp(): Prisma.output_tempDelegate<ExtArgs>;

  /**
   * `prisma.pallete`: Exposes CRUD operations for the **pallete** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Palletes
    * const palletes = await prisma.pallete.findMany()
    * ```
    */
  get pallete(): Prisma.palleteDelegate<ExtArgs>;

  /**
   * `prisma.pln_code`: Exposes CRUD operations for the **pln_code** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pln_codes
    * const pln_codes = await prisma.pln_code.findMany()
    * ```
    */
  get pln_code(): Prisma.pln_codeDelegate<ExtArgs>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.productDelegate<ExtArgs>;

  /**
   * `prisma.production_ng`: Exposes CRUD operations for the **production_ng** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Production_ngs
    * const production_ngs = await prisma.production_ng.findMany()
    * ```
    */
  get production_ng(): Prisma.production_ngDelegate<ExtArgs>;

  /**
   * `prisma.productionorder`: Exposes CRUD operations for the **productionorder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Productionorders
    * const productionorders = await prisma.productionorder.findMany()
    * ```
    */
  get productionorder(): Prisma.productionorderDelegate<ExtArgs>;

  /**
   * `prisma.receive_110`: Exposes CRUD operations for the **receive_110** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Receive_110s
    * const receive_110s = await prisma.receive_110.findMany()
    * ```
    */
  get receive_110(): Prisma.receive_110Delegate<ExtArgs>;

  /**
   * `prisma.rework_amr`: Exposes CRUD operations for the **rework_amr** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Rework_amrs
    * const rework_amrs = await prisma.rework_amr.findMany()
    * ```
    */
  get rework_amr(): Prisma.rework_amrDelegate<ExtArgs>;

  /**
   * `prisma.rework_box`: Exposes CRUD operations for the **rework_box** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Rework_boxes
    * const rework_boxes = await prisma.rework_box.findMany()
    * ```
    */
  get rework_box(): Prisma.rework_boxDelegate<ExtArgs>;

  /**
   * `prisma.rework_hxe110`: Exposes CRUD operations for the **rework_hxe110** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Rework_hxe110s
    * const rework_hxe110s = await prisma.rework_hxe110.findMany()
    * ```
    */
  get rework_hxe110(): Prisma.rework_hxe110Delegate<ExtArgs>;

  /**
   * `prisma.rework_pallete`: Exposes CRUD operations for the **rework_pallete** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Rework_palletes
    * const rework_palletes = await prisma.rework_pallete.findMany()
    * ```
    */
  get rework_pallete(): Prisma.rework_palleteDelegate<ExtArgs>;

  /**
   * `prisma.serial_check`: Exposes CRUD operations for the **serial_check** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Serial_checks
    * const serial_checks = await prisma.serial_check.findMany()
    * ```
    */
  get serial_check(): Prisma.serial_checkDelegate<ExtArgs>;

  /**
   * `prisma.tahun_garansi`: Exposes CRUD operations for the **tahun_garansi** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tahun_garansis
    * const tahun_garansis = await prisma.tahun_garansi.findMany()
    * ```
    */
  get tahun_garansi(): Prisma.tahun_garansiDelegate<ExtArgs>;

  /**
   * `prisma.temp_indicator`: Exposes CRUD operations for the **temp_indicator** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Temp_indicators
    * const temp_indicators = await prisma.temp_indicator.findMany()
    * ```
    */
  get temp_indicator(): Prisma.temp_indicatorDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.10.0
   * Query Engine version: 5a9203d0590c951969e85a7d07215503f4672eb9
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    area_list: 'area_list',
    attachment: 'attachment',
    attachment2: 'attachment2',
    box: 'box',
    config: 'config',
    defect_list: 'defect_list',
    fct_notpass: 'fct_notpass',
    fct_pass: 'fct_pass',
    fct_temp: 'fct_temp',
    filestore_file: 'filestore_file',
    filestore_type: 'filestore_type',
    filestore_volume: 'filestore_volume',
    audit_logs: 'audit_logs',
    logs_edit: 'logs_edit',
    meter_type: 'meter_type',
    module_list: 'module_list',
    order_num: 'order_num',
    out_110: 'out_110',
    output_target: 'output_target',
    output_temp: 'output_temp',
    pallete: 'pallete',
    pln_code: 'pln_code',
    product: 'product',
    production_ng: 'production_ng',
    productionorder: 'productionorder',
    receive_110: 'receive_110',
    rework_amr: 'rework_amr',
    rework_box: 'rework_box',
    rework_hxe110: 'rework_hxe110',
    rework_pallete: 'rework_pallete',
    serial_check: 'serial_check',
    tahun_garansi: 'tahun_garansi',
    temp_indicator: 'temp_indicator'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'area_list' | 'attachment' | 'attachment2' | 'box' | 'config' | 'defect_list' | 'fct_notpass' | 'fct_pass' | 'fct_temp' | 'filestore_file' | 'filestore_type' | 'filestore_volume' | 'audit_logs' | 'logs_edit' | 'meter_type' | 'module_list' | 'order_num' | 'out_110' | 'output_target' | 'output_temp' | 'pallete' | 'pln_code' | 'product' | 'production_ng' | 'productionorder' | 'receive_110' | 'rework_amr' | 'rework_box' | 'rework_hxe110' | 'rework_pallete' | 'serial_check' | 'tahun_garansi' | 'temp_indicator'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      area_list: {
        payload: Prisma.$area_listPayload<ExtArgs>
        fields: Prisma.area_listFieldRefs
        operations: {
          findUnique: {
            args: Prisma.area_listFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$area_listPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.area_listFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$area_listPayload>
          }
          findFirst: {
            args: Prisma.area_listFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$area_listPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.area_listFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$area_listPayload>
          }
          findMany: {
            args: Prisma.area_listFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$area_listPayload>[]
          }
          create: {
            args: Prisma.area_listCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$area_listPayload>
          }
          createMany: {
            args: Prisma.area_listCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.area_listDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$area_listPayload>
          }
          update: {
            args: Prisma.area_listUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$area_listPayload>
          }
          deleteMany: {
            args: Prisma.area_listDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.area_listUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.area_listUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$area_listPayload>
          }
          aggregate: {
            args: Prisma.Area_listAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateArea_list>
          }
          groupBy: {
            args: Prisma.area_listGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Area_listGroupByOutputType>[]
          }
          count: {
            args: Prisma.area_listCountArgs<ExtArgs>,
            result: $Utils.Optional<Area_listCountAggregateOutputType> | number
          }
        }
      }
      attachment: {
        payload: Prisma.$attachmentPayload<ExtArgs>
        fields: Prisma.attachmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.attachmentFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$attachmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.attachmentFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$attachmentPayload>
          }
          findFirst: {
            args: Prisma.attachmentFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$attachmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.attachmentFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$attachmentPayload>
          }
          findMany: {
            args: Prisma.attachmentFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$attachmentPayload>[]
          }
          create: {
            args: Prisma.attachmentCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$attachmentPayload>
          }
          createMany: {
            args: Prisma.attachmentCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.attachmentDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$attachmentPayload>
          }
          update: {
            args: Prisma.attachmentUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$attachmentPayload>
          }
          deleteMany: {
            args: Prisma.attachmentDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.attachmentUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.attachmentUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$attachmentPayload>
          }
          aggregate: {
            args: Prisma.AttachmentAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAttachment>
          }
          groupBy: {
            args: Prisma.attachmentGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AttachmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.attachmentCountArgs<ExtArgs>,
            result: $Utils.Optional<AttachmentCountAggregateOutputType> | number
          }
        }
      }
      attachment2: {
        payload: Prisma.$attachment2Payload<ExtArgs>
        fields: Prisma.attachment2FieldRefs
        operations: {
          findUnique: {
            args: Prisma.attachment2FindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$attachment2Payload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.attachment2FindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$attachment2Payload>
          }
          findFirst: {
            args: Prisma.attachment2FindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$attachment2Payload> | null
          }
          findFirstOrThrow: {
            args: Prisma.attachment2FindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$attachment2Payload>
          }
          findMany: {
            args: Prisma.attachment2FindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$attachment2Payload>[]
          }
          create: {
            args: Prisma.attachment2CreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$attachment2Payload>
          }
          createMany: {
            args: Prisma.attachment2CreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.attachment2DeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$attachment2Payload>
          }
          update: {
            args: Prisma.attachment2UpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$attachment2Payload>
          }
          deleteMany: {
            args: Prisma.attachment2DeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.attachment2UpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.attachment2UpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$attachment2Payload>
          }
          aggregate: {
            args: Prisma.Attachment2AggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAttachment2>
          }
          groupBy: {
            args: Prisma.attachment2GroupByArgs<ExtArgs>,
            result: $Utils.Optional<Attachment2GroupByOutputType>[]
          }
          count: {
            args: Prisma.attachment2CountArgs<ExtArgs>,
            result: $Utils.Optional<Attachment2CountAggregateOutputType> | number
          }
        }
      }
      box: {
        payload: Prisma.$boxPayload<ExtArgs>
        fields: Prisma.boxFieldRefs
        operations: {
          findUnique: {
            args: Prisma.boxFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$boxPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.boxFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$boxPayload>
          }
          findFirst: {
            args: Prisma.boxFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$boxPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.boxFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$boxPayload>
          }
          findMany: {
            args: Prisma.boxFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$boxPayload>[]
          }
          create: {
            args: Prisma.boxCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$boxPayload>
          }
          createMany: {
            args: Prisma.boxCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.boxDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$boxPayload>
          }
          update: {
            args: Prisma.boxUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$boxPayload>
          }
          deleteMany: {
            args: Prisma.boxDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.boxUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.boxUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$boxPayload>
          }
          aggregate: {
            args: Prisma.BoxAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBox>
          }
          groupBy: {
            args: Prisma.boxGroupByArgs<ExtArgs>,
            result: $Utils.Optional<BoxGroupByOutputType>[]
          }
          count: {
            args: Prisma.boxCountArgs<ExtArgs>,
            result: $Utils.Optional<BoxCountAggregateOutputType> | number
          }
        }
      }
      config: {
        payload: Prisma.$configPayload<ExtArgs>
        fields: Prisma.configFieldRefs
        operations: {
          findUnique: {
            args: Prisma.configFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$configPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.configFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$configPayload>
          }
          findFirst: {
            args: Prisma.configFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$configPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.configFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$configPayload>
          }
          findMany: {
            args: Prisma.configFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$configPayload>[]
          }
          create: {
            args: Prisma.configCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$configPayload>
          }
          createMany: {
            args: Prisma.configCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.configDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$configPayload>
          }
          update: {
            args: Prisma.configUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$configPayload>
          }
          deleteMany: {
            args: Prisma.configDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.configUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.configUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$configPayload>
          }
          aggregate: {
            args: Prisma.ConfigAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateConfig>
          }
          groupBy: {
            args: Prisma.configGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ConfigGroupByOutputType>[]
          }
          count: {
            args: Prisma.configCountArgs<ExtArgs>,
            result: $Utils.Optional<ConfigCountAggregateOutputType> | number
          }
        }
      }
      defect_list: {
        payload: Prisma.$defect_listPayload<ExtArgs>
        fields: Prisma.defect_listFieldRefs
        operations: {
          findUnique: {
            args: Prisma.defect_listFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$defect_listPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.defect_listFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$defect_listPayload>
          }
          findFirst: {
            args: Prisma.defect_listFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$defect_listPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.defect_listFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$defect_listPayload>
          }
          findMany: {
            args: Prisma.defect_listFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$defect_listPayload>[]
          }
          create: {
            args: Prisma.defect_listCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$defect_listPayload>
          }
          createMany: {
            args: Prisma.defect_listCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.defect_listDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$defect_listPayload>
          }
          update: {
            args: Prisma.defect_listUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$defect_listPayload>
          }
          deleteMany: {
            args: Prisma.defect_listDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.defect_listUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.defect_listUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$defect_listPayload>
          }
          aggregate: {
            args: Prisma.Defect_listAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateDefect_list>
          }
          groupBy: {
            args: Prisma.defect_listGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Defect_listGroupByOutputType>[]
          }
          count: {
            args: Prisma.defect_listCountArgs<ExtArgs>,
            result: $Utils.Optional<Defect_listCountAggregateOutputType> | number
          }
        }
      }
      fct_notpass: {
        payload: Prisma.$fct_notpassPayload<ExtArgs>
        fields: Prisma.fct_notpassFieldRefs
        operations: {
          findUnique: {
            args: Prisma.fct_notpassFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$fct_notpassPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.fct_notpassFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$fct_notpassPayload>
          }
          findFirst: {
            args: Prisma.fct_notpassFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$fct_notpassPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.fct_notpassFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$fct_notpassPayload>
          }
          findMany: {
            args: Prisma.fct_notpassFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$fct_notpassPayload>[]
          }
          create: {
            args: Prisma.fct_notpassCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$fct_notpassPayload>
          }
          createMany: {
            args: Prisma.fct_notpassCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.fct_notpassDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$fct_notpassPayload>
          }
          update: {
            args: Prisma.fct_notpassUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$fct_notpassPayload>
          }
          deleteMany: {
            args: Prisma.fct_notpassDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.fct_notpassUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.fct_notpassUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$fct_notpassPayload>
          }
          aggregate: {
            args: Prisma.Fct_notpassAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateFct_notpass>
          }
          groupBy: {
            args: Prisma.fct_notpassGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Fct_notpassGroupByOutputType>[]
          }
          count: {
            args: Prisma.fct_notpassCountArgs<ExtArgs>,
            result: $Utils.Optional<Fct_notpassCountAggregateOutputType> | number
          }
        }
      }
      fct_pass: {
        payload: Prisma.$fct_passPayload<ExtArgs>
        fields: Prisma.fct_passFieldRefs
        operations: {
          findUnique: {
            args: Prisma.fct_passFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$fct_passPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.fct_passFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$fct_passPayload>
          }
          findFirst: {
            args: Prisma.fct_passFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$fct_passPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.fct_passFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$fct_passPayload>
          }
          findMany: {
            args: Prisma.fct_passFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$fct_passPayload>[]
          }
          create: {
            args: Prisma.fct_passCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$fct_passPayload>
          }
          createMany: {
            args: Prisma.fct_passCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.fct_passDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$fct_passPayload>
          }
          update: {
            args: Prisma.fct_passUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$fct_passPayload>
          }
          deleteMany: {
            args: Prisma.fct_passDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.fct_passUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.fct_passUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$fct_passPayload>
          }
          aggregate: {
            args: Prisma.Fct_passAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateFct_pass>
          }
          groupBy: {
            args: Prisma.fct_passGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Fct_passGroupByOutputType>[]
          }
          count: {
            args: Prisma.fct_passCountArgs<ExtArgs>,
            result: $Utils.Optional<Fct_passCountAggregateOutputType> | number
          }
        }
      }
      fct_temp: {
        payload: Prisma.$fct_tempPayload<ExtArgs>
        fields: Prisma.fct_tempFieldRefs
        operations: {
          findUnique: {
            args: Prisma.fct_tempFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$fct_tempPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.fct_tempFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$fct_tempPayload>
          }
          findFirst: {
            args: Prisma.fct_tempFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$fct_tempPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.fct_tempFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$fct_tempPayload>
          }
          findMany: {
            args: Prisma.fct_tempFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$fct_tempPayload>[]
          }
          create: {
            args: Prisma.fct_tempCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$fct_tempPayload>
          }
          createMany: {
            args: Prisma.fct_tempCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.fct_tempDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$fct_tempPayload>
          }
          update: {
            args: Prisma.fct_tempUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$fct_tempPayload>
          }
          deleteMany: {
            args: Prisma.fct_tempDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.fct_tempUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.fct_tempUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$fct_tempPayload>
          }
          aggregate: {
            args: Prisma.Fct_tempAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateFct_temp>
          }
          groupBy: {
            args: Prisma.fct_tempGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Fct_tempGroupByOutputType>[]
          }
          count: {
            args: Prisma.fct_tempCountArgs<ExtArgs>,
            result: $Utils.Optional<Fct_tempCountAggregateOutputType> | number
          }
        }
      }
      filestore_file: {
        payload: Prisma.$filestore_filePayload<ExtArgs>
        fields: Prisma.filestore_fileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.filestore_fileFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$filestore_filePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.filestore_fileFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$filestore_filePayload>
          }
          findFirst: {
            args: Prisma.filestore_fileFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$filestore_filePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.filestore_fileFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$filestore_filePayload>
          }
          findMany: {
            args: Prisma.filestore_fileFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$filestore_filePayload>[]
          }
          create: {
            args: Prisma.filestore_fileCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$filestore_filePayload>
          }
          createMany: {
            args: Prisma.filestore_fileCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.filestore_fileDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$filestore_filePayload>
          }
          update: {
            args: Prisma.filestore_fileUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$filestore_filePayload>
          }
          deleteMany: {
            args: Prisma.filestore_fileDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.filestore_fileUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.filestore_fileUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$filestore_filePayload>
          }
          aggregate: {
            args: Prisma.Filestore_fileAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateFilestore_file>
          }
          groupBy: {
            args: Prisma.filestore_fileGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Filestore_fileGroupByOutputType>[]
          }
          count: {
            args: Prisma.filestore_fileCountArgs<ExtArgs>,
            result: $Utils.Optional<Filestore_fileCountAggregateOutputType> | number
          }
        }
      }
      filestore_type: {
        payload: Prisma.$filestore_typePayload<ExtArgs>
        fields: Prisma.filestore_typeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.filestore_typeFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$filestore_typePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.filestore_typeFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$filestore_typePayload>
          }
          findFirst: {
            args: Prisma.filestore_typeFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$filestore_typePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.filestore_typeFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$filestore_typePayload>
          }
          findMany: {
            args: Prisma.filestore_typeFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$filestore_typePayload>[]
          }
          create: {
            args: Prisma.filestore_typeCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$filestore_typePayload>
          }
          createMany: {
            args: Prisma.filestore_typeCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.filestore_typeDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$filestore_typePayload>
          }
          update: {
            args: Prisma.filestore_typeUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$filestore_typePayload>
          }
          deleteMany: {
            args: Prisma.filestore_typeDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.filestore_typeUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.filestore_typeUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$filestore_typePayload>
          }
          aggregate: {
            args: Prisma.Filestore_typeAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateFilestore_type>
          }
          groupBy: {
            args: Prisma.filestore_typeGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Filestore_typeGroupByOutputType>[]
          }
          count: {
            args: Prisma.filestore_typeCountArgs<ExtArgs>,
            result: $Utils.Optional<Filestore_typeCountAggregateOutputType> | number
          }
        }
      }
      filestore_volume: {
        payload: Prisma.$filestore_volumePayload<ExtArgs>
        fields: Prisma.filestore_volumeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.filestore_volumeFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$filestore_volumePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.filestore_volumeFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$filestore_volumePayload>
          }
          findFirst: {
            args: Prisma.filestore_volumeFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$filestore_volumePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.filestore_volumeFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$filestore_volumePayload>
          }
          findMany: {
            args: Prisma.filestore_volumeFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$filestore_volumePayload>[]
          }
          create: {
            args: Prisma.filestore_volumeCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$filestore_volumePayload>
          }
          createMany: {
            args: Prisma.filestore_volumeCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.filestore_volumeDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$filestore_volumePayload>
          }
          update: {
            args: Prisma.filestore_volumeUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$filestore_volumePayload>
          }
          deleteMany: {
            args: Prisma.filestore_volumeDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.filestore_volumeUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.filestore_volumeUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$filestore_volumePayload>
          }
          aggregate: {
            args: Prisma.Filestore_volumeAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateFilestore_volume>
          }
          groupBy: {
            args: Prisma.filestore_volumeGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Filestore_volumeGroupByOutputType>[]
          }
          count: {
            args: Prisma.filestore_volumeCountArgs<ExtArgs>,
            result: $Utils.Optional<Filestore_volumeCountAggregateOutputType> | number
          }
        }
      }
      audit_logs: {
        payload: Prisma.$audit_logsPayload<ExtArgs>
        fields: Prisma.audit_logsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.audit_logsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$audit_logsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.audit_logsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$audit_logsPayload>
          }
          findFirst: {
            args: Prisma.audit_logsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$audit_logsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.audit_logsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$audit_logsPayload>
          }
          findMany: {
            args: Prisma.audit_logsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$audit_logsPayload>[]
          }
          create: {
            args: Prisma.audit_logsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$audit_logsPayload>
          }
          createMany: {
            args: Prisma.audit_logsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.audit_logsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$audit_logsPayload>
          }
          update: {
            args: Prisma.audit_logsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$audit_logsPayload>
          }
          deleteMany: {
            args: Prisma.audit_logsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.audit_logsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.audit_logsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$audit_logsPayload>
          }
          aggregate: {
            args: Prisma.Audit_logsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAudit_logs>
          }
          groupBy: {
            args: Prisma.audit_logsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Audit_logsGroupByOutputType>[]
          }
          count: {
            args: Prisma.audit_logsCountArgs<ExtArgs>,
            result: $Utils.Optional<Audit_logsCountAggregateOutputType> | number
          }
        }
      }
      logs_edit: {
        payload: Prisma.$logs_editPayload<ExtArgs>
        fields: Prisma.logs_editFieldRefs
        operations: {
          findUnique: {
            args: Prisma.logs_editFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$logs_editPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.logs_editFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$logs_editPayload>
          }
          findFirst: {
            args: Prisma.logs_editFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$logs_editPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.logs_editFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$logs_editPayload>
          }
          findMany: {
            args: Prisma.logs_editFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$logs_editPayload>[]
          }
          create: {
            args: Prisma.logs_editCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$logs_editPayload>
          }
          createMany: {
            args: Prisma.logs_editCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.logs_editDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$logs_editPayload>
          }
          update: {
            args: Prisma.logs_editUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$logs_editPayload>
          }
          deleteMany: {
            args: Prisma.logs_editDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.logs_editUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.logs_editUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$logs_editPayload>
          }
          aggregate: {
            args: Prisma.Logs_editAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateLogs_edit>
          }
          groupBy: {
            args: Prisma.logs_editGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Logs_editGroupByOutputType>[]
          }
          count: {
            args: Prisma.logs_editCountArgs<ExtArgs>,
            result: $Utils.Optional<Logs_editCountAggregateOutputType> | number
          }
        }
      }
      meter_type: {
        payload: Prisma.$meter_typePayload<ExtArgs>
        fields: Prisma.meter_typeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.meter_typeFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$meter_typePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.meter_typeFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$meter_typePayload>
          }
          findFirst: {
            args: Prisma.meter_typeFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$meter_typePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.meter_typeFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$meter_typePayload>
          }
          findMany: {
            args: Prisma.meter_typeFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$meter_typePayload>[]
          }
          create: {
            args: Prisma.meter_typeCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$meter_typePayload>
          }
          createMany: {
            args: Prisma.meter_typeCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.meter_typeDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$meter_typePayload>
          }
          update: {
            args: Prisma.meter_typeUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$meter_typePayload>
          }
          deleteMany: {
            args: Prisma.meter_typeDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.meter_typeUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.meter_typeUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$meter_typePayload>
          }
          aggregate: {
            args: Prisma.Meter_typeAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMeter_type>
          }
          groupBy: {
            args: Prisma.meter_typeGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Meter_typeGroupByOutputType>[]
          }
          count: {
            args: Prisma.meter_typeCountArgs<ExtArgs>,
            result: $Utils.Optional<Meter_typeCountAggregateOutputType> | number
          }
        }
      }
      module_list: {
        payload: Prisma.$module_listPayload<ExtArgs>
        fields: Prisma.module_listFieldRefs
        operations: {
          findUnique: {
            args: Prisma.module_listFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$module_listPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.module_listFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$module_listPayload>
          }
          findFirst: {
            args: Prisma.module_listFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$module_listPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.module_listFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$module_listPayload>
          }
          findMany: {
            args: Prisma.module_listFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$module_listPayload>[]
          }
          create: {
            args: Prisma.module_listCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$module_listPayload>
          }
          createMany: {
            args: Prisma.module_listCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.module_listDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$module_listPayload>
          }
          update: {
            args: Prisma.module_listUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$module_listPayload>
          }
          deleteMany: {
            args: Prisma.module_listDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.module_listUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.module_listUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$module_listPayload>
          }
          aggregate: {
            args: Prisma.Module_listAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateModule_list>
          }
          groupBy: {
            args: Prisma.module_listGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Module_listGroupByOutputType>[]
          }
          count: {
            args: Prisma.module_listCountArgs<ExtArgs>,
            result: $Utils.Optional<Module_listCountAggregateOutputType> | number
          }
        }
      }
      order_num: {
        payload: Prisma.$order_numPayload<ExtArgs>
        fields: Prisma.order_numFieldRefs
        operations: {
          findUnique: {
            args: Prisma.order_numFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$order_numPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.order_numFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$order_numPayload>
          }
          findFirst: {
            args: Prisma.order_numFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$order_numPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.order_numFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$order_numPayload>
          }
          findMany: {
            args: Prisma.order_numFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$order_numPayload>[]
          }
          create: {
            args: Prisma.order_numCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$order_numPayload>
          }
          createMany: {
            args: Prisma.order_numCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.order_numDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$order_numPayload>
          }
          update: {
            args: Prisma.order_numUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$order_numPayload>
          }
          deleteMany: {
            args: Prisma.order_numDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.order_numUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.order_numUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$order_numPayload>
          }
          aggregate: {
            args: Prisma.Order_numAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateOrder_num>
          }
          groupBy: {
            args: Prisma.order_numGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Order_numGroupByOutputType>[]
          }
          count: {
            args: Prisma.order_numCountArgs<ExtArgs>,
            result: $Utils.Optional<Order_numCountAggregateOutputType> | number
          }
        }
      }
      out_110: {
        payload: Prisma.$out_110Payload<ExtArgs>
        fields: Prisma.out_110FieldRefs
        operations: {
          findUnique: {
            args: Prisma.out_110FindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$out_110Payload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.out_110FindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$out_110Payload>
          }
          findFirst: {
            args: Prisma.out_110FindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$out_110Payload> | null
          }
          findFirstOrThrow: {
            args: Prisma.out_110FindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$out_110Payload>
          }
          findMany: {
            args: Prisma.out_110FindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$out_110Payload>[]
          }
          create: {
            args: Prisma.out_110CreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$out_110Payload>
          }
          createMany: {
            args: Prisma.out_110CreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.out_110DeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$out_110Payload>
          }
          update: {
            args: Prisma.out_110UpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$out_110Payload>
          }
          deleteMany: {
            args: Prisma.out_110DeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.out_110UpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.out_110UpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$out_110Payload>
          }
          aggregate: {
            args: Prisma.Out_110AggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateOut_110>
          }
          groupBy: {
            args: Prisma.out_110GroupByArgs<ExtArgs>,
            result: $Utils.Optional<Out_110GroupByOutputType>[]
          }
          count: {
            args: Prisma.out_110CountArgs<ExtArgs>,
            result: $Utils.Optional<Out_110CountAggregateOutputType> | number
          }
        }
      }
      output_target: {
        payload: Prisma.$output_targetPayload<ExtArgs>
        fields: Prisma.output_targetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.output_targetFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$output_targetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.output_targetFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$output_targetPayload>
          }
          findFirst: {
            args: Prisma.output_targetFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$output_targetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.output_targetFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$output_targetPayload>
          }
          findMany: {
            args: Prisma.output_targetFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$output_targetPayload>[]
          }
          create: {
            args: Prisma.output_targetCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$output_targetPayload>
          }
          createMany: {
            args: Prisma.output_targetCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.output_targetDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$output_targetPayload>
          }
          update: {
            args: Prisma.output_targetUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$output_targetPayload>
          }
          deleteMany: {
            args: Prisma.output_targetDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.output_targetUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.output_targetUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$output_targetPayload>
          }
          aggregate: {
            args: Prisma.Output_targetAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateOutput_target>
          }
          groupBy: {
            args: Prisma.output_targetGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Output_targetGroupByOutputType>[]
          }
          count: {
            args: Prisma.output_targetCountArgs<ExtArgs>,
            result: $Utils.Optional<Output_targetCountAggregateOutputType> | number
          }
        }
      }
      output_temp: {
        payload: Prisma.$output_tempPayload<ExtArgs>
        fields: Prisma.output_tempFieldRefs
        operations: {
          findUnique: {
            args: Prisma.output_tempFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$output_tempPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.output_tempFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$output_tempPayload>
          }
          findFirst: {
            args: Prisma.output_tempFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$output_tempPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.output_tempFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$output_tempPayload>
          }
          findMany: {
            args: Prisma.output_tempFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$output_tempPayload>[]
          }
          create: {
            args: Prisma.output_tempCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$output_tempPayload>
          }
          createMany: {
            args: Prisma.output_tempCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.output_tempDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$output_tempPayload>
          }
          update: {
            args: Prisma.output_tempUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$output_tempPayload>
          }
          deleteMany: {
            args: Prisma.output_tempDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.output_tempUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.output_tempUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$output_tempPayload>
          }
          aggregate: {
            args: Prisma.Output_tempAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateOutput_temp>
          }
          groupBy: {
            args: Prisma.output_tempGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Output_tempGroupByOutputType>[]
          }
          count: {
            args: Prisma.output_tempCountArgs<ExtArgs>,
            result: $Utils.Optional<Output_tempCountAggregateOutputType> | number
          }
        }
      }
      pallete: {
        payload: Prisma.$palletePayload<ExtArgs>
        fields: Prisma.palleteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.palleteFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$palletePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.palleteFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$palletePayload>
          }
          findFirst: {
            args: Prisma.palleteFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$palletePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.palleteFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$palletePayload>
          }
          findMany: {
            args: Prisma.palleteFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$palletePayload>[]
          }
          create: {
            args: Prisma.palleteCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$palletePayload>
          }
          createMany: {
            args: Prisma.palleteCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.palleteDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$palletePayload>
          }
          update: {
            args: Prisma.palleteUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$palletePayload>
          }
          deleteMany: {
            args: Prisma.palleteDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.palleteUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.palleteUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$palletePayload>
          }
          aggregate: {
            args: Prisma.PalleteAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePallete>
          }
          groupBy: {
            args: Prisma.palleteGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PalleteGroupByOutputType>[]
          }
          count: {
            args: Prisma.palleteCountArgs<ExtArgs>,
            result: $Utils.Optional<PalleteCountAggregateOutputType> | number
          }
        }
      }
      pln_code: {
        payload: Prisma.$pln_codePayload<ExtArgs>
        fields: Prisma.pln_codeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.pln_codeFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$pln_codePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.pln_codeFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$pln_codePayload>
          }
          findFirst: {
            args: Prisma.pln_codeFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$pln_codePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.pln_codeFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$pln_codePayload>
          }
          findMany: {
            args: Prisma.pln_codeFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$pln_codePayload>[]
          }
          create: {
            args: Prisma.pln_codeCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$pln_codePayload>
          }
          createMany: {
            args: Prisma.pln_codeCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.pln_codeDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$pln_codePayload>
          }
          update: {
            args: Prisma.pln_codeUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$pln_codePayload>
          }
          deleteMany: {
            args: Prisma.pln_codeDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.pln_codeUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.pln_codeUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$pln_codePayload>
          }
          aggregate: {
            args: Prisma.Pln_codeAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePln_code>
          }
          groupBy: {
            args: Prisma.pln_codeGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Pln_codeGroupByOutputType>[]
          }
          count: {
            args: Prisma.pln_codeCountArgs<ExtArgs>,
            result: $Utils.Optional<Pln_codeCountAggregateOutputType> | number
          }
        }
      }
      product: {
        payload: Prisma.$productPayload<ExtArgs>
        fields: Prisma.productFieldRefs
        operations: {
          findUnique: {
            args: Prisma.productFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$productPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.productFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$productPayload>
          }
          findFirst: {
            args: Prisma.productFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$productPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.productFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$productPayload>
          }
          findMany: {
            args: Prisma.productFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$productPayload>[]
          }
          create: {
            args: Prisma.productCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$productPayload>
          }
          createMany: {
            args: Prisma.productCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.productDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$productPayload>
          }
          update: {
            args: Prisma.productUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$productPayload>
          }
          deleteMany: {
            args: Prisma.productDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.productUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.productUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$productPayload>
          }
          aggregate: {
            args: Prisma.ProductAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateProduct>
          }
          groupBy: {
            args: Prisma.productGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.productCountArgs<ExtArgs>,
            result: $Utils.Optional<ProductCountAggregateOutputType> | number
          }
        }
      }
      production_ng: {
        payload: Prisma.$production_ngPayload<ExtArgs>
        fields: Prisma.production_ngFieldRefs
        operations: {
          findUnique: {
            args: Prisma.production_ngFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$production_ngPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.production_ngFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$production_ngPayload>
          }
          findFirst: {
            args: Prisma.production_ngFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$production_ngPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.production_ngFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$production_ngPayload>
          }
          findMany: {
            args: Prisma.production_ngFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$production_ngPayload>[]
          }
          create: {
            args: Prisma.production_ngCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$production_ngPayload>
          }
          createMany: {
            args: Prisma.production_ngCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.production_ngDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$production_ngPayload>
          }
          update: {
            args: Prisma.production_ngUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$production_ngPayload>
          }
          deleteMany: {
            args: Prisma.production_ngDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.production_ngUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.production_ngUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$production_ngPayload>
          }
          aggregate: {
            args: Prisma.Production_ngAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateProduction_ng>
          }
          groupBy: {
            args: Prisma.production_ngGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Production_ngGroupByOutputType>[]
          }
          count: {
            args: Prisma.production_ngCountArgs<ExtArgs>,
            result: $Utils.Optional<Production_ngCountAggregateOutputType> | number
          }
        }
      }
      productionorder: {
        payload: Prisma.$productionorderPayload<ExtArgs>
        fields: Prisma.productionorderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.productionorderFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$productionorderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.productionorderFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$productionorderPayload>
          }
          findFirst: {
            args: Prisma.productionorderFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$productionorderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.productionorderFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$productionorderPayload>
          }
          findMany: {
            args: Prisma.productionorderFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$productionorderPayload>[]
          }
          create: {
            args: Prisma.productionorderCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$productionorderPayload>
          }
          createMany: {
            args: Prisma.productionorderCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.productionorderDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$productionorderPayload>
          }
          update: {
            args: Prisma.productionorderUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$productionorderPayload>
          }
          deleteMany: {
            args: Prisma.productionorderDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.productionorderUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.productionorderUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$productionorderPayload>
          }
          aggregate: {
            args: Prisma.ProductionorderAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateProductionorder>
          }
          groupBy: {
            args: Prisma.productionorderGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ProductionorderGroupByOutputType>[]
          }
          count: {
            args: Prisma.productionorderCountArgs<ExtArgs>,
            result: $Utils.Optional<ProductionorderCountAggregateOutputType> | number
          }
        }
      }
      receive_110: {
        payload: Prisma.$receive_110Payload<ExtArgs>
        fields: Prisma.receive_110FieldRefs
        operations: {
          findUnique: {
            args: Prisma.receive_110FindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$receive_110Payload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.receive_110FindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$receive_110Payload>
          }
          findFirst: {
            args: Prisma.receive_110FindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$receive_110Payload> | null
          }
          findFirstOrThrow: {
            args: Prisma.receive_110FindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$receive_110Payload>
          }
          findMany: {
            args: Prisma.receive_110FindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$receive_110Payload>[]
          }
          create: {
            args: Prisma.receive_110CreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$receive_110Payload>
          }
          createMany: {
            args: Prisma.receive_110CreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.receive_110DeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$receive_110Payload>
          }
          update: {
            args: Prisma.receive_110UpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$receive_110Payload>
          }
          deleteMany: {
            args: Prisma.receive_110DeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.receive_110UpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.receive_110UpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$receive_110Payload>
          }
          aggregate: {
            args: Prisma.Receive_110AggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateReceive_110>
          }
          groupBy: {
            args: Prisma.receive_110GroupByArgs<ExtArgs>,
            result: $Utils.Optional<Receive_110GroupByOutputType>[]
          }
          count: {
            args: Prisma.receive_110CountArgs<ExtArgs>,
            result: $Utils.Optional<Receive_110CountAggregateOutputType> | number
          }
        }
      }
      rework_amr: {
        payload: Prisma.$rework_amrPayload<ExtArgs>
        fields: Prisma.rework_amrFieldRefs
        operations: {
          findUnique: {
            args: Prisma.rework_amrFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$rework_amrPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.rework_amrFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$rework_amrPayload>
          }
          findFirst: {
            args: Prisma.rework_amrFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$rework_amrPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.rework_amrFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$rework_amrPayload>
          }
          findMany: {
            args: Prisma.rework_amrFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$rework_amrPayload>[]
          }
          create: {
            args: Prisma.rework_amrCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$rework_amrPayload>
          }
          createMany: {
            args: Prisma.rework_amrCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.rework_amrDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$rework_amrPayload>
          }
          update: {
            args: Prisma.rework_amrUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$rework_amrPayload>
          }
          deleteMany: {
            args: Prisma.rework_amrDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.rework_amrUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.rework_amrUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$rework_amrPayload>
          }
          aggregate: {
            args: Prisma.Rework_amrAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRework_amr>
          }
          groupBy: {
            args: Prisma.rework_amrGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Rework_amrGroupByOutputType>[]
          }
          count: {
            args: Prisma.rework_amrCountArgs<ExtArgs>,
            result: $Utils.Optional<Rework_amrCountAggregateOutputType> | number
          }
        }
      }
      rework_box: {
        payload: Prisma.$rework_boxPayload<ExtArgs>
        fields: Prisma.rework_boxFieldRefs
        operations: {
          findUnique: {
            args: Prisma.rework_boxFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$rework_boxPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.rework_boxFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$rework_boxPayload>
          }
          findFirst: {
            args: Prisma.rework_boxFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$rework_boxPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.rework_boxFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$rework_boxPayload>
          }
          findMany: {
            args: Prisma.rework_boxFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$rework_boxPayload>[]
          }
          create: {
            args: Prisma.rework_boxCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$rework_boxPayload>
          }
          createMany: {
            args: Prisma.rework_boxCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.rework_boxDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$rework_boxPayload>
          }
          update: {
            args: Prisma.rework_boxUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$rework_boxPayload>
          }
          deleteMany: {
            args: Prisma.rework_boxDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.rework_boxUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.rework_boxUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$rework_boxPayload>
          }
          aggregate: {
            args: Prisma.Rework_boxAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRework_box>
          }
          groupBy: {
            args: Prisma.rework_boxGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Rework_boxGroupByOutputType>[]
          }
          count: {
            args: Prisma.rework_boxCountArgs<ExtArgs>,
            result: $Utils.Optional<Rework_boxCountAggregateOutputType> | number
          }
        }
      }
      rework_hxe110: {
        payload: Prisma.$rework_hxe110Payload<ExtArgs>
        fields: Prisma.rework_hxe110FieldRefs
        operations: {
          findUnique: {
            args: Prisma.rework_hxe110FindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$rework_hxe110Payload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.rework_hxe110FindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$rework_hxe110Payload>
          }
          findFirst: {
            args: Prisma.rework_hxe110FindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$rework_hxe110Payload> | null
          }
          findFirstOrThrow: {
            args: Prisma.rework_hxe110FindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$rework_hxe110Payload>
          }
          findMany: {
            args: Prisma.rework_hxe110FindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$rework_hxe110Payload>[]
          }
          create: {
            args: Prisma.rework_hxe110CreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$rework_hxe110Payload>
          }
          createMany: {
            args: Prisma.rework_hxe110CreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.rework_hxe110DeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$rework_hxe110Payload>
          }
          update: {
            args: Prisma.rework_hxe110UpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$rework_hxe110Payload>
          }
          deleteMany: {
            args: Prisma.rework_hxe110DeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.rework_hxe110UpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.rework_hxe110UpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$rework_hxe110Payload>
          }
          aggregate: {
            args: Prisma.Rework_hxe110AggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRework_hxe110>
          }
          groupBy: {
            args: Prisma.rework_hxe110GroupByArgs<ExtArgs>,
            result: $Utils.Optional<Rework_hxe110GroupByOutputType>[]
          }
          count: {
            args: Prisma.rework_hxe110CountArgs<ExtArgs>,
            result: $Utils.Optional<Rework_hxe110CountAggregateOutputType> | number
          }
        }
      }
      rework_pallete: {
        payload: Prisma.$rework_palletePayload<ExtArgs>
        fields: Prisma.rework_palleteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.rework_palleteFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$rework_palletePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.rework_palleteFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$rework_palletePayload>
          }
          findFirst: {
            args: Prisma.rework_palleteFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$rework_palletePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.rework_palleteFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$rework_palletePayload>
          }
          findMany: {
            args: Prisma.rework_palleteFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$rework_palletePayload>[]
          }
          create: {
            args: Prisma.rework_palleteCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$rework_palletePayload>
          }
          createMany: {
            args: Prisma.rework_palleteCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.rework_palleteDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$rework_palletePayload>
          }
          update: {
            args: Prisma.rework_palleteUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$rework_palletePayload>
          }
          deleteMany: {
            args: Prisma.rework_palleteDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.rework_palleteUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.rework_palleteUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$rework_palletePayload>
          }
          aggregate: {
            args: Prisma.Rework_palleteAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRework_pallete>
          }
          groupBy: {
            args: Prisma.rework_palleteGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Rework_palleteGroupByOutputType>[]
          }
          count: {
            args: Prisma.rework_palleteCountArgs<ExtArgs>,
            result: $Utils.Optional<Rework_palleteCountAggregateOutputType> | number
          }
        }
      }
      serial_check: {
        payload: Prisma.$serial_checkPayload<ExtArgs>
        fields: Prisma.serial_checkFieldRefs
        operations: {
          findUnique: {
            args: Prisma.serial_checkFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$serial_checkPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.serial_checkFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$serial_checkPayload>
          }
          findFirst: {
            args: Prisma.serial_checkFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$serial_checkPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.serial_checkFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$serial_checkPayload>
          }
          findMany: {
            args: Prisma.serial_checkFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$serial_checkPayload>[]
          }
          create: {
            args: Prisma.serial_checkCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$serial_checkPayload>
          }
          createMany: {
            args: Prisma.serial_checkCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.serial_checkDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$serial_checkPayload>
          }
          update: {
            args: Prisma.serial_checkUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$serial_checkPayload>
          }
          deleteMany: {
            args: Prisma.serial_checkDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.serial_checkUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.serial_checkUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$serial_checkPayload>
          }
          aggregate: {
            args: Prisma.Serial_checkAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSerial_check>
          }
          groupBy: {
            args: Prisma.serial_checkGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Serial_checkGroupByOutputType>[]
          }
          count: {
            args: Prisma.serial_checkCountArgs<ExtArgs>,
            result: $Utils.Optional<Serial_checkCountAggregateOutputType> | number
          }
        }
      }
      tahun_garansi: {
        payload: Prisma.$tahun_garansiPayload<ExtArgs>
        fields: Prisma.tahun_garansiFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tahun_garansiFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tahun_garansiPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tahun_garansiFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tahun_garansiPayload>
          }
          findFirst: {
            args: Prisma.tahun_garansiFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tahun_garansiPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tahun_garansiFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tahun_garansiPayload>
          }
          findMany: {
            args: Prisma.tahun_garansiFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tahun_garansiPayload>[]
          }
          create: {
            args: Prisma.tahun_garansiCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tahun_garansiPayload>
          }
          createMany: {
            args: Prisma.tahun_garansiCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.tahun_garansiDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tahun_garansiPayload>
          }
          update: {
            args: Prisma.tahun_garansiUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tahun_garansiPayload>
          }
          deleteMany: {
            args: Prisma.tahun_garansiDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.tahun_garansiUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.tahun_garansiUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tahun_garansiPayload>
          }
          aggregate: {
            args: Prisma.Tahun_garansiAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTahun_garansi>
          }
          groupBy: {
            args: Prisma.tahun_garansiGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Tahun_garansiGroupByOutputType>[]
          }
          count: {
            args: Prisma.tahun_garansiCountArgs<ExtArgs>,
            result: $Utils.Optional<Tahun_garansiCountAggregateOutputType> | number
          }
        }
      }
      temp_indicator: {
        payload: Prisma.$temp_indicatorPayload<ExtArgs>
        fields: Prisma.temp_indicatorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.temp_indicatorFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$temp_indicatorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.temp_indicatorFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$temp_indicatorPayload>
          }
          findFirst: {
            args: Prisma.temp_indicatorFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$temp_indicatorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.temp_indicatorFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$temp_indicatorPayload>
          }
          findMany: {
            args: Prisma.temp_indicatorFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$temp_indicatorPayload>[]
          }
          create: {
            args: Prisma.temp_indicatorCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$temp_indicatorPayload>
          }
          createMany: {
            args: Prisma.temp_indicatorCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.temp_indicatorDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$temp_indicatorPayload>
          }
          update: {
            args: Prisma.temp_indicatorUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$temp_indicatorPayload>
          }
          deleteMany: {
            args: Prisma.temp_indicatorDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.temp_indicatorUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.temp_indicatorUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$temp_indicatorPayload>
          }
          aggregate: {
            args: Prisma.Temp_indicatorAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTemp_indicator>
          }
          groupBy: {
            args: Prisma.temp_indicatorGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Temp_indicatorGroupByOutputType>[]
          }
          count: {
            args: Prisma.temp_indicatorCountArgs<ExtArgs>,
            result: $Utils.Optional<Temp_indicatorCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */



  /**
   * Models
   */

  /**
   * Model area_list
   */

  export type AggregateArea_list = {
    _count: Area_listCountAggregateOutputType | null
    _avg: Area_listAvgAggregateOutputType | null
    _sum: Area_listSumAggregateOutputType | null
    _min: Area_listMinAggregateOutputType | null
    _max: Area_listMaxAggregateOutputType | null
  }

  export type Area_listAvgAggregateOutputType = {
    id: number | null
  }

  export type Area_listSumAggregateOutputType = {
    id: number | null
  }

  export type Area_listMinAggregateOutputType = {
    id: number | null
    value: string | null
  }

  export type Area_listMaxAggregateOutputType = {
    id: number | null
    value: string | null
  }

  export type Area_listCountAggregateOutputType = {
    id: number
    value: number
    _all: number
  }


  export type Area_listAvgAggregateInputType = {
    id?: true
  }

  export type Area_listSumAggregateInputType = {
    id?: true
  }

  export type Area_listMinAggregateInputType = {
    id?: true
    value?: true
  }

  export type Area_listMaxAggregateInputType = {
    id?: true
    value?: true
  }

  export type Area_listCountAggregateInputType = {
    id?: true
    value?: true
    _all?: true
  }

  export type Area_listAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which area_list to aggregate.
     */
    where?: area_listWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of area_lists to fetch.
     */
    orderBy?: area_listOrderByWithRelationInput | area_listOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: area_listWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` area_lists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` area_lists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned area_lists
    **/
    _count?: true | Area_listCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Area_listAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Area_listSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Area_listMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Area_listMaxAggregateInputType
  }

  export type GetArea_listAggregateType<T extends Area_listAggregateArgs> = {
        [P in keyof T & keyof AggregateArea_list]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateArea_list[P]>
      : GetScalarType<T[P], AggregateArea_list[P]>
  }




  export type area_listGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: area_listWhereInput
    orderBy?: area_listOrderByWithAggregationInput | area_listOrderByWithAggregationInput[]
    by: Area_listScalarFieldEnum[] | Area_listScalarFieldEnum
    having?: area_listScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Area_listCountAggregateInputType | true
    _avg?: Area_listAvgAggregateInputType
    _sum?: Area_listSumAggregateInputType
    _min?: Area_listMinAggregateInputType
    _max?: Area_listMaxAggregateInputType
  }

  export type Area_listGroupByOutputType = {
    id: number
    value: string
    _count: Area_listCountAggregateOutputType | null
    _avg: Area_listAvgAggregateOutputType | null
    _sum: Area_listSumAggregateOutputType | null
    _min: Area_listMinAggregateOutputType | null
    _max: Area_listMaxAggregateOutputType | null
  }

  type GetArea_listGroupByPayload<T extends area_listGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Area_listGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Area_listGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Area_listGroupByOutputType[P]>
            : GetScalarType<T[P], Area_listGroupByOutputType[P]>
        }
      >
    >


  export type area_listSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
  }, ExtArgs["result"]["area_list"]>

  export type area_listSelectScalar = {
    id?: boolean
    value?: boolean
  }


  export type $area_listPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "area_list"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      value: string
    }, ExtArgs["result"]["area_list"]>
    composites: {}
  }


  type area_listGetPayload<S extends boolean | null | undefined | area_listDefaultArgs> = $Result.GetResult<Prisma.$area_listPayload, S>

  type area_listCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<area_listFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Area_listCountAggregateInputType | true
    }

  export interface area_listDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['area_list'], meta: { name: 'area_list' } }
    /**
     * Find zero or one Area_list that matches the filter.
     * @param {area_listFindUniqueArgs} args - Arguments to find a Area_list
     * @example
     * // Get one Area_list
     * const area_list = await prisma.area_list.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends area_listFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, area_listFindUniqueArgs<ExtArgs>>
    ): Prisma__area_listClient<$Result.GetResult<Prisma.$area_listPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Area_list that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {area_listFindUniqueOrThrowArgs} args - Arguments to find a Area_list
     * @example
     * // Get one Area_list
     * const area_list = await prisma.area_list.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends area_listFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, area_listFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__area_listClient<$Result.GetResult<Prisma.$area_listPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Area_list that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {area_listFindFirstArgs} args - Arguments to find a Area_list
     * @example
     * // Get one Area_list
     * const area_list = await prisma.area_list.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends area_listFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, area_listFindFirstArgs<ExtArgs>>
    ): Prisma__area_listClient<$Result.GetResult<Prisma.$area_listPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Area_list that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {area_listFindFirstOrThrowArgs} args - Arguments to find a Area_list
     * @example
     * // Get one Area_list
     * const area_list = await prisma.area_list.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends area_listFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, area_listFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__area_listClient<$Result.GetResult<Prisma.$area_listPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Area_lists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {area_listFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Area_lists
     * const area_lists = await prisma.area_list.findMany()
     * 
     * // Get first 10 Area_lists
     * const area_lists = await prisma.area_list.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const area_listWithIdOnly = await prisma.area_list.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends area_listFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, area_listFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$area_listPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Area_list.
     * @param {area_listCreateArgs} args - Arguments to create a Area_list.
     * @example
     * // Create one Area_list
     * const Area_list = await prisma.area_list.create({
     *   data: {
     *     // ... data to create a Area_list
     *   }
     * })
     * 
    **/
    create<T extends area_listCreateArgs<ExtArgs>>(
      args: SelectSubset<T, area_listCreateArgs<ExtArgs>>
    ): Prisma__area_listClient<$Result.GetResult<Prisma.$area_listPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Area_lists.
     *     @param {area_listCreateManyArgs} args - Arguments to create many Area_lists.
     *     @example
     *     // Create many Area_lists
     *     const area_list = await prisma.area_list.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends area_listCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, area_listCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Area_list.
     * @param {area_listDeleteArgs} args - Arguments to delete one Area_list.
     * @example
     * // Delete one Area_list
     * const Area_list = await prisma.area_list.delete({
     *   where: {
     *     // ... filter to delete one Area_list
     *   }
     * })
     * 
    **/
    delete<T extends area_listDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, area_listDeleteArgs<ExtArgs>>
    ): Prisma__area_listClient<$Result.GetResult<Prisma.$area_listPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Area_list.
     * @param {area_listUpdateArgs} args - Arguments to update one Area_list.
     * @example
     * // Update one Area_list
     * const area_list = await prisma.area_list.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends area_listUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, area_listUpdateArgs<ExtArgs>>
    ): Prisma__area_listClient<$Result.GetResult<Prisma.$area_listPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Area_lists.
     * @param {area_listDeleteManyArgs} args - Arguments to filter Area_lists to delete.
     * @example
     * // Delete a few Area_lists
     * const { count } = await prisma.area_list.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends area_listDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, area_listDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Area_lists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {area_listUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Area_lists
     * const area_list = await prisma.area_list.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends area_listUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, area_listUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Area_list.
     * @param {area_listUpsertArgs} args - Arguments to update or create a Area_list.
     * @example
     * // Update or create a Area_list
     * const area_list = await prisma.area_list.upsert({
     *   create: {
     *     // ... data to create a Area_list
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Area_list we want to update
     *   }
     * })
    **/
    upsert<T extends area_listUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, area_listUpsertArgs<ExtArgs>>
    ): Prisma__area_listClient<$Result.GetResult<Prisma.$area_listPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Area_lists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {area_listCountArgs} args - Arguments to filter Area_lists to count.
     * @example
     * // Count the number of Area_lists
     * const count = await prisma.area_list.count({
     *   where: {
     *     // ... the filter for the Area_lists we want to count
     *   }
     * })
    **/
    count<T extends area_listCountArgs>(
      args?: Subset<T, area_listCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Area_listCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Area_list.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Area_listAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Area_listAggregateArgs>(args: Subset<T, Area_listAggregateArgs>): Prisma.PrismaPromise<GetArea_listAggregateType<T>>

    /**
     * Group by Area_list.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {area_listGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends area_listGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: area_listGroupByArgs['orderBy'] }
        : { orderBy?: area_listGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, area_listGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetArea_listGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the area_list model
   */
  readonly fields: area_listFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for area_list.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__area_listClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the area_list model
   */ 
  interface area_listFieldRefs {
    readonly id: FieldRef<"area_list", 'Int'>
    readonly value: FieldRef<"area_list", 'String'>
  }
    

  // Custom InputTypes

  /**
   * area_list findUnique
   */
  export type area_listFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the area_list
     */
    select?: area_listSelect<ExtArgs> | null
    /**
     * Filter, which area_list to fetch.
     */
    where: area_listWhereUniqueInput
  }


  /**
   * area_list findUniqueOrThrow
   */
  export type area_listFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the area_list
     */
    select?: area_listSelect<ExtArgs> | null
    /**
     * Filter, which area_list to fetch.
     */
    where: area_listWhereUniqueInput
  }


  /**
   * area_list findFirst
   */
  export type area_listFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the area_list
     */
    select?: area_listSelect<ExtArgs> | null
    /**
     * Filter, which area_list to fetch.
     */
    where?: area_listWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of area_lists to fetch.
     */
    orderBy?: area_listOrderByWithRelationInput | area_listOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for area_lists.
     */
    cursor?: area_listWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` area_lists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` area_lists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of area_lists.
     */
    distinct?: Area_listScalarFieldEnum | Area_listScalarFieldEnum[]
  }


  /**
   * area_list findFirstOrThrow
   */
  export type area_listFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the area_list
     */
    select?: area_listSelect<ExtArgs> | null
    /**
     * Filter, which area_list to fetch.
     */
    where?: area_listWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of area_lists to fetch.
     */
    orderBy?: area_listOrderByWithRelationInput | area_listOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for area_lists.
     */
    cursor?: area_listWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` area_lists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` area_lists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of area_lists.
     */
    distinct?: Area_listScalarFieldEnum | Area_listScalarFieldEnum[]
  }


  /**
   * area_list findMany
   */
  export type area_listFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the area_list
     */
    select?: area_listSelect<ExtArgs> | null
    /**
     * Filter, which area_lists to fetch.
     */
    where?: area_listWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of area_lists to fetch.
     */
    orderBy?: area_listOrderByWithRelationInput | area_listOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing area_lists.
     */
    cursor?: area_listWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` area_lists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` area_lists.
     */
    skip?: number
    distinct?: Area_listScalarFieldEnum | Area_listScalarFieldEnum[]
  }


  /**
   * area_list create
   */
  export type area_listCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the area_list
     */
    select?: area_listSelect<ExtArgs> | null
    /**
     * The data needed to create a area_list.
     */
    data: XOR<area_listCreateInput, area_listUncheckedCreateInput>
  }


  /**
   * area_list createMany
   */
  export type area_listCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many area_lists.
     */
    data: area_listCreateManyInput | area_listCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * area_list update
   */
  export type area_listUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the area_list
     */
    select?: area_listSelect<ExtArgs> | null
    /**
     * The data needed to update a area_list.
     */
    data: XOR<area_listUpdateInput, area_listUncheckedUpdateInput>
    /**
     * Choose, which area_list to update.
     */
    where: area_listWhereUniqueInput
  }


  /**
   * area_list updateMany
   */
  export type area_listUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update area_lists.
     */
    data: XOR<area_listUpdateManyMutationInput, area_listUncheckedUpdateManyInput>
    /**
     * Filter which area_lists to update
     */
    where?: area_listWhereInput
  }


  /**
   * area_list upsert
   */
  export type area_listUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the area_list
     */
    select?: area_listSelect<ExtArgs> | null
    /**
     * The filter to search for the area_list to update in case it exists.
     */
    where: area_listWhereUniqueInput
    /**
     * In case the area_list found by the `where` argument doesn't exist, create a new area_list with this data.
     */
    create: XOR<area_listCreateInput, area_listUncheckedCreateInput>
    /**
     * In case the area_list was found with the provided `where` argument, update it with this data.
     */
    update: XOR<area_listUpdateInput, area_listUncheckedUpdateInput>
  }


  /**
   * area_list delete
   */
  export type area_listDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the area_list
     */
    select?: area_listSelect<ExtArgs> | null
    /**
     * Filter which area_list to delete.
     */
    where: area_listWhereUniqueInput
  }


  /**
   * area_list deleteMany
   */
  export type area_listDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which area_lists to delete
     */
    where?: area_listWhereInput
  }


  /**
   * area_list without action
   */
  export type area_listDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the area_list
     */
    select?: area_listSelect<ExtArgs> | null
  }



  /**
   * Model attachment
   */

  export type AggregateAttachment = {
    _count: AttachmentCountAggregateOutputType | null
    _avg: AttachmentAvgAggregateOutputType | null
    _sum: AttachmentSumAggregateOutputType | null
    _min: AttachmentMinAggregateOutputType | null
    _max: AttachmentMaxAggregateOutputType | null
  }

  export type AttachmentAvgAggregateOutputType = {
    id: number | null
    qty: number | null
    used_qty: number | null
  }

  export type AttachmentSumAggregateOutputType = {
    id: number | null
    qty: number | null
    used_qty: number | null
  }

  export type AttachmentMinAggregateOutputType = {
    id: number | null
    nomor: string | null
    timestamp: Date | null
    type: string | null
    no_do: string | null
    no_order: string | null
    tgl_order: Date | null
    area: string | null
    status: boolean | null
    active: boolean | null
    qty: number | null
    used_qty: number | null
  }

  export type AttachmentMaxAggregateOutputType = {
    id: number | null
    nomor: string | null
    timestamp: Date | null
    type: string | null
    no_do: string | null
    no_order: string | null
    tgl_order: Date | null
    area: string | null
    status: boolean | null
    active: boolean | null
    qty: number | null
    used_qty: number | null
  }

  export type AttachmentCountAggregateOutputType = {
    id: number
    nomor: number
    timestamp: number
    type: number
    no_do: number
    no_order: number
    tgl_order: number
    area: number
    status: number
    active: number
    qty: number
    used_qty: number
    _all: number
  }


  export type AttachmentAvgAggregateInputType = {
    id?: true
    qty?: true
    used_qty?: true
  }

  export type AttachmentSumAggregateInputType = {
    id?: true
    qty?: true
    used_qty?: true
  }

  export type AttachmentMinAggregateInputType = {
    id?: true
    nomor?: true
    timestamp?: true
    type?: true
    no_do?: true
    no_order?: true
    tgl_order?: true
    area?: true
    status?: true
    active?: true
    qty?: true
    used_qty?: true
  }

  export type AttachmentMaxAggregateInputType = {
    id?: true
    nomor?: true
    timestamp?: true
    type?: true
    no_do?: true
    no_order?: true
    tgl_order?: true
    area?: true
    status?: true
    active?: true
    qty?: true
    used_qty?: true
  }

  export type AttachmentCountAggregateInputType = {
    id?: true
    nomor?: true
    timestamp?: true
    type?: true
    no_do?: true
    no_order?: true
    tgl_order?: true
    area?: true
    status?: true
    active?: true
    qty?: true
    used_qty?: true
    _all?: true
  }

  export type AttachmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which attachment to aggregate.
     */
    where?: attachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of attachments to fetch.
     */
    orderBy?: attachmentOrderByWithRelationInput | attachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: attachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` attachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` attachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned attachments
    **/
    _count?: true | AttachmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AttachmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AttachmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AttachmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AttachmentMaxAggregateInputType
  }

  export type GetAttachmentAggregateType<T extends AttachmentAggregateArgs> = {
        [P in keyof T & keyof AggregateAttachment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAttachment[P]>
      : GetScalarType<T[P], AggregateAttachment[P]>
  }




  export type attachmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: attachmentWhereInput
    orderBy?: attachmentOrderByWithAggregationInput | attachmentOrderByWithAggregationInput[]
    by: AttachmentScalarFieldEnum[] | AttachmentScalarFieldEnum
    having?: attachmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AttachmentCountAggregateInputType | true
    _avg?: AttachmentAvgAggregateInputType
    _sum?: AttachmentSumAggregateInputType
    _min?: AttachmentMinAggregateInputType
    _max?: AttachmentMaxAggregateInputType
  }

  export type AttachmentGroupByOutputType = {
    id: number
    nomor: string
    timestamp: Date
    type: string
    no_do: string
    no_order: string
    tgl_order: Date
    area: string
    status: boolean
    active: boolean
    qty: number
    used_qty: number
    _count: AttachmentCountAggregateOutputType | null
    _avg: AttachmentAvgAggregateOutputType | null
    _sum: AttachmentSumAggregateOutputType | null
    _min: AttachmentMinAggregateOutputType | null
    _max: AttachmentMaxAggregateOutputType | null
  }

  type GetAttachmentGroupByPayload<T extends attachmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AttachmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AttachmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AttachmentGroupByOutputType[P]>
            : GetScalarType<T[P], AttachmentGroupByOutputType[P]>
        }
      >
    >


  export type attachmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nomor?: boolean
    timestamp?: boolean
    type?: boolean
    no_do?: boolean
    no_order?: boolean
    tgl_order?: boolean
    area?: boolean
    status?: boolean
    active?: boolean
    qty?: boolean
    used_qty?: boolean
  }, ExtArgs["result"]["attachment"]>

  export type attachmentSelectScalar = {
    id?: boolean
    nomor?: boolean
    timestamp?: boolean
    type?: boolean
    no_do?: boolean
    no_order?: boolean
    tgl_order?: boolean
    area?: boolean
    status?: boolean
    active?: boolean
    qty?: boolean
    used_qty?: boolean
  }


  export type $attachmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "attachment"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nomor: string
      timestamp: Date
      type: string
      no_do: string
      no_order: string
      tgl_order: Date
      area: string
      status: boolean
      active: boolean
      qty: number
      used_qty: number
    }, ExtArgs["result"]["attachment"]>
    composites: {}
  }


  type attachmentGetPayload<S extends boolean | null | undefined | attachmentDefaultArgs> = $Result.GetResult<Prisma.$attachmentPayload, S>

  type attachmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<attachmentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AttachmentCountAggregateInputType | true
    }

  export interface attachmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['attachment'], meta: { name: 'attachment' } }
    /**
     * Find zero or one Attachment that matches the filter.
     * @param {attachmentFindUniqueArgs} args - Arguments to find a Attachment
     * @example
     * // Get one Attachment
     * const attachment = await prisma.attachment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends attachmentFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, attachmentFindUniqueArgs<ExtArgs>>
    ): Prisma__attachmentClient<$Result.GetResult<Prisma.$attachmentPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Attachment that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {attachmentFindUniqueOrThrowArgs} args - Arguments to find a Attachment
     * @example
     * // Get one Attachment
     * const attachment = await prisma.attachment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends attachmentFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, attachmentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__attachmentClient<$Result.GetResult<Prisma.$attachmentPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Attachment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {attachmentFindFirstArgs} args - Arguments to find a Attachment
     * @example
     * // Get one Attachment
     * const attachment = await prisma.attachment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends attachmentFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, attachmentFindFirstArgs<ExtArgs>>
    ): Prisma__attachmentClient<$Result.GetResult<Prisma.$attachmentPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Attachment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {attachmentFindFirstOrThrowArgs} args - Arguments to find a Attachment
     * @example
     * // Get one Attachment
     * const attachment = await prisma.attachment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends attachmentFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, attachmentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__attachmentClient<$Result.GetResult<Prisma.$attachmentPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Attachments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {attachmentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Attachments
     * const attachments = await prisma.attachment.findMany()
     * 
     * // Get first 10 Attachments
     * const attachments = await prisma.attachment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const attachmentWithIdOnly = await prisma.attachment.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends attachmentFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, attachmentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$attachmentPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Attachment.
     * @param {attachmentCreateArgs} args - Arguments to create a Attachment.
     * @example
     * // Create one Attachment
     * const Attachment = await prisma.attachment.create({
     *   data: {
     *     // ... data to create a Attachment
     *   }
     * })
     * 
    **/
    create<T extends attachmentCreateArgs<ExtArgs>>(
      args: SelectSubset<T, attachmentCreateArgs<ExtArgs>>
    ): Prisma__attachmentClient<$Result.GetResult<Prisma.$attachmentPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Attachments.
     *     @param {attachmentCreateManyArgs} args - Arguments to create many Attachments.
     *     @example
     *     // Create many Attachments
     *     const attachment = await prisma.attachment.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends attachmentCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, attachmentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Attachment.
     * @param {attachmentDeleteArgs} args - Arguments to delete one Attachment.
     * @example
     * // Delete one Attachment
     * const Attachment = await prisma.attachment.delete({
     *   where: {
     *     // ... filter to delete one Attachment
     *   }
     * })
     * 
    **/
    delete<T extends attachmentDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, attachmentDeleteArgs<ExtArgs>>
    ): Prisma__attachmentClient<$Result.GetResult<Prisma.$attachmentPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Attachment.
     * @param {attachmentUpdateArgs} args - Arguments to update one Attachment.
     * @example
     * // Update one Attachment
     * const attachment = await prisma.attachment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends attachmentUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, attachmentUpdateArgs<ExtArgs>>
    ): Prisma__attachmentClient<$Result.GetResult<Prisma.$attachmentPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Attachments.
     * @param {attachmentDeleteManyArgs} args - Arguments to filter Attachments to delete.
     * @example
     * // Delete a few Attachments
     * const { count } = await prisma.attachment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends attachmentDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, attachmentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Attachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {attachmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Attachments
     * const attachment = await prisma.attachment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends attachmentUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, attachmentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Attachment.
     * @param {attachmentUpsertArgs} args - Arguments to update or create a Attachment.
     * @example
     * // Update or create a Attachment
     * const attachment = await prisma.attachment.upsert({
     *   create: {
     *     // ... data to create a Attachment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Attachment we want to update
     *   }
     * })
    **/
    upsert<T extends attachmentUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, attachmentUpsertArgs<ExtArgs>>
    ): Prisma__attachmentClient<$Result.GetResult<Prisma.$attachmentPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Attachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {attachmentCountArgs} args - Arguments to filter Attachments to count.
     * @example
     * // Count the number of Attachments
     * const count = await prisma.attachment.count({
     *   where: {
     *     // ... the filter for the Attachments we want to count
     *   }
     * })
    **/
    count<T extends attachmentCountArgs>(
      args?: Subset<T, attachmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AttachmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Attachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AttachmentAggregateArgs>(args: Subset<T, AttachmentAggregateArgs>): Prisma.PrismaPromise<GetAttachmentAggregateType<T>>

    /**
     * Group by Attachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {attachmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends attachmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: attachmentGroupByArgs['orderBy'] }
        : { orderBy?: attachmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, attachmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAttachmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the attachment model
   */
  readonly fields: attachmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for attachment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__attachmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the attachment model
   */ 
  interface attachmentFieldRefs {
    readonly id: FieldRef<"attachment", 'Int'>
    readonly nomor: FieldRef<"attachment", 'String'>
    readonly timestamp: FieldRef<"attachment", 'DateTime'>
    readonly type: FieldRef<"attachment", 'String'>
    readonly no_do: FieldRef<"attachment", 'String'>
    readonly no_order: FieldRef<"attachment", 'String'>
    readonly tgl_order: FieldRef<"attachment", 'DateTime'>
    readonly area: FieldRef<"attachment", 'String'>
    readonly status: FieldRef<"attachment", 'Boolean'>
    readonly active: FieldRef<"attachment", 'Boolean'>
    readonly qty: FieldRef<"attachment", 'Int'>
    readonly used_qty: FieldRef<"attachment", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * attachment findUnique
   */
  export type attachmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attachment
     */
    select?: attachmentSelect<ExtArgs> | null
    /**
     * Filter, which attachment to fetch.
     */
    where: attachmentWhereUniqueInput
  }


  /**
   * attachment findUniqueOrThrow
   */
  export type attachmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attachment
     */
    select?: attachmentSelect<ExtArgs> | null
    /**
     * Filter, which attachment to fetch.
     */
    where: attachmentWhereUniqueInput
  }


  /**
   * attachment findFirst
   */
  export type attachmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attachment
     */
    select?: attachmentSelect<ExtArgs> | null
    /**
     * Filter, which attachment to fetch.
     */
    where?: attachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of attachments to fetch.
     */
    orderBy?: attachmentOrderByWithRelationInput | attachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for attachments.
     */
    cursor?: attachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` attachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` attachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of attachments.
     */
    distinct?: AttachmentScalarFieldEnum | AttachmentScalarFieldEnum[]
  }


  /**
   * attachment findFirstOrThrow
   */
  export type attachmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attachment
     */
    select?: attachmentSelect<ExtArgs> | null
    /**
     * Filter, which attachment to fetch.
     */
    where?: attachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of attachments to fetch.
     */
    orderBy?: attachmentOrderByWithRelationInput | attachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for attachments.
     */
    cursor?: attachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` attachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` attachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of attachments.
     */
    distinct?: AttachmentScalarFieldEnum | AttachmentScalarFieldEnum[]
  }


  /**
   * attachment findMany
   */
  export type attachmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attachment
     */
    select?: attachmentSelect<ExtArgs> | null
    /**
     * Filter, which attachments to fetch.
     */
    where?: attachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of attachments to fetch.
     */
    orderBy?: attachmentOrderByWithRelationInput | attachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing attachments.
     */
    cursor?: attachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` attachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` attachments.
     */
    skip?: number
    distinct?: AttachmentScalarFieldEnum | AttachmentScalarFieldEnum[]
  }


  /**
   * attachment create
   */
  export type attachmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attachment
     */
    select?: attachmentSelect<ExtArgs> | null
    /**
     * The data needed to create a attachment.
     */
    data: XOR<attachmentCreateInput, attachmentUncheckedCreateInput>
  }


  /**
   * attachment createMany
   */
  export type attachmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many attachments.
     */
    data: attachmentCreateManyInput | attachmentCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * attachment update
   */
  export type attachmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attachment
     */
    select?: attachmentSelect<ExtArgs> | null
    /**
     * The data needed to update a attachment.
     */
    data: XOR<attachmentUpdateInput, attachmentUncheckedUpdateInput>
    /**
     * Choose, which attachment to update.
     */
    where: attachmentWhereUniqueInput
  }


  /**
   * attachment updateMany
   */
  export type attachmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update attachments.
     */
    data: XOR<attachmentUpdateManyMutationInput, attachmentUncheckedUpdateManyInput>
    /**
     * Filter which attachments to update
     */
    where?: attachmentWhereInput
  }


  /**
   * attachment upsert
   */
  export type attachmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attachment
     */
    select?: attachmentSelect<ExtArgs> | null
    /**
     * The filter to search for the attachment to update in case it exists.
     */
    where: attachmentWhereUniqueInput
    /**
     * In case the attachment found by the `where` argument doesn't exist, create a new attachment with this data.
     */
    create: XOR<attachmentCreateInput, attachmentUncheckedCreateInput>
    /**
     * In case the attachment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<attachmentUpdateInput, attachmentUncheckedUpdateInput>
  }


  /**
   * attachment delete
   */
  export type attachmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attachment
     */
    select?: attachmentSelect<ExtArgs> | null
    /**
     * Filter which attachment to delete.
     */
    where: attachmentWhereUniqueInput
  }


  /**
   * attachment deleteMany
   */
  export type attachmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which attachments to delete
     */
    where?: attachmentWhereInput
  }


  /**
   * attachment without action
   */
  export type attachmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attachment
     */
    select?: attachmentSelect<ExtArgs> | null
  }



  /**
   * Model attachment2
   */

  export type AggregateAttachment2 = {
    _count: Attachment2CountAggregateOutputType | null
    _avg: Attachment2AvgAggregateOutputType | null
    _sum: Attachment2SumAggregateOutputType | null
    _min: Attachment2MinAggregateOutputType | null
    _max: Attachment2MaxAggregateOutputType | null
  }

  export type Attachment2AvgAggregateOutputType = {
    id: number | null
  }

  export type Attachment2SumAggregateOutputType = {
    id: number | null
  }

  export type Attachment2MinAggregateOutputType = {
    id: number | null
    nomor: string | null
    timestamp: Date | null
    type: string | null
    no_do: string | null
    no_order: string | null
    tgl_order: Date | null
    area: string | null
    status: boolean | null
    active: boolean | null
  }

  export type Attachment2MaxAggregateOutputType = {
    id: number | null
    nomor: string | null
    timestamp: Date | null
    type: string | null
    no_do: string | null
    no_order: string | null
    tgl_order: Date | null
    area: string | null
    status: boolean | null
    active: boolean | null
  }

  export type Attachment2CountAggregateOutputType = {
    id: number
    nomor: number
    timestamp: number
    type: number
    no_do: number
    no_order: number
    tgl_order: number
    area: number
    status: number
    active: number
    _all: number
  }


  export type Attachment2AvgAggregateInputType = {
    id?: true
  }

  export type Attachment2SumAggregateInputType = {
    id?: true
  }

  export type Attachment2MinAggregateInputType = {
    id?: true
    nomor?: true
    timestamp?: true
    type?: true
    no_do?: true
    no_order?: true
    tgl_order?: true
    area?: true
    status?: true
    active?: true
  }

  export type Attachment2MaxAggregateInputType = {
    id?: true
    nomor?: true
    timestamp?: true
    type?: true
    no_do?: true
    no_order?: true
    tgl_order?: true
    area?: true
    status?: true
    active?: true
  }

  export type Attachment2CountAggregateInputType = {
    id?: true
    nomor?: true
    timestamp?: true
    type?: true
    no_do?: true
    no_order?: true
    tgl_order?: true
    area?: true
    status?: true
    active?: true
    _all?: true
  }

  export type Attachment2AggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which attachment2 to aggregate.
     */
    where?: attachment2WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of attachment2s to fetch.
     */
    orderBy?: attachment2OrderByWithRelationInput | attachment2OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: attachment2WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` attachment2s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` attachment2s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned attachment2s
    **/
    _count?: true | Attachment2CountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Attachment2AvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Attachment2SumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Attachment2MinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Attachment2MaxAggregateInputType
  }

  export type GetAttachment2AggregateType<T extends Attachment2AggregateArgs> = {
        [P in keyof T & keyof AggregateAttachment2]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAttachment2[P]>
      : GetScalarType<T[P], AggregateAttachment2[P]>
  }




  export type attachment2GroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: attachment2WhereInput
    orderBy?: attachment2OrderByWithAggregationInput | attachment2OrderByWithAggregationInput[]
    by: Attachment2ScalarFieldEnum[] | Attachment2ScalarFieldEnum
    having?: attachment2ScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Attachment2CountAggregateInputType | true
    _avg?: Attachment2AvgAggregateInputType
    _sum?: Attachment2SumAggregateInputType
    _min?: Attachment2MinAggregateInputType
    _max?: Attachment2MaxAggregateInputType
  }

  export type Attachment2GroupByOutputType = {
    id: number
    nomor: string
    timestamp: Date
    type: string
    no_do: string
    no_order: string
    tgl_order: Date
    area: string
    status: boolean
    active: boolean
    _count: Attachment2CountAggregateOutputType | null
    _avg: Attachment2AvgAggregateOutputType | null
    _sum: Attachment2SumAggregateOutputType | null
    _min: Attachment2MinAggregateOutputType | null
    _max: Attachment2MaxAggregateOutputType | null
  }

  type GetAttachment2GroupByPayload<T extends attachment2GroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Attachment2GroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Attachment2GroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Attachment2GroupByOutputType[P]>
            : GetScalarType<T[P], Attachment2GroupByOutputType[P]>
        }
      >
    >


  export type attachment2Select<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nomor?: boolean
    timestamp?: boolean
    type?: boolean
    no_do?: boolean
    no_order?: boolean
    tgl_order?: boolean
    area?: boolean
    status?: boolean
    active?: boolean
  }, ExtArgs["result"]["attachment2"]>

  export type attachment2SelectScalar = {
    id?: boolean
    nomor?: boolean
    timestamp?: boolean
    type?: boolean
    no_do?: boolean
    no_order?: boolean
    tgl_order?: boolean
    area?: boolean
    status?: boolean
    active?: boolean
  }


  export type $attachment2Payload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "attachment2"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nomor: string
      timestamp: Date
      type: string
      no_do: string
      no_order: string
      tgl_order: Date
      area: string
      status: boolean
      active: boolean
    }, ExtArgs["result"]["attachment2"]>
    composites: {}
  }


  type attachment2GetPayload<S extends boolean | null | undefined | attachment2DefaultArgs> = $Result.GetResult<Prisma.$attachment2Payload, S>

  type attachment2CountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<attachment2FindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Attachment2CountAggregateInputType | true
    }

  export interface attachment2Delegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['attachment2'], meta: { name: 'attachment2' } }
    /**
     * Find zero or one Attachment2 that matches the filter.
     * @param {attachment2FindUniqueArgs} args - Arguments to find a Attachment2
     * @example
     * // Get one Attachment2
     * const attachment2 = await prisma.attachment2.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends attachment2FindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, attachment2FindUniqueArgs<ExtArgs>>
    ): Prisma__attachment2Client<$Result.GetResult<Prisma.$attachment2Payload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Attachment2 that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {attachment2FindUniqueOrThrowArgs} args - Arguments to find a Attachment2
     * @example
     * // Get one Attachment2
     * const attachment2 = await prisma.attachment2.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends attachment2FindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, attachment2FindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__attachment2Client<$Result.GetResult<Prisma.$attachment2Payload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Attachment2 that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {attachment2FindFirstArgs} args - Arguments to find a Attachment2
     * @example
     * // Get one Attachment2
     * const attachment2 = await prisma.attachment2.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends attachment2FindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, attachment2FindFirstArgs<ExtArgs>>
    ): Prisma__attachment2Client<$Result.GetResult<Prisma.$attachment2Payload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Attachment2 that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {attachment2FindFirstOrThrowArgs} args - Arguments to find a Attachment2
     * @example
     * // Get one Attachment2
     * const attachment2 = await prisma.attachment2.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends attachment2FindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, attachment2FindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__attachment2Client<$Result.GetResult<Prisma.$attachment2Payload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Attachment2s that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {attachment2FindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Attachment2s
     * const attachment2s = await prisma.attachment2.findMany()
     * 
     * // Get first 10 Attachment2s
     * const attachment2s = await prisma.attachment2.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const attachment2WithIdOnly = await prisma.attachment2.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends attachment2FindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, attachment2FindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$attachment2Payload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Attachment2.
     * @param {attachment2CreateArgs} args - Arguments to create a Attachment2.
     * @example
     * // Create one Attachment2
     * const Attachment2 = await prisma.attachment2.create({
     *   data: {
     *     // ... data to create a Attachment2
     *   }
     * })
     * 
    **/
    create<T extends attachment2CreateArgs<ExtArgs>>(
      args: SelectSubset<T, attachment2CreateArgs<ExtArgs>>
    ): Prisma__attachment2Client<$Result.GetResult<Prisma.$attachment2Payload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Attachment2s.
     *     @param {attachment2CreateManyArgs} args - Arguments to create many Attachment2s.
     *     @example
     *     // Create many Attachment2s
     *     const attachment2 = await prisma.attachment2.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends attachment2CreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, attachment2CreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Attachment2.
     * @param {attachment2DeleteArgs} args - Arguments to delete one Attachment2.
     * @example
     * // Delete one Attachment2
     * const Attachment2 = await prisma.attachment2.delete({
     *   where: {
     *     // ... filter to delete one Attachment2
     *   }
     * })
     * 
    **/
    delete<T extends attachment2DeleteArgs<ExtArgs>>(
      args: SelectSubset<T, attachment2DeleteArgs<ExtArgs>>
    ): Prisma__attachment2Client<$Result.GetResult<Prisma.$attachment2Payload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Attachment2.
     * @param {attachment2UpdateArgs} args - Arguments to update one Attachment2.
     * @example
     * // Update one Attachment2
     * const attachment2 = await prisma.attachment2.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends attachment2UpdateArgs<ExtArgs>>(
      args: SelectSubset<T, attachment2UpdateArgs<ExtArgs>>
    ): Prisma__attachment2Client<$Result.GetResult<Prisma.$attachment2Payload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Attachment2s.
     * @param {attachment2DeleteManyArgs} args - Arguments to filter Attachment2s to delete.
     * @example
     * // Delete a few Attachment2s
     * const { count } = await prisma.attachment2.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends attachment2DeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, attachment2DeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Attachment2s.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {attachment2UpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Attachment2s
     * const attachment2 = await prisma.attachment2.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends attachment2UpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, attachment2UpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Attachment2.
     * @param {attachment2UpsertArgs} args - Arguments to update or create a Attachment2.
     * @example
     * // Update or create a Attachment2
     * const attachment2 = await prisma.attachment2.upsert({
     *   create: {
     *     // ... data to create a Attachment2
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Attachment2 we want to update
     *   }
     * })
    **/
    upsert<T extends attachment2UpsertArgs<ExtArgs>>(
      args: SelectSubset<T, attachment2UpsertArgs<ExtArgs>>
    ): Prisma__attachment2Client<$Result.GetResult<Prisma.$attachment2Payload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Attachment2s.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {attachment2CountArgs} args - Arguments to filter Attachment2s to count.
     * @example
     * // Count the number of Attachment2s
     * const count = await prisma.attachment2.count({
     *   where: {
     *     // ... the filter for the Attachment2s we want to count
     *   }
     * })
    **/
    count<T extends attachment2CountArgs>(
      args?: Subset<T, attachment2CountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Attachment2CountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Attachment2.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Attachment2AggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Attachment2AggregateArgs>(args: Subset<T, Attachment2AggregateArgs>): Prisma.PrismaPromise<GetAttachment2AggregateType<T>>

    /**
     * Group by Attachment2.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {attachment2GroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends attachment2GroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: attachment2GroupByArgs['orderBy'] }
        : { orderBy?: attachment2GroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, attachment2GroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAttachment2GroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the attachment2 model
   */
  readonly fields: attachment2FieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for attachment2.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__attachment2Client<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the attachment2 model
   */ 
  interface attachment2FieldRefs {
    readonly id: FieldRef<"attachment2", 'Int'>
    readonly nomor: FieldRef<"attachment2", 'String'>
    readonly timestamp: FieldRef<"attachment2", 'DateTime'>
    readonly type: FieldRef<"attachment2", 'String'>
    readonly no_do: FieldRef<"attachment2", 'String'>
    readonly no_order: FieldRef<"attachment2", 'String'>
    readonly tgl_order: FieldRef<"attachment2", 'DateTime'>
    readonly area: FieldRef<"attachment2", 'String'>
    readonly status: FieldRef<"attachment2", 'Boolean'>
    readonly active: FieldRef<"attachment2", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * attachment2 findUnique
   */
  export type attachment2FindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attachment2
     */
    select?: attachment2Select<ExtArgs> | null
    /**
     * Filter, which attachment2 to fetch.
     */
    where: attachment2WhereUniqueInput
  }


  /**
   * attachment2 findUniqueOrThrow
   */
  export type attachment2FindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attachment2
     */
    select?: attachment2Select<ExtArgs> | null
    /**
     * Filter, which attachment2 to fetch.
     */
    where: attachment2WhereUniqueInput
  }


  /**
   * attachment2 findFirst
   */
  export type attachment2FindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attachment2
     */
    select?: attachment2Select<ExtArgs> | null
    /**
     * Filter, which attachment2 to fetch.
     */
    where?: attachment2WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of attachment2s to fetch.
     */
    orderBy?: attachment2OrderByWithRelationInput | attachment2OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for attachment2s.
     */
    cursor?: attachment2WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` attachment2s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` attachment2s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of attachment2s.
     */
    distinct?: Attachment2ScalarFieldEnum | Attachment2ScalarFieldEnum[]
  }


  /**
   * attachment2 findFirstOrThrow
   */
  export type attachment2FindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attachment2
     */
    select?: attachment2Select<ExtArgs> | null
    /**
     * Filter, which attachment2 to fetch.
     */
    where?: attachment2WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of attachment2s to fetch.
     */
    orderBy?: attachment2OrderByWithRelationInput | attachment2OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for attachment2s.
     */
    cursor?: attachment2WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` attachment2s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` attachment2s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of attachment2s.
     */
    distinct?: Attachment2ScalarFieldEnum | Attachment2ScalarFieldEnum[]
  }


  /**
   * attachment2 findMany
   */
  export type attachment2FindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attachment2
     */
    select?: attachment2Select<ExtArgs> | null
    /**
     * Filter, which attachment2s to fetch.
     */
    where?: attachment2WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of attachment2s to fetch.
     */
    orderBy?: attachment2OrderByWithRelationInput | attachment2OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing attachment2s.
     */
    cursor?: attachment2WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` attachment2s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` attachment2s.
     */
    skip?: number
    distinct?: Attachment2ScalarFieldEnum | Attachment2ScalarFieldEnum[]
  }


  /**
   * attachment2 create
   */
  export type attachment2CreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attachment2
     */
    select?: attachment2Select<ExtArgs> | null
    /**
     * The data needed to create a attachment2.
     */
    data: XOR<attachment2CreateInput, attachment2UncheckedCreateInput>
  }


  /**
   * attachment2 createMany
   */
  export type attachment2CreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many attachment2s.
     */
    data: attachment2CreateManyInput | attachment2CreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * attachment2 update
   */
  export type attachment2UpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attachment2
     */
    select?: attachment2Select<ExtArgs> | null
    /**
     * The data needed to update a attachment2.
     */
    data: XOR<attachment2UpdateInput, attachment2UncheckedUpdateInput>
    /**
     * Choose, which attachment2 to update.
     */
    where: attachment2WhereUniqueInput
  }


  /**
   * attachment2 updateMany
   */
  export type attachment2UpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update attachment2s.
     */
    data: XOR<attachment2UpdateManyMutationInput, attachment2UncheckedUpdateManyInput>
    /**
     * Filter which attachment2s to update
     */
    where?: attachment2WhereInput
  }


  /**
   * attachment2 upsert
   */
  export type attachment2UpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attachment2
     */
    select?: attachment2Select<ExtArgs> | null
    /**
     * The filter to search for the attachment2 to update in case it exists.
     */
    where: attachment2WhereUniqueInput
    /**
     * In case the attachment2 found by the `where` argument doesn't exist, create a new attachment2 with this data.
     */
    create: XOR<attachment2CreateInput, attachment2UncheckedCreateInput>
    /**
     * In case the attachment2 was found with the provided `where` argument, update it with this data.
     */
    update: XOR<attachment2UpdateInput, attachment2UncheckedUpdateInput>
  }


  /**
   * attachment2 delete
   */
  export type attachment2DeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attachment2
     */
    select?: attachment2Select<ExtArgs> | null
    /**
     * Filter which attachment2 to delete.
     */
    where: attachment2WhereUniqueInput
  }


  /**
   * attachment2 deleteMany
   */
  export type attachment2DeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which attachment2s to delete
     */
    where?: attachment2WhereInput
  }


  /**
   * attachment2 without action
   */
  export type attachment2DefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attachment2
     */
    select?: attachment2Select<ExtArgs> | null
  }



  /**
   * Model box
   */

  export type AggregateBox = {
    _count: BoxCountAggregateOutputType | null
    _avg: BoxAvgAggregateOutputType | null
    _sum: BoxSumAggregateOutputType | null
    _min: BoxMinAggregateOutputType | null
    _max: BoxMaxAggregateOutputType | null
  }

  export type BoxAvgAggregateOutputType = {
    id: number | null
    pallete_id: number | null
    attachment_id: number | null
    attachment2_id: number | null
  }

  export type BoxSumAggregateOutputType = {
    id: number | null
    pallete_id: number | null
    attachment_id: number | null
    attachment2_id: number | null
  }

  export type BoxMinAggregateOutputType = {
    id: number | null
    serial: string | null
    timestamp: Date | null
    line: string | null
    type: string | null
    pallete_id: number | null
    attachment_id: number | null
    attachment2_id: number | null
    remain: string | null
  }

  export type BoxMaxAggregateOutputType = {
    id: number | null
    serial: string | null
    timestamp: Date | null
    line: string | null
    type: string | null
    pallete_id: number | null
    attachment_id: number | null
    attachment2_id: number | null
    remain: string | null
  }

  export type BoxCountAggregateOutputType = {
    id: number
    serial: number
    timestamp: number
    line: number
    type: number
    pallete_id: number
    attachment_id: number
    attachment2_id: number
    remain: number
    _all: number
  }


  export type BoxAvgAggregateInputType = {
    id?: true
    pallete_id?: true
    attachment_id?: true
    attachment2_id?: true
  }

  export type BoxSumAggregateInputType = {
    id?: true
    pallete_id?: true
    attachment_id?: true
    attachment2_id?: true
  }

  export type BoxMinAggregateInputType = {
    id?: true
    serial?: true
    timestamp?: true
    line?: true
    type?: true
    pallete_id?: true
    attachment_id?: true
    attachment2_id?: true
    remain?: true
  }

  export type BoxMaxAggregateInputType = {
    id?: true
    serial?: true
    timestamp?: true
    line?: true
    type?: true
    pallete_id?: true
    attachment_id?: true
    attachment2_id?: true
    remain?: true
  }

  export type BoxCountAggregateInputType = {
    id?: true
    serial?: true
    timestamp?: true
    line?: true
    type?: true
    pallete_id?: true
    attachment_id?: true
    attachment2_id?: true
    remain?: true
    _all?: true
  }

  export type BoxAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which box to aggregate.
     */
    where?: boxWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of boxes to fetch.
     */
    orderBy?: boxOrderByWithRelationInput | boxOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: boxWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` boxes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` boxes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned boxes
    **/
    _count?: true | BoxCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BoxAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BoxSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BoxMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BoxMaxAggregateInputType
  }

  export type GetBoxAggregateType<T extends BoxAggregateArgs> = {
        [P in keyof T & keyof AggregateBox]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBox[P]>
      : GetScalarType<T[P], AggregateBox[P]>
  }




  export type boxGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: boxWhereInput
    orderBy?: boxOrderByWithAggregationInput | boxOrderByWithAggregationInput[]
    by: BoxScalarFieldEnum[] | BoxScalarFieldEnum
    having?: boxScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BoxCountAggregateInputType | true
    _avg?: BoxAvgAggregateInputType
    _sum?: BoxSumAggregateInputType
    _min?: BoxMinAggregateInputType
    _max?: BoxMaxAggregateInputType
  }

  export type BoxGroupByOutputType = {
    id: number
    serial: string
    timestamp: Date
    line: string
    type: string
    pallete_id: number | null
    attachment_id: number | null
    attachment2_id: number | null
    remain: string
    _count: BoxCountAggregateOutputType | null
    _avg: BoxAvgAggregateOutputType | null
    _sum: BoxSumAggregateOutputType | null
    _min: BoxMinAggregateOutputType | null
    _max: BoxMaxAggregateOutputType | null
  }

  type GetBoxGroupByPayload<T extends boxGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BoxGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BoxGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BoxGroupByOutputType[P]>
            : GetScalarType<T[P], BoxGroupByOutputType[P]>
        }
      >
    >


  export type boxSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serial?: boolean
    timestamp?: boolean
    line?: boolean
    type?: boolean
    pallete_id?: boolean
    attachment_id?: boolean
    attachment2_id?: boolean
    remain?: boolean
  }, ExtArgs["result"]["box"]>

  export type boxSelectScalar = {
    id?: boolean
    serial?: boolean
    timestamp?: boolean
    line?: boolean
    type?: boolean
    pallete_id?: boolean
    attachment_id?: boolean
    attachment2_id?: boolean
    remain?: boolean
  }


  export type $boxPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "box"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      serial: string
      timestamp: Date
      line: string
      type: string
      pallete_id: number | null
      attachment_id: number | null
      attachment2_id: number | null
      remain: string
    }, ExtArgs["result"]["box"]>
    composites: {}
  }


  type boxGetPayload<S extends boolean | null | undefined | boxDefaultArgs> = $Result.GetResult<Prisma.$boxPayload, S>

  type boxCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<boxFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BoxCountAggregateInputType | true
    }

  export interface boxDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['box'], meta: { name: 'box' } }
    /**
     * Find zero or one Box that matches the filter.
     * @param {boxFindUniqueArgs} args - Arguments to find a Box
     * @example
     * // Get one Box
     * const box = await prisma.box.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends boxFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, boxFindUniqueArgs<ExtArgs>>
    ): Prisma__boxClient<$Result.GetResult<Prisma.$boxPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Box that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {boxFindUniqueOrThrowArgs} args - Arguments to find a Box
     * @example
     * // Get one Box
     * const box = await prisma.box.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends boxFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, boxFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__boxClient<$Result.GetResult<Prisma.$boxPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Box that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {boxFindFirstArgs} args - Arguments to find a Box
     * @example
     * // Get one Box
     * const box = await prisma.box.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends boxFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, boxFindFirstArgs<ExtArgs>>
    ): Prisma__boxClient<$Result.GetResult<Prisma.$boxPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Box that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {boxFindFirstOrThrowArgs} args - Arguments to find a Box
     * @example
     * // Get one Box
     * const box = await prisma.box.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends boxFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, boxFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__boxClient<$Result.GetResult<Prisma.$boxPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Boxes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {boxFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Boxes
     * const boxes = await prisma.box.findMany()
     * 
     * // Get first 10 Boxes
     * const boxes = await prisma.box.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const boxWithIdOnly = await prisma.box.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends boxFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, boxFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$boxPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Box.
     * @param {boxCreateArgs} args - Arguments to create a Box.
     * @example
     * // Create one Box
     * const Box = await prisma.box.create({
     *   data: {
     *     // ... data to create a Box
     *   }
     * })
     * 
    **/
    create<T extends boxCreateArgs<ExtArgs>>(
      args: SelectSubset<T, boxCreateArgs<ExtArgs>>
    ): Prisma__boxClient<$Result.GetResult<Prisma.$boxPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Boxes.
     *     @param {boxCreateManyArgs} args - Arguments to create many Boxes.
     *     @example
     *     // Create many Boxes
     *     const box = await prisma.box.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends boxCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, boxCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Box.
     * @param {boxDeleteArgs} args - Arguments to delete one Box.
     * @example
     * // Delete one Box
     * const Box = await prisma.box.delete({
     *   where: {
     *     // ... filter to delete one Box
     *   }
     * })
     * 
    **/
    delete<T extends boxDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, boxDeleteArgs<ExtArgs>>
    ): Prisma__boxClient<$Result.GetResult<Prisma.$boxPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Box.
     * @param {boxUpdateArgs} args - Arguments to update one Box.
     * @example
     * // Update one Box
     * const box = await prisma.box.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends boxUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, boxUpdateArgs<ExtArgs>>
    ): Prisma__boxClient<$Result.GetResult<Prisma.$boxPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Boxes.
     * @param {boxDeleteManyArgs} args - Arguments to filter Boxes to delete.
     * @example
     * // Delete a few Boxes
     * const { count } = await prisma.box.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends boxDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, boxDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Boxes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {boxUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Boxes
     * const box = await prisma.box.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends boxUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, boxUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Box.
     * @param {boxUpsertArgs} args - Arguments to update or create a Box.
     * @example
     * // Update or create a Box
     * const box = await prisma.box.upsert({
     *   create: {
     *     // ... data to create a Box
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Box we want to update
     *   }
     * })
    **/
    upsert<T extends boxUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, boxUpsertArgs<ExtArgs>>
    ): Prisma__boxClient<$Result.GetResult<Prisma.$boxPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Boxes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {boxCountArgs} args - Arguments to filter Boxes to count.
     * @example
     * // Count the number of Boxes
     * const count = await prisma.box.count({
     *   where: {
     *     // ... the filter for the Boxes we want to count
     *   }
     * })
    **/
    count<T extends boxCountArgs>(
      args?: Subset<T, boxCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BoxCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Box.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoxAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BoxAggregateArgs>(args: Subset<T, BoxAggregateArgs>): Prisma.PrismaPromise<GetBoxAggregateType<T>>

    /**
     * Group by Box.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {boxGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends boxGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: boxGroupByArgs['orderBy'] }
        : { orderBy?: boxGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, boxGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBoxGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the box model
   */
  readonly fields: boxFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for box.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__boxClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the box model
   */ 
  interface boxFieldRefs {
    readonly id: FieldRef<"box", 'Int'>
    readonly serial: FieldRef<"box", 'String'>
    readonly timestamp: FieldRef<"box", 'DateTime'>
    readonly line: FieldRef<"box", 'String'>
    readonly type: FieldRef<"box", 'String'>
    readonly pallete_id: FieldRef<"box", 'Int'>
    readonly attachment_id: FieldRef<"box", 'Int'>
    readonly attachment2_id: FieldRef<"box", 'Int'>
    readonly remain: FieldRef<"box", 'String'>
  }
    

  // Custom InputTypes

  /**
   * box findUnique
   */
  export type boxFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the box
     */
    select?: boxSelect<ExtArgs> | null
    /**
     * Filter, which box to fetch.
     */
    where: boxWhereUniqueInput
  }


  /**
   * box findUniqueOrThrow
   */
  export type boxFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the box
     */
    select?: boxSelect<ExtArgs> | null
    /**
     * Filter, which box to fetch.
     */
    where: boxWhereUniqueInput
  }


  /**
   * box findFirst
   */
  export type boxFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the box
     */
    select?: boxSelect<ExtArgs> | null
    /**
     * Filter, which box to fetch.
     */
    where?: boxWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of boxes to fetch.
     */
    orderBy?: boxOrderByWithRelationInput | boxOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for boxes.
     */
    cursor?: boxWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` boxes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` boxes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of boxes.
     */
    distinct?: BoxScalarFieldEnum | BoxScalarFieldEnum[]
  }


  /**
   * box findFirstOrThrow
   */
  export type boxFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the box
     */
    select?: boxSelect<ExtArgs> | null
    /**
     * Filter, which box to fetch.
     */
    where?: boxWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of boxes to fetch.
     */
    orderBy?: boxOrderByWithRelationInput | boxOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for boxes.
     */
    cursor?: boxWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` boxes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` boxes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of boxes.
     */
    distinct?: BoxScalarFieldEnum | BoxScalarFieldEnum[]
  }


  /**
   * box findMany
   */
  export type boxFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the box
     */
    select?: boxSelect<ExtArgs> | null
    /**
     * Filter, which boxes to fetch.
     */
    where?: boxWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of boxes to fetch.
     */
    orderBy?: boxOrderByWithRelationInput | boxOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing boxes.
     */
    cursor?: boxWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` boxes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` boxes.
     */
    skip?: number
    distinct?: BoxScalarFieldEnum | BoxScalarFieldEnum[]
  }


  /**
   * box create
   */
  export type boxCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the box
     */
    select?: boxSelect<ExtArgs> | null
    /**
     * The data needed to create a box.
     */
    data: XOR<boxCreateInput, boxUncheckedCreateInput>
  }


  /**
   * box createMany
   */
  export type boxCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many boxes.
     */
    data: boxCreateManyInput | boxCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * box update
   */
  export type boxUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the box
     */
    select?: boxSelect<ExtArgs> | null
    /**
     * The data needed to update a box.
     */
    data: XOR<boxUpdateInput, boxUncheckedUpdateInput>
    /**
     * Choose, which box to update.
     */
    where: boxWhereUniqueInput
  }


  /**
   * box updateMany
   */
  export type boxUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update boxes.
     */
    data: XOR<boxUpdateManyMutationInput, boxUncheckedUpdateManyInput>
    /**
     * Filter which boxes to update
     */
    where?: boxWhereInput
  }


  /**
   * box upsert
   */
  export type boxUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the box
     */
    select?: boxSelect<ExtArgs> | null
    /**
     * The filter to search for the box to update in case it exists.
     */
    where: boxWhereUniqueInput
    /**
     * In case the box found by the `where` argument doesn't exist, create a new box with this data.
     */
    create: XOR<boxCreateInput, boxUncheckedCreateInput>
    /**
     * In case the box was found with the provided `where` argument, update it with this data.
     */
    update: XOR<boxUpdateInput, boxUncheckedUpdateInput>
  }


  /**
   * box delete
   */
  export type boxDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the box
     */
    select?: boxSelect<ExtArgs> | null
    /**
     * Filter which box to delete.
     */
    where: boxWhereUniqueInput
  }


  /**
   * box deleteMany
   */
  export type boxDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which boxes to delete
     */
    where?: boxWhereInput
  }


  /**
   * box without action
   */
  export type boxDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the box
     */
    select?: boxSelect<ExtArgs> | null
  }



  /**
   * Model config
   */

  export type AggregateConfig = {
    _count: ConfigCountAggregateOutputType | null
    _min: ConfigMinAggregateOutputType | null
    _max: ConfigMaxAggregateOutputType | null
  }

  export type ConfigMinAggregateOutputType = {
    root: string | null
    branch: string | null
    value: string | null
    tanggal: Date | null
  }

  export type ConfigMaxAggregateOutputType = {
    root: string | null
    branch: string | null
    value: string | null
    tanggal: Date | null
  }

  export type ConfigCountAggregateOutputType = {
    root: number
    branch: number
    value: number
    tanggal: number
    _all: number
  }


  export type ConfigMinAggregateInputType = {
    root?: true
    branch?: true
    value?: true
    tanggal?: true
  }

  export type ConfigMaxAggregateInputType = {
    root?: true
    branch?: true
    value?: true
    tanggal?: true
  }

  export type ConfigCountAggregateInputType = {
    root?: true
    branch?: true
    value?: true
    tanggal?: true
    _all?: true
  }

  export type ConfigAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which config to aggregate.
     */
    where?: configWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of configs to fetch.
     */
    orderBy?: configOrderByWithRelationInput | configOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: configWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` configs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` configs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned configs
    **/
    _count?: true | ConfigCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConfigMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConfigMaxAggregateInputType
  }

  export type GetConfigAggregateType<T extends ConfigAggregateArgs> = {
        [P in keyof T & keyof AggregateConfig]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConfig[P]>
      : GetScalarType<T[P], AggregateConfig[P]>
  }




  export type configGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: configWhereInput
    orderBy?: configOrderByWithAggregationInput | configOrderByWithAggregationInput[]
    by: ConfigScalarFieldEnum[] | ConfigScalarFieldEnum
    having?: configScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConfigCountAggregateInputType | true
    _min?: ConfigMinAggregateInputType
    _max?: ConfigMaxAggregateInputType
  }

  export type ConfigGroupByOutputType = {
    root: string
    branch: string
    value: string
    tanggal: Date
    _count: ConfigCountAggregateOutputType | null
    _min: ConfigMinAggregateOutputType | null
    _max: ConfigMaxAggregateOutputType | null
  }

  type GetConfigGroupByPayload<T extends configGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConfigGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConfigGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConfigGroupByOutputType[P]>
            : GetScalarType<T[P], ConfigGroupByOutputType[P]>
        }
      >
    >


  export type configSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    root?: boolean
    branch?: boolean
    value?: boolean
    tanggal?: boolean
  }, ExtArgs["result"]["config"]>

  export type configSelectScalar = {
    root?: boolean
    branch?: boolean
    value?: boolean
    tanggal?: boolean
  }


  export type $configPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "config"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      root: string
      branch: string
      value: string
      tanggal: Date
    }, ExtArgs["result"]["config"]>
    composites: {}
  }


  type configGetPayload<S extends boolean | null | undefined | configDefaultArgs> = $Result.GetResult<Prisma.$configPayload, S>

  type configCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<configFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ConfigCountAggregateInputType | true
    }

  export interface configDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['config'], meta: { name: 'config' } }
    /**
     * Find zero or one Config that matches the filter.
     * @param {configFindUniqueArgs} args - Arguments to find a Config
     * @example
     * // Get one Config
     * const config = await prisma.config.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends configFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, configFindUniqueArgs<ExtArgs>>
    ): Prisma__configClient<$Result.GetResult<Prisma.$configPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Config that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {configFindUniqueOrThrowArgs} args - Arguments to find a Config
     * @example
     * // Get one Config
     * const config = await prisma.config.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends configFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, configFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__configClient<$Result.GetResult<Prisma.$configPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Config that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {configFindFirstArgs} args - Arguments to find a Config
     * @example
     * // Get one Config
     * const config = await prisma.config.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends configFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, configFindFirstArgs<ExtArgs>>
    ): Prisma__configClient<$Result.GetResult<Prisma.$configPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Config that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {configFindFirstOrThrowArgs} args - Arguments to find a Config
     * @example
     * // Get one Config
     * const config = await prisma.config.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends configFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, configFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__configClient<$Result.GetResult<Prisma.$configPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Configs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {configFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Configs
     * const configs = await prisma.config.findMany()
     * 
     * // Get first 10 Configs
     * const configs = await prisma.config.findMany({ take: 10 })
     * 
     * // Only select the `root`
     * const configWithRootOnly = await prisma.config.findMany({ select: { root: true } })
     * 
    **/
    findMany<T extends configFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, configFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$configPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Config.
     * @param {configCreateArgs} args - Arguments to create a Config.
     * @example
     * // Create one Config
     * const Config = await prisma.config.create({
     *   data: {
     *     // ... data to create a Config
     *   }
     * })
     * 
    **/
    create<T extends configCreateArgs<ExtArgs>>(
      args: SelectSubset<T, configCreateArgs<ExtArgs>>
    ): Prisma__configClient<$Result.GetResult<Prisma.$configPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Configs.
     *     @param {configCreateManyArgs} args - Arguments to create many Configs.
     *     @example
     *     // Create many Configs
     *     const config = await prisma.config.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends configCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, configCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Config.
     * @param {configDeleteArgs} args - Arguments to delete one Config.
     * @example
     * // Delete one Config
     * const Config = await prisma.config.delete({
     *   where: {
     *     // ... filter to delete one Config
     *   }
     * })
     * 
    **/
    delete<T extends configDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, configDeleteArgs<ExtArgs>>
    ): Prisma__configClient<$Result.GetResult<Prisma.$configPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Config.
     * @param {configUpdateArgs} args - Arguments to update one Config.
     * @example
     * // Update one Config
     * const config = await prisma.config.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends configUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, configUpdateArgs<ExtArgs>>
    ): Prisma__configClient<$Result.GetResult<Prisma.$configPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Configs.
     * @param {configDeleteManyArgs} args - Arguments to filter Configs to delete.
     * @example
     * // Delete a few Configs
     * const { count } = await prisma.config.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends configDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, configDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Configs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {configUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Configs
     * const config = await prisma.config.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends configUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, configUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Config.
     * @param {configUpsertArgs} args - Arguments to update or create a Config.
     * @example
     * // Update or create a Config
     * const config = await prisma.config.upsert({
     *   create: {
     *     // ... data to create a Config
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Config we want to update
     *   }
     * })
    **/
    upsert<T extends configUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, configUpsertArgs<ExtArgs>>
    ): Prisma__configClient<$Result.GetResult<Prisma.$configPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Configs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {configCountArgs} args - Arguments to filter Configs to count.
     * @example
     * // Count the number of Configs
     * const count = await prisma.config.count({
     *   where: {
     *     // ... the filter for the Configs we want to count
     *   }
     * })
    **/
    count<T extends configCountArgs>(
      args?: Subset<T, configCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConfigCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Config.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConfigAggregateArgs>(args: Subset<T, ConfigAggregateArgs>): Prisma.PrismaPromise<GetConfigAggregateType<T>>

    /**
     * Group by Config.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {configGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends configGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: configGroupByArgs['orderBy'] }
        : { orderBy?: configGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, configGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConfigGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the config model
   */
  readonly fields: configFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for config.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__configClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the config model
   */ 
  interface configFieldRefs {
    readonly root: FieldRef<"config", 'String'>
    readonly branch: FieldRef<"config", 'String'>
    readonly value: FieldRef<"config", 'String'>
    readonly tanggal: FieldRef<"config", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * config findUnique
   */
  export type configFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the config
     */
    select?: configSelect<ExtArgs> | null
    /**
     * Filter, which config to fetch.
     */
    where: configWhereUniqueInput
  }


  /**
   * config findUniqueOrThrow
   */
  export type configFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the config
     */
    select?: configSelect<ExtArgs> | null
    /**
     * Filter, which config to fetch.
     */
    where: configWhereUniqueInput
  }


  /**
   * config findFirst
   */
  export type configFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the config
     */
    select?: configSelect<ExtArgs> | null
    /**
     * Filter, which config to fetch.
     */
    where?: configWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of configs to fetch.
     */
    orderBy?: configOrderByWithRelationInput | configOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for configs.
     */
    cursor?: configWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` configs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` configs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of configs.
     */
    distinct?: ConfigScalarFieldEnum | ConfigScalarFieldEnum[]
  }


  /**
   * config findFirstOrThrow
   */
  export type configFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the config
     */
    select?: configSelect<ExtArgs> | null
    /**
     * Filter, which config to fetch.
     */
    where?: configWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of configs to fetch.
     */
    orderBy?: configOrderByWithRelationInput | configOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for configs.
     */
    cursor?: configWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` configs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` configs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of configs.
     */
    distinct?: ConfigScalarFieldEnum | ConfigScalarFieldEnum[]
  }


  /**
   * config findMany
   */
  export type configFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the config
     */
    select?: configSelect<ExtArgs> | null
    /**
     * Filter, which configs to fetch.
     */
    where?: configWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of configs to fetch.
     */
    orderBy?: configOrderByWithRelationInput | configOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing configs.
     */
    cursor?: configWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` configs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` configs.
     */
    skip?: number
    distinct?: ConfigScalarFieldEnum | ConfigScalarFieldEnum[]
  }


  /**
   * config create
   */
  export type configCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the config
     */
    select?: configSelect<ExtArgs> | null
    /**
     * The data needed to create a config.
     */
    data: XOR<configCreateInput, configUncheckedCreateInput>
  }


  /**
   * config createMany
   */
  export type configCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many configs.
     */
    data: configCreateManyInput | configCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * config update
   */
  export type configUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the config
     */
    select?: configSelect<ExtArgs> | null
    /**
     * The data needed to update a config.
     */
    data: XOR<configUpdateInput, configUncheckedUpdateInput>
    /**
     * Choose, which config to update.
     */
    where: configWhereUniqueInput
  }


  /**
   * config updateMany
   */
  export type configUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update configs.
     */
    data: XOR<configUpdateManyMutationInput, configUncheckedUpdateManyInput>
    /**
     * Filter which configs to update
     */
    where?: configWhereInput
  }


  /**
   * config upsert
   */
  export type configUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the config
     */
    select?: configSelect<ExtArgs> | null
    /**
     * The filter to search for the config to update in case it exists.
     */
    where: configWhereUniqueInput
    /**
     * In case the config found by the `where` argument doesn't exist, create a new config with this data.
     */
    create: XOR<configCreateInput, configUncheckedCreateInput>
    /**
     * In case the config was found with the provided `where` argument, update it with this data.
     */
    update: XOR<configUpdateInput, configUncheckedUpdateInput>
  }


  /**
   * config delete
   */
  export type configDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the config
     */
    select?: configSelect<ExtArgs> | null
    /**
     * Filter which config to delete.
     */
    where: configWhereUniqueInput
  }


  /**
   * config deleteMany
   */
  export type configDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which configs to delete
     */
    where?: configWhereInput
  }


  /**
   * config without action
   */
  export type configDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the config
     */
    select?: configSelect<ExtArgs> | null
  }



  /**
   * Model defect_list
   */

  export type AggregateDefect_list = {
    _count: Defect_listCountAggregateOutputType | null
    _avg: Defect_listAvgAggregateOutputType | null
    _sum: Defect_listSumAggregateOutputType | null
    _min: Defect_listMinAggregateOutputType | null
    _max: Defect_listMaxAggregateOutputType | null
  }

  export type Defect_listAvgAggregateOutputType = {
    id: number | null
  }

  export type Defect_listSumAggregateOutputType = {
    id: number | null
  }

  export type Defect_listMinAggregateOutputType = {
    id: number | null
    defect_name: string | null
  }

  export type Defect_listMaxAggregateOutputType = {
    id: number | null
    defect_name: string | null
  }

  export type Defect_listCountAggregateOutputType = {
    id: number
    defect_name: number
    _all: number
  }


  export type Defect_listAvgAggregateInputType = {
    id?: true
  }

  export type Defect_listSumAggregateInputType = {
    id?: true
  }

  export type Defect_listMinAggregateInputType = {
    id?: true
    defect_name?: true
  }

  export type Defect_listMaxAggregateInputType = {
    id?: true
    defect_name?: true
  }

  export type Defect_listCountAggregateInputType = {
    id?: true
    defect_name?: true
    _all?: true
  }

  export type Defect_listAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which defect_list to aggregate.
     */
    where?: defect_listWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of defect_lists to fetch.
     */
    orderBy?: defect_listOrderByWithRelationInput | defect_listOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: defect_listWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` defect_lists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` defect_lists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned defect_lists
    **/
    _count?: true | Defect_listCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Defect_listAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Defect_listSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Defect_listMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Defect_listMaxAggregateInputType
  }

  export type GetDefect_listAggregateType<T extends Defect_listAggregateArgs> = {
        [P in keyof T & keyof AggregateDefect_list]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDefect_list[P]>
      : GetScalarType<T[P], AggregateDefect_list[P]>
  }




  export type defect_listGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: defect_listWhereInput
    orderBy?: defect_listOrderByWithAggregationInput | defect_listOrderByWithAggregationInput[]
    by: Defect_listScalarFieldEnum[] | Defect_listScalarFieldEnum
    having?: defect_listScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Defect_listCountAggregateInputType | true
    _avg?: Defect_listAvgAggregateInputType
    _sum?: Defect_listSumAggregateInputType
    _min?: Defect_listMinAggregateInputType
    _max?: Defect_listMaxAggregateInputType
  }

  export type Defect_listGroupByOutputType = {
    id: number
    defect_name: string
    _count: Defect_listCountAggregateOutputType | null
    _avg: Defect_listAvgAggregateOutputType | null
    _sum: Defect_listSumAggregateOutputType | null
    _min: Defect_listMinAggregateOutputType | null
    _max: Defect_listMaxAggregateOutputType | null
  }

  type GetDefect_listGroupByPayload<T extends defect_listGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Defect_listGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Defect_listGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Defect_listGroupByOutputType[P]>
            : GetScalarType<T[P], Defect_listGroupByOutputType[P]>
        }
      >
    >


  export type defect_listSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    defect_name?: boolean
  }, ExtArgs["result"]["defect_list"]>

  export type defect_listSelectScalar = {
    id?: boolean
    defect_name?: boolean
  }


  export type $defect_listPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "defect_list"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      defect_name: string
    }, ExtArgs["result"]["defect_list"]>
    composites: {}
  }


  type defect_listGetPayload<S extends boolean | null | undefined | defect_listDefaultArgs> = $Result.GetResult<Prisma.$defect_listPayload, S>

  type defect_listCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<defect_listFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Defect_listCountAggregateInputType | true
    }

  export interface defect_listDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['defect_list'], meta: { name: 'defect_list' } }
    /**
     * Find zero or one Defect_list that matches the filter.
     * @param {defect_listFindUniqueArgs} args - Arguments to find a Defect_list
     * @example
     * // Get one Defect_list
     * const defect_list = await prisma.defect_list.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends defect_listFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, defect_listFindUniqueArgs<ExtArgs>>
    ): Prisma__defect_listClient<$Result.GetResult<Prisma.$defect_listPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Defect_list that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {defect_listFindUniqueOrThrowArgs} args - Arguments to find a Defect_list
     * @example
     * // Get one Defect_list
     * const defect_list = await prisma.defect_list.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends defect_listFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, defect_listFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__defect_listClient<$Result.GetResult<Prisma.$defect_listPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Defect_list that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {defect_listFindFirstArgs} args - Arguments to find a Defect_list
     * @example
     * // Get one Defect_list
     * const defect_list = await prisma.defect_list.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends defect_listFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, defect_listFindFirstArgs<ExtArgs>>
    ): Prisma__defect_listClient<$Result.GetResult<Prisma.$defect_listPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Defect_list that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {defect_listFindFirstOrThrowArgs} args - Arguments to find a Defect_list
     * @example
     * // Get one Defect_list
     * const defect_list = await prisma.defect_list.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends defect_listFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, defect_listFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__defect_listClient<$Result.GetResult<Prisma.$defect_listPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Defect_lists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {defect_listFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Defect_lists
     * const defect_lists = await prisma.defect_list.findMany()
     * 
     * // Get first 10 Defect_lists
     * const defect_lists = await prisma.defect_list.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const defect_listWithIdOnly = await prisma.defect_list.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends defect_listFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, defect_listFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$defect_listPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Defect_list.
     * @param {defect_listCreateArgs} args - Arguments to create a Defect_list.
     * @example
     * // Create one Defect_list
     * const Defect_list = await prisma.defect_list.create({
     *   data: {
     *     // ... data to create a Defect_list
     *   }
     * })
     * 
    **/
    create<T extends defect_listCreateArgs<ExtArgs>>(
      args: SelectSubset<T, defect_listCreateArgs<ExtArgs>>
    ): Prisma__defect_listClient<$Result.GetResult<Prisma.$defect_listPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Defect_lists.
     *     @param {defect_listCreateManyArgs} args - Arguments to create many Defect_lists.
     *     @example
     *     // Create many Defect_lists
     *     const defect_list = await prisma.defect_list.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends defect_listCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, defect_listCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Defect_list.
     * @param {defect_listDeleteArgs} args - Arguments to delete one Defect_list.
     * @example
     * // Delete one Defect_list
     * const Defect_list = await prisma.defect_list.delete({
     *   where: {
     *     // ... filter to delete one Defect_list
     *   }
     * })
     * 
    **/
    delete<T extends defect_listDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, defect_listDeleteArgs<ExtArgs>>
    ): Prisma__defect_listClient<$Result.GetResult<Prisma.$defect_listPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Defect_list.
     * @param {defect_listUpdateArgs} args - Arguments to update one Defect_list.
     * @example
     * // Update one Defect_list
     * const defect_list = await prisma.defect_list.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends defect_listUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, defect_listUpdateArgs<ExtArgs>>
    ): Prisma__defect_listClient<$Result.GetResult<Prisma.$defect_listPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Defect_lists.
     * @param {defect_listDeleteManyArgs} args - Arguments to filter Defect_lists to delete.
     * @example
     * // Delete a few Defect_lists
     * const { count } = await prisma.defect_list.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends defect_listDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, defect_listDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Defect_lists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {defect_listUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Defect_lists
     * const defect_list = await prisma.defect_list.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends defect_listUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, defect_listUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Defect_list.
     * @param {defect_listUpsertArgs} args - Arguments to update or create a Defect_list.
     * @example
     * // Update or create a Defect_list
     * const defect_list = await prisma.defect_list.upsert({
     *   create: {
     *     // ... data to create a Defect_list
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Defect_list we want to update
     *   }
     * })
    **/
    upsert<T extends defect_listUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, defect_listUpsertArgs<ExtArgs>>
    ): Prisma__defect_listClient<$Result.GetResult<Prisma.$defect_listPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Defect_lists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {defect_listCountArgs} args - Arguments to filter Defect_lists to count.
     * @example
     * // Count the number of Defect_lists
     * const count = await prisma.defect_list.count({
     *   where: {
     *     // ... the filter for the Defect_lists we want to count
     *   }
     * })
    **/
    count<T extends defect_listCountArgs>(
      args?: Subset<T, defect_listCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Defect_listCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Defect_list.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Defect_listAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Defect_listAggregateArgs>(args: Subset<T, Defect_listAggregateArgs>): Prisma.PrismaPromise<GetDefect_listAggregateType<T>>

    /**
     * Group by Defect_list.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {defect_listGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends defect_listGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: defect_listGroupByArgs['orderBy'] }
        : { orderBy?: defect_listGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, defect_listGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDefect_listGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the defect_list model
   */
  readonly fields: defect_listFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for defect_list.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__defect_listClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the defect_list model
   */ 
  interface defect_listFieldRefs {
    readonly id: FieldRef<"defect_list", 'Int'>
    readonly defect_name: FieldRef<"defect_list", 'String'>
  }
    

  // Custom InputTypes

  /**
   * defect_list findUnique
   */
  export type defect_listFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the defect_list
     */
    select?: defect_listSelect<ExtArgs> | null
    /**
     * Filter, which defect_list to fetch.
     */
    where: defect_listWhereUniqueInput
  }


  /**
   * defect_list findUniqueOrThrow
   */
  export type defect_listFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the defect_list
     */
    select?: defect_listSelect<ExtArgs> | null
    /**
     * Filter, which defect_list to fetch.
     */
    where: defect_listWhereUniqueInput
  }


  /**
   * defect_list findFirst
   */
  export type defect_listFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the defect_list
     */
    select?: defect_listSelect<ExtArgs> | null
    /**
     * Filter, which defect_list to fetch.
     */
    where?: defect_listWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of defect_lists to fetch.
     */
    orderBy?: defect_listOrderByWithRelationInput | defect_listOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for defect_lists.
     */
    cursor?: defect_listWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` defect_lists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` defect_lists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of defect_lists.
     */
    distinct?: Defect_listScalarFieldEnum | Defect_listScalarFieldEnum[]
  }


  /**
   * defect_list findFirstOrThrow
   */
  export type defect_listFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the defect_list
     */
    select?: defect_listSelect<ExtArgs> | null
    /**
     * Filter, which defect_list to fetch.
     */
    where?: defect_listWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of defect_lists to fetch.
     */
    orderBy?: defect_listOrderByWithRelationInput | defect_listOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for defect_lists.
     */
    cursor?: defect_listWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` defect_lists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` defect_lists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of defect_lists.
     */
    distinct?: Defect_listScalarFieldEnum | Defect_listScalarFieldEnum[]
  }


  /**
   * defect_list findMany
   */
  export type defect_listFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the defect_list
     */
    select?: defect_listSelect<ExtArgs> | null
    /**
     * Filter, which defect_lists to fetch.
     */
    where?: defect_listWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of defect_lists to fetch.
     */
    orderBy?: defect_listOrderByWithRelationInput | defect_listOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing defect_lists.
     */
    cursor?: defect_listWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` defect_lists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` defect_lists.
     */
    skip?: number
    distinct?: Defect_listScalarFieldEnum | Defect_listScalarFieldEnum[]
  }


  /**
   * defect_list create
   */
  export type defect_listCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the defect_list
     */
    select?: defect_listSelect<ExtArgs> | null
    /**
     * The data needed to create a defect_list.
     */
    data: XOR<defect_listCreateInput, defect_listUncheckedCreateInput>
  }


  /**
   * defect_list createMany
   */
  export type defect_listCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many defect_lists.
     */
    data: defect_listCreateManyInput | defect_listCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * defect_list update
   */
  export type defect_listUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the defect_list
     */
    select?: defect_listSelect<ExtArgs> | null
    /**
     * The data needed to update a defect_list.
     */
    data: XOR<defect_listUpdateInput, defect_listUncheckedUpdateInput>
    /**
     * Choose, which defect_list to update.
     */
    where: defect_listWhereUniqueInput
  }


  /**
   * defect_list updateMany
   */
  export type defect_listUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update defect_lists.
     */
    data: XOR<defect_listUpdateManyMutationInput, defect_listUncheckedUpdateManyInput>
    /**
     * Filter which defect_lists to update
     */
    where?: defect_listWhereInput
  }


  /**
   * defect_list upsert
   */
  export type defect_listUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the defect_list
     */
    select?: defect_listSelect<ExtArgs> | null
    /**
     * The filter to search for the defect_list to update in case it exists.
     */
    where: defect_listWhereUniqueInput
    /**
     * In case the defect_list found by the `where` argument doesn't exist, create a new defect_list with this data.
     */
    create: XOR<defect_listCreateInput, defect_listUncheckedCreateInput>
    /**
     * In case the defect_list was found with the provided `where` argument, update it with this data.
     */
    update: XOR<defect_listUpdateInput, defect_listUncheckedUpdateInput>
  }


  /**
   * defect_list delete
   */
  export type defect_listDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the defect_list
     */
    select?: defect_listSelect<ExtArgs> | null
    /**
     * Filter which defect_list to delete.
     */
    where: defect_listWhereUniqueInput
  }


  /**
   * defect_list deleteMany
   */
  export type defect_listDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which defect_lists to delete
     */
    where?: defect_listWhereInput
  }


  /**
   * defect_list without action
   */
  export type defect_listDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the defect_list
     */
    select?: defect_listSelect<ExtArgs> | null
  }



  /**
   * Model fct_notpass
   */

  export type AggregateFct_notpass = {
    _count: Fct_notpassCountAggregateOutputType | null
    _avg: Fct_notpassAvgAggregateOutputType | null
    _sum: Fct_notpassSumAggregateOutputType | null
    _min: Fct_notpassMinAggregateOutputType | null
    _max: Fct_notpassMaxAggregateOutputType | null
  }

  export type Fct_notpassAvgAggregateOutputType = {
    id: number | null
  }

  export type Fct_notpassSumAggregateOutputType = {
    id: number | null
  }

  export type Fct_notpassMinAggregateOutputType = {
    id: number | null
    serial: string | null
    type: string | null
    line: string | null
    timestamp: Date | null
  }

  export type Fct_notpassMaxAggregateOutputType = {
    id: number | null
    serial: string | null
    type: string | null
    line: string | null
    timestamp: Date | null
  }

  export type Fct_notpassCountAggregateOutputType = {
    id: number
    serial: number
    type: number
    line: number
    timestamp: number
    _all: number
  }


  export type Fct_notpassAvgAggregateInputType = {
    id?: true
  }

  export type Fct_notpassSumAggregateInputType = {
    id?: true
  }

  export type Fct_notpassMinAggregateInputType = {
    id?: true
    serial?: true
    type?: true
    line?: true
    timestamp?: true
  }

  export type Fct_notpassMaxAggregateInputType = {
    id?: true
    serial?: true
    type?: true
    line?: true
    timestamp?: true
  }

  export type Fct_notpassCountAggregateInputType = {
    id?: true
    serial?: true
    type?: true
    line?: true
    timestamp?: true
    _all?: true
  }

  export type Fct_notpassAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which fct_notpass to aggregate.
     */
    where?: fct_notpassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fct_notpasses to fetch.
     */
    orderBy?: fct_notpassOrderByWithRelationInput | fct_notpassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: fct_notpassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fct_notpasses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fct_notpasses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned fct_notpasses
    **/
    _count?: true | Fct_notpassCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Fct_notpassAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Fct_notpassSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Fct_notpassMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Fct_notpassMaxAggregateInputType
  }

  export type GetFct_notpassAggregateType<T extends Fct_notpassAggregateArgs> = {
        [P in keyof T & keyof AggregateFct_notpass]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFct_notpass[P]>
      : GetScalarType<T[P], AggregateFct_notpass[P]>
  }




  export type fct_notpassGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: fct_notpassWhereInput
    orderBy?: fct_notpassOrderByWithAggregationInput | fct_notpassOrderByWithAggregationInput[]
    by: Fct_notpassScalarFieldEnum[] | Fct_notpassScalarFieldEnum
    having?: fct_notpassScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Fct_notpassCountAggregateInputType | true
    _avg?: Fct_notpassAvgAggregateInputType
    _sum?: Fct_notpassSumAggregateInputType
    _min?: Fct_notpassMinAggregateInputType
    _max?: Fct_notpassMaxAggregateInputType
  }

  export type Fct_notpassGroupByOutputType = {
    id: number
    serial: string
    type: string
    line: string
    timestamp: Date
    _count: Fct_notpassCountAggregateOutputType | null
    _avg: Fct_notpassAvgAggregateOutputType | null
    _sum: Fct_notpassSumAggregateOutputType | null
    _min: Fct_notpassMinAggregateOutputType | null
    _max: Fct_notpassMaxAggregateOutputType | null
  }

  type GetFct_notpassGroupByPayload<T extends fct_notpassGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Fct_notpassGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Fct_notpassGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Fct_notpassGroupByOutputType[P]>
            : GetScalarType<T[P], Fct_notpassGroupByOutputType[P]>
        }
      >
    >


  export type fct_notpassSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serial?: boolean
    type?: boolean
    line?: boolean
    timestamp?: boolean
  }, ExtArgs["result"]["fct_notpass"]>

  export type fct_notpassSelectScalar = {
    id?: boolean
    serial?: boolean
    type?: boolean
    line?: boolean
    timestamp?: boolean
  }


  export type $fct_notpassPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "fct_notpass"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      serial: string
      type: string
      line: string
      timestamp: Date
    }, ExtArgs["result"]["fct_notpass"]>
    composites: {}
  }


  type fct_notpassGetPayload<S extends boolean | null | undefined | fct_notpassDefaultArgs> = $Result.GetResult<Prisma.$fct_notpassPayload, S>

  type fct_notpassCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<fct_notpassFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Fct_notpassCountAggregateInputType | true
    }

  export interface fct_notpassDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['fct_notpass'], meta: { name: 'fct_notpass' } }
    /**
     * Find zero or one Fct_notpass that matches the filter.
     * @param {fct_notpassFindUniqueArgs} args - Arguments to find a Fct_notpass
     * @example
     * // Get one Fct_notpass
     * const fct_notpass = await prisma.fct_notpass.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends fct_notpassFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, fct_notpassFindUniqueArgs<ExtArgs>>
    ): Prisma__fct_notpassClient<$Result.GetResult<Prisma.$fct_notpassPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Fct_notpass that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {fct_notpassFindUniqueOrThrowArgs} args - Arguments to find a Fct_notpass
     * @example
     * // Get one Fct_notpass
     * const fct_notpass = await prisma.fct_notpass.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends fct_notpassFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, fct_notpassFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__fct_notpassClient<$Result.GetResult<Prisma.$fct_notpassPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Fct_notpass that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fct_notpassFindFirstArgs} args - Arguments to find a Fct_notpass
     * @example
     * // Get one Fct_notpass
     * const fct_notpass = await prisma.fct_notpass.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends fct_notpassFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, fct_notpassFindFirstArgs<ExtArgs>>
    ): Prisma__fct_notpassClient<$Result.GetResult<Prisma.$fct_notpassPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Fct_notpass that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fct_notpassFindFirstOrThrowArgs} args - Arguments to find a Fct_notpass
     * @example
     * // Get one Fct_notpass
     * const fct_notpass = await prisma.fct_notpass.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends fct_notpassFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, fct_notpassFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__fct_notpassClient<$Result.GetResult<Prisma.$fct_notpassPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Fct_notpasses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fct_notpassFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Fct_notpasses
     * const fct_notpasses = await prisma.fct_notpass.findMany()
     * 
     * // Get first 10 Fct_notpasses
     * const fct_notpasses = await prisma.fct_notpass.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fct_notpassWithIdOnly = await prisma.fct_notpass.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends fct_notpassFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, fct_notpassFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$fct_notpassPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Fct_notpass.
     * @param {fct_notpassCreateArgs} args - Arguments to create a Fct_notpass.
     * @example
     * // Create one Fct_notpass
     * const Fct_notpass = await prisma.fct_notpass.create({
     *   data: {
     *     // ... data to create a Fct_notpass
     *   }
     * })
     * 
    **/
    create<T extends fct_notpassCreateArgs<ExtArgs>>(
      args: SelectSubset<T, fct_notpassCreateArgs<ExtArgs>>
    ): Prisma__fct_notpassClient<$Result.GetResult<Prisma.$fct_notpassPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Fct_notpasses.
     *     @param {fct_notpassCreateManyArgs} args - Arguments to create many Fct_notpasses.
     *     @example
     *     // Create many Fct_notpasses
     *     const fct_notpass = await prisma.fct_notpass.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends fct_notpassCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, fct_notpassCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Fct_notpass.
     * @param {fct_notpassDeleteArgs} args - Arguments to delete one Fct_notpass.
     * @example
     * // Delete one Fct_notpass
     * const Fct_notpass = await prisma.fct_notpass.delete({
     *   where: {
     *     // ... filter to delete one Fct_notpass
     *   }
     * })
     * 
    **/
    delete<T extends fct_notpassDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, fct_notpassDeleteArgs<ExtArgs>>
    ): Prisma__fct_notpassClient<$Result.GetResult<Prisma.$fct_notpassPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Fct_notpass.
     * @param {fct_notpassUpdateArgs} args - Arguments to update one Fct_notpass.
     * @example
     * // Update one Fct_notpass
     * const fct_notpass = await prisma.fct_notpass.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends fct_notpassUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, fct_notpassUpdateArgs<ExtArgs>>
    ): Prisma__fct_notpassClient<$Result.GetResult<Prisma.$fct_notpassPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Fct_notpasses.
     * @param {fct_notpassDeleteManyArgs} args - Arguments to filter Fct_notpasses to delete.
     * @example
     * // Delete a few Fct_notpasses
     * const { count } = await prisma.fct_notpass.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends fct_notpassDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, fct_notpassDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Fct_notpasses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fct_notpassUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Fct_notpasses
     * const fct_notpass = await prisma.fct_notpass.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends fct_notpassUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, fct_notpassUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Fct_notpass.
     * @param {fct_notpassUpsertArgs} args - Arguments to update or create a Fct_notpass.
     * @example
     * // Update or create a Fct_notpass
     * const fct_notpass = await prisma.fct_notpass.upsert({
     *   create: {
     *     // ... data to create a Fct_notpass
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Fct_notpass we want to update
     *   }
     * })
    **/
    upsert<T extends fct_notpassUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, fct_notpassUpsertArgs<ExtArgs>>
    ): Prisma__fct_notpassClient<$Result.GetResult<Prisma.$fct_notpassPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Fct_notpasses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fct_notpassCountArgs} args - Arguments to filter Fct_notpasses to count.
     * @example
     * // Count the number of Fct_notpasses
     * const count = await prisma.fct_notpass.count({
     *   where: {
     *     // ... the filter for the Fct_notpasses we want to count
     *   }
     * })
    **/
    count<T extends fct_notpassCountArgs>(
      args?: Subset<T, fct_notpassCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Fct_notpassCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Fct_notpass.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Fct_notpassAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Fct_notpassAggregateArgs>(args: Subset<T, Fct_notpassAggregateArgs>): Prisma.PrismaPromise<GetFct_notpassAggregateType<T>>

    /**
     * Group by Fct_notpass.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fct_notpassGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends fct_notpassGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: fct_notpassGroupByArgs['orderBy'] }
        : { orderBy?: fct_notpassGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, fct_notpassGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFct_notpassGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the fct_notpass model
   */
  readonly fields: fct_notpassFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for fct_notpass.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__fct_notpassClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the fct_notpass model
   */ 
  interface fct_notpassFieldRefs {
    readonly id: FieldRef<"fct_notpass", 'Int'>
    readonly serial: FieldRef<"fct_notpass", 'String'>
    readonly type: FieldRef<"fct_notpass", 'String'>
    readonly line: FieldRef<"fct_notpass", 'String'>
    readonly timestamp: FieldRef<"fct_notpass", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * fct_notpass findUnique
   */
  export type fct_notpassFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fct_notpass
     */
    select?: fct_notpassSelect<ExtArgs> | null
    /**
     * Filter, which fct_notpass to fetch.
     */
    where: fct_notpassWhereUniqueInput
  }


  /**
   * fct_notpass findUniqueOrThrow
   */
  export type fct_notpassFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fct_notpass
     */
    select?: fct_notpassSelect<ExtArgs> | null
    /**
     * Filter, which fct_notpass to fetch.
     */
    where: fct_notpassWhereUniqueInput
  }


  /**
   * fct_notpass findFirst
   */
  export type fct_notpassFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fct_notpass
     */
    select?: fct_notpassSelect<ExtArgs> | null
    /**
     * Filter, which fct_notpass to fetch.
     */
    where?: fct_notpassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fct_notpasses to fetch.
     */
    orderBy?: fct_notpassOrderByWithRelationInput | fct_notpassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for fct_notpasses.
     */
    cursor?: fct_notpassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fct_notpasses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fct_notpasses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of fct_notpasses.
     */
    distinct?: Fct_notpassScalarFieldEnum | Fct_notpassScalarFieldEnum[]
  }


  /**
   * fct_notpass findFirstOrThrow
   */
  export type fct_notpassFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fct_notpass
     */
    select?: fct_notpassSelect<ExtArgs> | null
    /**
     * Filter, which fct_notpass to fetch.
     */
    where?: fct_notpassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fct_notpasses to fetch.
     */
    orderBy?: fct_notpassOrderByWithRelationInput | fct_notpassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for fct_notpasses.
     */
    cursor?: fct_notpassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fct_notpasses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fct_notpasses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of fct_notpasses.
     */
    distinct?: Fct_notpassScalarFieldEnum | Fct_notpassScalarFieldEnum[]
  }


  /**
   * fct_notpass findMany
   */
  export type fct_notpassFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fct_notpass
     */
    select?: fct_notpassSelect<ExtArgs> | null
    /**
     * Filter, which fct_notpasses to fetch.
     */
    where?: fct_notpassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fct_notpasses to fetch.
     */
    orderBy?: fct_notpassOrderByWithRelationInput | fct_notpassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing fct_notpasses.
     */
    cursor?: fct_notpassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fct_notpasses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fct_notpasses.
     */
    skip?: number
    distinct?: Fct_notpassScalarFieldEnum | Fct_notpassScalarFieldEnum[]
  }


  /**
   * fct_notpass create
   */
  export type fct_notpassCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fct_notpass
     */
    select?: fct_notpassSelect<ExtArgs> | null
    /**
     * The data needed to create a fct_notpass.
     */
    data: XOR<fct_notpassCreateInput, fct_notpassUncheckedCreateInput>
  }


  /**
   * fct_notpass createMany
   */
  export type fct_notpassCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many fct_notpasses.
     */
    data: fct_notpassCreateManyInput | fct_notpassCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * fct_notpass update
   */
  export type fct_notpassUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fct_notpass
     */
    select?: fct_notpassSelect<ExtArgs> | null
    /**
     * The data needed to update a fct_notpass.
     */
    data: XOR<fct_notpassUpdateInput, fct_notpassUncheckedUpdateInput>
    /**
     * Choose, which fct_notpass to update.
     */
    where: fct_notpassWhereUniqueInput
  }


  /**
   * fct_notpass updateMany
   */
  export type fct_notpassUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update fct_notpasses.
     */
    data: XOR<fct_notpassUpdateManyMutationInput, fct_notpassUncheckedUpdateManyInput>
    /**
     * Filter which fct_notpasses to update
     */
    where?: fct_notpassWhereInput
  }


  /**
   * fct_notpass upsert
   */
  export type fct_notpassUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fct_notpass
     */
    select?: fct_notpassSelect<ExtArgs> | null
    /**
     * The filter to search for the fct_notpass to update in case it exists.
     */
    where: fct_notpassWhereUniqueInput
    /**
     * In case the fct_notpass found by the `where` argument doesn't exist, create a new fct_notpass with this data.
     */
    create: XOR<fct_notpassCreateInput, fct_notpassUncheckedCreateInput>
    /**
     * In case the fct_notpass was found with the provided `where` argument, update it with this data.
     */
    update: XOR<fct_notpassUpdateInput, fct_notpassUncheckedUpdateInput>
  }


  /**
   * fct_notpass delete
   */
  export type fct_notpassDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fct_notpass
     */
    select?: fct_notpassSelect<ExtArgs> | null
    /**
     * Filter which fct_notpass to delete.
     */
    where: fct_notpassWhereUniqueInput
  }


  /**
   * fct_notpass deleteMany
   */
  export type fct_notpassDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which fct_notpasses to delete
     */
    where?: fct_notpassWhereInput
  }


  /**
   * fct_notpass without action
   */
  export type fct_notpassDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fct_notpass
     */
    select?: fct_notpassSelect<ExtArgs> | null
  }



  /**
   * Model fct_pass
   */

  export type AggregateFct_pass = {
    _count: Fct_passCountAggregateOutputType | null
    _avg: Fct_passAvgAggregateOutputType | null
    _sum: Fct_passSumAggregateOutputType | null
    _min: Fct_passMinAggregateOutputType | null
    _max: Fct_passMaxAggregateOutputType | null
  }

  export type Fct_passAvgAggregateOutputType = {
    id: number | null
  }

  export type Fct_passSumAggregateOutputType = {
    id: number | null
  }

  export type Fct_passMinAggregateOutputType = {
    id: number | null
    serial: string | null
    type: string | null
    line: string | null
    timestamp: Date | null
  }

  export type Fct_passMaxAggregateOutputType = {
    id: number | null
    serial: string | null
    type: string | null
    line: string | null
    timestamp: Date | null
  }

  export type Fct_passCountAggregateOutputType = {
    id: number
    serial: number
    type: number
    line: number
    timestamp: number
    _all: number
  }


  export type Fct_passAvgAggregateInputType = {
    id?: true
  }

  export type Fct_passSumAggregateInputType = {
    id?: true
  }

  export type Fct_passMinAggregateInputType = {
    id?: true
    serial?: true
    type?: true
    line?: true
    timestamp?: true
  }

  export type Fct_passMaxAggregateInputType = {
    id?: true
    serial?: true
    type?: true
    line?: true
    timestamp?: true
  }

  export type Fct_passCountAggregateInputType = {
    id?: true
    serial?: true
    type?: true
    line?: true
    timestamp?: true
    _all?: true
  }

  export type Fct_passAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which fct_pass to aggregate.
     */
    where?: fct_passWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fct_passes to fetch.
     */
    orderBy?: fct_passOrderByWithRelationInput | fct_passOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: fct_passWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fct_passes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fct_passes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned fct_passes
    **/
    _count?: true | Fct_passCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Fct_passAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Fct_passSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Fct_passMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Fct_passMaxAggregateInputType
  }

  export type GetFct_passAggregateType<T extends Fct_passAggregateArgs> = {
        [P in keyof T & keyof AggregateFct_pass]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFct_pass[P]>
      : GetScalarType<T[P], AggregateFct_pass[P]>
  }




  export type fct_passGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: fct_passWhereInput
    orderBy?: fct_passOrderByWithAggregationInput | fct_passOrderByWithAggregationInput[]
    by: Fct_passScalarFieldEnum[] | Fct_passScalarFieldEnum
    having?: fct_passScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Fct_passCountAggregateInputType | true
    _avg?: Fct_passAvgAggregateInputType
    _sum?: Fct_passSumAggregateInputType
    _min?: Fct_passMinAggregateInputType
    _max?: Fct_passMaxAggregateInputType
  }

  export type Fct_passGroupByOutputType = {
    id: number
    serial: string
    type: string
    line: string
    timestamp: Date
    _count: Fct_passCountAggregateOutputType | null
    _avg: Fct_passAvgAggregateOutputType | null
    _sum: Fct_passSumAggregateOutputType | null
    _min: Fct_passMinAggregateOutputType | null
    _max: Fct_passMaxAggregateOutputType | null
  }

  type GetFct_passGroupByPayload<T extends fct_passGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Fct_passGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Fct_passGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Fct_passGroupByOutputType[P]>
            : GetScalarType<T[P], Fct_passGroupByOutputType[P]>
        }
      >
    >


  export type fct_passSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serial?: boolean
    type?: boolean
    line?: boolean
    timestamp?: boolean
  }, ExtArgs["result"]["fct_pass"]>

  export type fct_passSelectScalar = {
    id?: boolean
    serial?: boolean
    type?: boolean
    line?: boolean
    timestamp?: boolean
  }


  export type $fct_passPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "fct_pass"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      serial: string
      type: string
      line: string
      timestamp: Date
    }, ExtArgs["result"]["fct_pass"]>
    composites: {}
  }


  type fct_passGetPayload<S extends boolean | null | undefined | fct_passDefaultArgs> = $Result.GetResult<Prisma.$fct_passPayload, S>

  type fct_passCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<fct_passFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Fct_passCountAggregateInputType | true
    }

  export interface fct_passDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['fct_pass'], meta: { name: 'fct_pass' } }
    /**
     * Find zero or one Fct_pass that matches the filter.
     * @param {fct_passFindUniqueArgs} args - Arguments to find a Fct_pass
     * @example
     * // Get one Fct_pass
     * const fct_pass = await prisma.fct_pass.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends fct_passFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, fct_passFindUniqueArgs<ExtArgs>>
    ): Prisma__fct_passClient<$Result.GetResult<Prisma.$fct_passPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Fct_pass that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {fct_passFindUniqueOrThrowArgs} args - Arguments to find a Fct_pass
     * @example
     * // Get one Fct_pass
     * const fct_pass = await prisma.fct_pass.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends fct_passFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, fct_passFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__fct_passClient<$Result.GetResult<Prisma.$fct_passPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Fct_pass that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fct_passFindFirstArgs} args - Arguments to find a Fct_pass
     * @example
     * // Get one Fct_pass
     * const fct_pass = await prisma.fct_pass.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends fct_passFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, fct_passFindFirstArgs<ExtArgs>>
    ): Prisma__fct_passClient<$Result.GetResult<Prisma.$fct_passPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Fct_pass that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fct_passFindFirstOrThrowArgs} args - Arguments to find a Fct_pass
     * @example
     * // Get one Fct_pass
     * const fct_pass = await prisma.fct_pass.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends fct_passFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, fct_passFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__fct_passClient<$Result.GetResult<Prisma.$fct_passPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Fct_passes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fct_passFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Fct_passes
     * const fct_passes = await prisma.fct_pass.findMany()
     * 
     * // Get first 10 Fct_passes
     * const fct_passes = await prisma.fct_pass.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fct_passWithIdOnly = await prisma.fct_pass.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends fct_passFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, fct_passFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$fct_passPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Fct_pass.
     * @param {fct_passCreateArgs} args - Arguments to create a Fct_pass.
     * @example
     * // Create one Fct_pass
     * const Fct_pass = await prisma.fct_pass.create({
     *   data: {
     *     // ... data to create a Fct_pass
     *   }
     * })
     * 
    **/
    create<T extends fct_passCreateArgs<ExtArgs>>(
      args: SelectSubset<T, fct_passCreateArgs<ExtArgs>>
    ): Prisma__fct_passClient<$Result.GetResult<Prisma.$fct_passPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Fct_passes.
     *     @param {fct_passCreateManyArgs} args - Arguments to create many Fct_passes.
     *     @example
     *     // Create many Fct_passes
     *     const fct_pass = await prisma.fct_pass.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends fct_passCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, fct_passCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Fct_pass.
     * @param {fct_passDeleteArgs} args - Arguments to delete one Fct_pass.
     * @example
     * // Delete one Fct_pass
     * const Fct_pass = await prisma.fct_pass.delete({
     *   where: {
     *     // ... filter to delete one Fct_pass
     *   }
     * })
     * 
    **/
    delete<T extends fct_passDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, fct_passDeleteArgs<ExtArgs>>
    ): Prisma__fct_passClient<$Result.GetResult<Prisma.$fct_passPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Fct_pass.
     * @param {fct_passUpdateArgs} args - Arguments to update one Fct_pass.
     * @example
     * // Update one Fct_pass
     * const fct_pass = await prisma.fct_pass.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends fct_passUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, fct_passUpdateArgs<ExtArgs>>
    ): Prisma__fct_passClient<$Result.GetResult<Prisma.$fct_passPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Fct_passes.
     * @param {fct_passDeleteManyArgs} args - Arguments to filter Fct_passes to delete.
     * @example
     * // Delete a few Fct_passes
     * const { count } = await prisma.fct_pass.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends fct_passDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, fct_passDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Fct_passes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fct_passUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Fct_passes
     * const fct_pass = await prisma.fct_pass.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends fct_passUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, fct_passUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Fct_pass.
     * @param {fct_passUpsertArgs} args - Arguments to update or create a Fct_pass.
     * @example
     * // Update or create a Fct_pass
     * const fct_pass = await prisma.fct_pass.upsert({
     *   create: {
     *     // ... data to create a Fct_pass
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Fct_pass we want to update
     *   }
     * })
    **/
    upsert<T extends fct_passUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, fct_passUpsertArgs<ExtArgs>>
    ): Prisma__fct_passClient<$Result.GetResult<Prisma.$fct_passPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Fct_passes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fct_passCountArgs} args - Arguments to filter Fct_passes to count.
     * @example
     * // Count the number of Fct_passes
     * const count = await prisma.fct_pass.count({
     *   where: {
     *     // ... the filter for the Fct_passes we want to count
     *   }
     * })
    **/
    count<T extends fct_passCountArgs>(
      args?: Subset<T, fct_passCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Fct_passCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Fct_pass.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Fct_passAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Fct_passAggregateArgs>(args: Subset<T, Fct_passAggregateArgs>): Prisma.PrismaPromise<GetFct_passAggregateType<T>>

    /**
     * Group by Fct_pass.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fct_passGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends fct_passGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: fct_passGroupByArgs['orderBy'] }
        : { orderBy?: fct_passGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, fct_passGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFct_passGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the fct_pass model
   */
  readonly fields: fct_passFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for fct_pass.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__fct_passClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the fct_pass model
   */ 
  interface fct_passFieldRefs {
    readonly id: FieldRef<"fct_pass", 'Int'>
    readonly serial: FieldRef<"fct_pass", 'String'>
    readonly type: FieldRef<"fct_pass", 'String'>
    readonly line: FieldRef<"fct_pass", 'String'>
    readonly timestamp: FieldRef<"fct_pass", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * fct_pass findUnique
   */
  export type fct_passFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fct_pass
     */
    select?: fct_passSelect<ExtArgs> | null
    /**
     * Filter, which fct_pass to fetch.
     */
    where: fct_passWhereUniqueInput
  }


  /**
   * fct_pass findUniqueOrThrow
   */
  export type fct_passFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fct_pass
     */
    select?: fct_passSelect<ExtArgs> | null
    /**
     * Filter, which fct_pass to fetch.
     */
    where: fct_passWhereUniqueInput
  }


  /**
   * fct_pass findFirst
   */
  export type fct_passFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fct_pass
     */
    select?: fct_passSelect<ExtArgs> | null
    /**
     * Filter, which fct_pass to fetch.
     */
    where?: fct_passWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fct_passes to fetch.
     */
    orderBy?: fct_passOrderByWithRelationInput | fct_passOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for fct_passes.
     */
    cursor?: fct_passWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fct_passes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fct_passes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of fct_passes.
     */
    distinct?: Fct_passScalarFieldEnum | Fct_passScalarFieldEnum[]
  }


  /**
   * fct_pass findFirstOrThrow
   */
  export type fct_passFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fct_pass
     */
    select?: fct_passSelect<ExtArgs> | null
    /**
     * Filter, which fct_pass to fetch.
     */
    where?: fct_passWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fct_passes to fetch.
     */
    orderBy?: fct_passOrderByWithRelationInput | fct_passOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for fct_passes.
     */
    cursor?: fct_passWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fct_passes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fct_passes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of fct_passes.
     */
    distinct?: Fct_passScalarFieldEnum | Fct_passScalarFieldEnum[]
  }


  /**
   * fct_pass findMany
   */
  export type fct_passFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fct_pass
     */
    select?: fct_passSelect<ExtArgs> | null
    /**
     * Filter, which fct_passes to fetch.
     */
    where?: fct_passWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fct_passes to fetch.
     */
    orderBy?: fct_passOrderByWithRelationInput | fct_passOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing fct_passes.
     */
    cursor?: fct_passWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fct_passes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fct_passes.
     */
    skip?: number
    distinct?: Fct_passScalarFieldEnum | Fct_passScalarFieldEnum[]
  }


  /**
   * fct_pass create
   */
  export type fct_passCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fct_pass
     */
    select?: fct_passSelect<ExtArgs> | null
    /**
     * The data needed to create a fct_pass.
     */
    data: XOR<fct_passCreateInput, fct_passUncheckedCreateInput>
  }


  /**
   * fct_pass createMany
   */
  export type fct_passCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many fct_passes.
     */
    data: fct_passCreateManyInput | fct_passCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * fct_pass update
   */
  export type fct_passUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fct_pass
     */
    select?: fct_passSelect<ExtArgs> | null
    /**
     * The data needed to update a fct_pass.
     */
    data: XOR<fct_passUpdateInput, fct_passUncheckedUpdateInput>
    /**
     * Choose, which fct_pass to update.
     */
    where: fct_passWhereUniqueInput
  }


  /**
   * fct_pass updateMany
   */
  export type fct_passUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update fct_passes.
     */
    data: XOR<fct_passUpdateManyMutationInput, fct_passUncheckedUpdateManyInput>
    /**
     * Filter which fct_passes to update
     */
    where?: fct_passWhereInput
  }


  /**
   * fct_pass upsert
   */
  export type fct_passUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fct_pass
     */
    select?: fct_passSelect<ExtArgs> | null
    /**
     * The filter to search for the fct_pass to update in case it exists.
     */
    where: fct_passWhereUniqueInput
    /**
     * In case the fct_pass found by the `where` argument doesn't exist, create a new fct_pass with this data.
     */
    create: XOR<fct_passCreateInput, fct_passUncheckedCreateInput>
    /**
     * In case the fct_pass was found with the provided `where` argument, update it with this data.
     */
    update: XOR<fct_passUpdateInput, fct_passUncheckedUpdateInput>
  }


  /**
   * fct_pass delete
   */
  export type fct_passDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fct_pass
     */
    select?: fct_passSelect<ExtArgs> | null
    /**
     * Filter which fct_pass to delete.
     */
    where: fct_passWhereUniqueInput
  }


  /**
   * fct_pass deleteMany
   */
  export type fct_passDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which fct_passes to delete
     */
    where?: fct_passWhereInput
  }


  /**
   * fct_pass without action
   */
  export type fct_passDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fct_pass
     */
    select?: fct_passSelect<ExtArgs> | null
  }



  /**
   * Model fct_temp
   */

  export type AggregateFct_temp = {
    _count: Fct_tempCountAggregateOutputType | null
    _avg: Fct_tempAvgAggregateOutputType | null
    _sum: Fct_tempSumAggregateOutputType | null
    _min: Fct_tempMinAggregateOutputType | null
    _max: Fct_tempMaxAggregateOutputType | null
  }

  export type Fct_tempAvgAggregateOutputType = {
    id: number | null
    total_output: number | null
    total_defect: number | null
    target: number | null
  }

  export type Fct_tempSumAggregateOutputType = {
    id: number | null
    total_output: number | null
    total_defect: number | null
    target: number | null
  }

  export type Fct_tempMinAggregateOutputType = {
    id: number | null
    type: string | null
    line: string | null
    timestamp: Date | null
    total_output: number | null
    total_defect: number | null
    target: number | null
  }

  export type Fct_tempMaxAggregateOutputType = {
    id: number | null
    type: string | null
    line: string | null
    timestamp: Date | null
    total_output: number | null
    total_defect: number | null
    target: number | null
  }

  export type Fct_tempCountAggregateOutputType = {
    id: number
    type: number
    line: number
    timestamp: number
    total_output: number
    total_defect: number
    target: number
    _all: number
  }


  export type Fct_tempAvgAggregateInputType = {
    id?: true
    total_output?: true
    total_defect?: true
    target?: true
  }

  export type Fct_tempSumAggregateInputType = {
    id?: true
    total_output?: true
    total_defect?: true
    target?: true
  }

  export type Fct_tempMinAggregateInputType = {
    id?: true
    type?: true
    line?: true
    timestamp?: true
    total_output?: true
    total_defect?: true
    target?: true
  }

  export type Fct_tempMaxAggregateInputType = {
    id?: true
    type?: true
    line?: true
    timestamp?: true
    total_output?: true
    total_defect?: true
    target?: true
  }

  export type Fct_tempCountAggregateInputType = {
    id?: true
    type?: true
    line?: true
    timestamp?: true
    total_output?: true
    total_defect?: true
    target?: true
    _all?: true
  }

  export type Fct_tempAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which fct_temp to aggregate.
     */
    where?: fct_tempWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fct_temps to fetch.
     */
    orderBy?: fct_tempOrderByWithRelationInput | fct_tempOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: fct_tempWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fct_temps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fct_temps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned fct_temps
    **/
    _count?: true | Fct_tempCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Fct_tempAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Fct_tempSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Fct_tempMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Fct_tempMaxAggregateInputType
  }

  export type GetFct_tempAggregateType<T extends Fct_tempAggregateArgs> = {
        [P in keyof T & keyof AggregateFct_temp]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFct_temp[P]>
      : GetScalarType<T[P], AggregateFct_temp[P]>
  }




  export type fct_tempGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: fct_tempWhereInput
    orderBy?: fct_tempOrderByWithAggregationInput | fct_tempOrderByWithAggregationInput[]
    by: Fct_tempScalarFieldEnum[] | Fct_tempScalarFieldEnum
    having?: fct_tempScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Fct_tempCountAggregateInputType | true
    _avg?: Fct_tempAvgAggregateInputType
    _sum?: Fct_tempSumAggregateInputType
    _min?: Fct_tempMinAggregateInputType
    _max?: Fct_tempMaxAggregateInputType
  }

  export type Fct_tempGroupByOutputType = {
    id: number
    type: string
    line: string
    timestamp: Date
    total_output: number
    total_defect: number
    target: number
    _count: Fct_tempCountAggregateOutputType | null
    _avg: Fct_tempAvgAggregateOutputType | null
    _sum: Fct_tempSumAggregateOutputType | null
    _min: Fct_tempMinAggregateOutputType | null
    _max: Fct_tempMaxAggregateOutputType | null
  }

  type GetFct_tempGroupByPayload<T extends fct_tempGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Fct_tempGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Fct_tempGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Fct_tempGroupByOutputType[P]>
            : GetScalarType<T[P], Fct_tempGroupByOutputType[P]>
        }
      >
    >


  export type fct_tempSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    line?: boolean
    timestamp?: boolean
    total_output?: boolean
    total_defect?: boolean
    target?: boolean
  }, ExtArgs["result"]["fct_temp"]>

  export type fct_tempSelectScalar = {
    id?: boolean
    type?: boolean
    line?: boolean
    timestamp?: boolean
    total_output?: boolean
    total_defect?: boolean
    target?: boolean
  }


  export type $fct_tempPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "fct_temp"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      type: string
      line: string
      timestamp: Date
      total_output: number
      total_defect: number
      target: number
    }, ExtArgs["result"]["fct_temp"]>
    composites: {}
  }


  type fct_tempGetPayload<S extends boolean | null | undefined | fct_tempDefaultArgs> = $Result.GetResult<Prisma.$fct_tempPayload, S>

  type fct_tempCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<fct_tempFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Fct_tempCountAggregateInputType | true
    }

  export interface fct_tempDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['fct_temp'], meta: { name: 'fct_temp' } }
    /**
     * Find zero or one Fct_temp that matches the filter.
     * @param {fct_tempFindUniqueArgs} args - Arguments to find a Fct_temp
     * @example
     * // Get one Fct_temp
     * const fct_temp = await prisma.fct_temp.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends fct_tempFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, fct_tempFindUniqueArgs<ExtArgs>>
    ): Prisma__fct_tempClient<$Result.GetResult<Prisma.$fct_tempPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Fct_temp that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {fct_tempFindUniqueOrThrowArgs} args - Arguments to find a Fct_temp
     * @example
     * // Get one Fct_temp
     * const fct_temp = await prisma.fct_temp.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends fct_tempFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, fct_tempFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__fct_tempClient<$Result.GetResult<Prisma.$fct_tempPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Fct_temp that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fct_tempFindFirstArgs} args - Arguments to find a Fct_temp
     * @example
     * // Get one Fct_temp
     * const fct_temp = await prisma.fct_temp.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends fct_tempFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, fct_tempFindFirstArgs<ExtArgs>>
    ): Prisma__fct_tempClient<$Result.GetResult<Prisma.$fct_tempPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Fct_temp that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fct_tempFindFirstOrThrowArgs} args - Arguments to find a Fct_temp
     * @example
     * // Get one Fct_temp
     * const fct_temp = await prisma.fct_temp.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends fct_tempFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, fct_tempFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__fct_tempClient<$Result.GetResult<Prisma.$fct_tempPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Fct_temps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fct_tempFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Fct_temps
     * const fct_temps = await prisma.fct_temp.findMany()
     * 
     * // Get first 10 Fct_temps
     * const fct_temps = await prisma.fct_temp.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fct_tempWithIdOnly = await prisma.fct_temp.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends fct_tempFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, fct_tempFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$fct_tempPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Fct_temp.
     * @param {fct_tempCreateArgs} args - Arguments to create a Fct_temp.
     * @example
     * // Create one Fct_temp
     * const Fct_temp = await prisma.fct_temp.create({
     *   data: {
     *     // ... data to create a Fct_temp
     *   }
     * })
     * 
    **/
    create<T extends fct_tempCreateArgs<ExtArgs>>(
      args: SelectSubset<T, fct_tempCreateArgs<ExtArgs>>
    ): Prisma__fct_tempClient<$Result.GetResult<Prisma.$fct_tempPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Fct_temps.
     *     @param {fct_tempCreateManyArgs} args - Arguments to create many Fct_temps.
     *     @example
     *     // Create many Fct_temps
     *     const fct_temp = await prisma.fct_temp.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends fct_tempCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, fct_tempCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Fct_temp.
     * @param {fct_tempDeleteArgs} args - Arguments to delete one Fct_temp.
     * @example
     * // Delete one Fct_temp
     * const Fct_temp = await prisma.fct_temp.delete({
     *   where: {
     *     // ... filter to delete one Fct_temp
     *   }
     * })
     * 
    **/
    delete<T extends fct_tempDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, fct_tempDeleteArgs<ExtArgs>>
    ): Prisma__fct_tempClient<$Result.GetResult<Prisma.$fct_tempPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Fct_temp.
     * @param {fct_tempUpdateArgs} args - Arguments to update one Fct_temp.
     * @example
     * // Update one Fct_temp
     * const fct_temp = await prisma.fct_temp.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends fct_tempUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, fct_tempUpdateArgs<ExtArgs>>
    ): Prisma__fct_tempClient<$Result.GetResult<Prisma.$fct_tempPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Fct_temps.
     * @param {fct_tempDeleteManyArgs} args - Arguments to filter Fct_temps to delete.
     * @example
     * // Delete a few Fct_temps
     * const { count } = await prisma.fct_temp.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends fct_tempDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, fct_tempDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Fct_temps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fct_tempUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Fct_temps
     * const fct_temp = await prisma.fct_temp.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends fct_tempUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, fct_tempUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Fct_temp.
     * @param {fct_tempUpsertArgs} args - Arguments to update or create a Fct_temp.
     * @example
     * // Update or create a Fct_temp
     * const fct_temp = await prisma.fct_temp.upsert({
     *   create: {
     *     // ... data to create a Fct_temp
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Fct_temp we want to update
     *   }
     * })
    **/
    upsert<T extends fct_tempUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, fct_tempUpsertArgs<ExtArgs>>
    ): Prisma__fct_tempClient<$Result.GetResult<Prisma.$fct_tempPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Fct_temps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fct_tempCountArgs} args - Arguments to filter Fct_temps to count.
     * @example
     * // Count the number of Fct_temps
     * const count = await prisma.fct_temp.count({
     *   where: {
     *     // ... the filter for the Fct_temps we want to count
     *   }
     * })
    **/
    count<T extends fct_tempCountArgs>(
      args?: Subset<T, fct_tempCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Fct_tempCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Fct_temp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Fct_tempAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Fct_tempAggregateArgs>(args: Subset<T, Fct_tempAggregateArgs>): Prisma.PrismaPromise<GetFct_tempAggregateType<T>>

    /**
     * Group by Fct_temp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fct_tempGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends fct_tempGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: fct_tempGroupByArgs['orderBy'] }
        : { orderBy?: fct_tempGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, fct_tempGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFct_tempGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the fct_temp model
   */
  readonly fields: fct_tempFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for fct_temp.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__fct_tempClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the fct_temp model
   */ 
  interface fct_tempFieldRefs {
    readonly id: FieldRef<"fct_temp", 'Int'>
    readonly type: FieldRef<"fct_temp", 'String'>
    readonly line: FieldRef<"fct_temp", 'String'>
    readonly timestamp: FieldRef<"fct_temp", 'DateTime'>
    readonly total_output: FieldRef<"fct_temp", 'Int'>
    readonly total_defect: FieldRef<"fct_temp", 'Int'>
    readonly target: FieldRef<"fct_temp", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * fct_temp findUnique
   */
  export type fct_tempFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fct_temp
     */
    select?: fct_tempSelect<ExtArgs> | null
    /**
     * Filter, which fct_temp to fetch.
     */
    where: fct_tempWhereUniqueInput
  }


  /**
   * fct_temp findUniqueOrThrow
   */
  export type fct_tempFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fct_temp
     */
    select?: fct_tempSelect<ExtArgs> | null
    /**
     * Filter, which fct_temp to fetch.
     */
    where: fct_tempWhereUniqueInput
  }


  /**
   * fct_temp findFirst
   */
  export type fct_tempFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fct_temp
     */
    select?: fct_tempSelect<ExtArgs> | null
    /**
     * Filter, which fct_temp to fetch.
     */
    where?: fct_tempWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fct_temps to fetch.
     */
    orderBy?: fct_tempOrderByWithRelationInput | fct_tempOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for fct_temps.
     */
    cursor?: fct_tempWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fct_temps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fct_temps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of fct_temps.
     */
    distinct?: Fct_tempScalarFieldEnum | Fct_tempScalarFieldEnum[]
  }


  /**
   * fct_temp findFirstOrThrow
   */
  export type fct_tempFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fct_temp
     */
    select?: fct_tempSelect<ExtArgs> | null
    /**
     * Filter, which fct_temp to fetch.
     */
    where?: fct_tempWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fct_temps to fetch.
     */
    orderBy?: fct_tempOrderByWithRelationInput | fct_tempOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for fct_temps.
     */
    cursor?: fct_tempWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fct_temps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fct_temps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of fct_temps.
     */
    distinct?: Fct_tempScalarFieldEnum | Fct_tempScalarFieldEnum[]
  }


  /**
   * fct_temp findMany
   */
  export type fct_tempFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fct_temp
     */
    select?: fct_tempSelect<ExtArgs> | null
    /**
     * Filter, which fct_temps to fetch.
     */
    where?: fct_tempWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fct_temps to fetch.
     */
    orderBy?: fct_tempOrderByWithRelationInput | fct_tempOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing fct_temps.
     */
    cursor?: fct_tempWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fct_temps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fct_temps.
     */
    skip?: number
    distinct?: Fct_tempScalarFieldEnum | Fct_tempScalarFieldEnum[]
  }


  /**
   * fct_temp create
   */
  export type fct_tempCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fct_temp
     */
    select?: fct_tempSelect<ExtArgs> | null
    /**
     * The data needed to create a fct_temp.
     */
    data: XOR<fct_tempCreateInput, fct_tempUncheckedCreateInput>
  }


  /**
   * fct_temp createMany
   */
  export type fct_tempCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many fct_temps.
     */
    data: fct_tempCreateManyInput | fct_tempCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * fct_temp update
   */
  export type fct_tempUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fct_temp
     */
    select?: fct_tempSelect<ExtArgs> | null
    /**
     * The data needed to update a fct_temp.
     */
    data: XOR<fct_tempUpdateInput, fct_tempUncheckedUpdateInput>
    /**
     * Choose, which fct_temp to update.
     */
    where: fct_tempWhereUniqueInput
  }


  /**
   * fct_temp updateMany
   */
  export type fct_tempUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update fct_temps.
     */
    data: XOR<fct_tempUpdateManyMutationInput, fct_tempUncheckedUpdateManyInput>
    /**
     * Filter which fct_temps to update
     */
    where?: fct_tempWhereInput
  }


  /**
   * fct_temp upsert
   */
  export type fct_tempUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fct_temp
     */
    select?: fct_tempSelect<ExtArgs> | null
    /**
     * The filter to search for the fct_temp to update in case it exists.
     */
    where: fct_tempWhereUniqueInput
    /**
     * In case the fct_temp found by the `where` argument doesn't exist, create a new fct_temp with this data.
     */
    create: XOR<fct_tempCreateInput, fct_tempUncheckedCreateInput>
    /**
     * In case the fct_temp was found with the provided `where` argument, update it with this data.
     */
    update: XOR<fct_tempUpdateInput, fct_tempUncheckedUpdateInput>
  }


  /**
   * fct_temp delete
   */
  export type fct_tempDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fct_temp
     */
    select?: fct_tempSelect<ExtArgs> | null
    /**
     * Filter which fct_temp to delete.
     */
    where: fct_tempWhereUniqueInput
  }


  /**
   * fct_temp deleteMany
   */
  export type fct_tempDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which fct_temps to delete
     */
    where?: fct_tempWhereInput
  }


  /**
   * fct_temp without action
   */
  export type fct_tempDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fct_temp
     */
    select?: fct_tempSelect<ExtArgs> | null
  }



  /**
   * Model filestore_file
   */

  export type AggregateFilestore_file = {
    _count: Filestore_fileCountAggregateOutputType | null
    _avg: Filestore_fileAvgAggregateOutputType | null
    _sum: Filestore_fileSumAggregateOutputType | null
    _min: Filestore_fileMinAggregateOutputType | null
    _max: Filestore_fileMaxAggregateOutputType | null
  }

  export type Filestore_fileAvgAggregateOutputType = {
    id: number | null
    filestore_type_id: number | null
    filestore_volume_id: number | null
    filesize: number | null
    filenum: number | null
  }

  export type Filestore_fileSumAggregateOutputType = {
    id: number | null
    filestore_type_id: number | null
    filestore_volume_id: number | null
    filesize: number | null
    filenum: number | null
  }

  export type Filestore_fileMinAggregateOutputType = {
    id: number | null
    filestore_type_id: number | null
    filestore_volume_id: number | null
    filename: string | null
    original_filename: string | null
    filesize: number | null
    filenum: number | null
    deleted: $Enums.filestore_file_deleted | null
  }

  export type Filestore_fileMaxAggregateOutputType = {
    id: number | null
    filestore_type_id: number | null
    filestore_volume_id: number | null
    filename: string | null
    original_filename: string | null
    filesize: number | null
    filenum: number | null
    deleted: $Enums.filestore_file_deleted | null
  }

  export type Filestore_fileCountAggregateOutputType = {
    id: number
    filestore_type_id: number
    filestore_volume_id: number
    filename: number
    original_filename: number
    filesize: number
    filenum: number
    deleted: number
    _all: number
  }


  export type Filestore_fileAvgAggregateInputType = {
    id?: true
    filestore_type_id?: true
    filestore_volume_id?: true
    filesize?: true
    filenum?: true
  }

  export type Filestore_fileSumAggregateInputType = {
    id?: true
    filestore_type_id?: true
    filestore_volume_id?: true
    filesize?: true
    filenum?: true
  }

  export type Filestore_fileMinAggregateInputType = {
    id?: true
    filestore_type_id?: true
    filestore_volume_id?: true
    filename?: true
    original_filename?: true
    filesize?: true
    filenum?: true
    deleted?: true
  }

  export type Filestore_fileMaxAggregateInputType = {
    id?: true
    filestore_type_id?: true
    filestore_volume_id?: true
    filename?: true
    original_filename?: true
    filesize?: true
    filenum?: true
    deleted?: true
  }

  export type Filestore_fileCountAggregateInputType = {
    id?: true
    filestore_type_id?: true
    filestore_volume_id?: true
    filename?: true
    original_filename?: true
    filesize?: true
    filenum?: true
    deleted?: true
    _all?: true
  }

  export type Filestore_fileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which filestore_file to aggregate.
     */
    where?: filestore_fileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of filestore_files to fetch.
     */
    orderBy?: filestore_fileOrderByWithRelationInput | filestore_fileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: filestore_fileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` filestore_files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` filestore_files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned filestore_files
    **/
    _count?: true | Filestore_fileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Filestore_fileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Filestore_fileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Filestore_fileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Filestore_fileMaxAggregateInputType
  }

  export type GetFilestore_fileAggregateType<T extends Filestore_fileAggregateArgs> = {
        [P in keyof T & keyof AggregateFilestore_file]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFilestore_file[P]>
      : GetScalarType<T[P], AggregateFilestore_file[P]>
  }




  export type filestore_fileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: filestore_fileWhereInput
    orderBy?: filestore_fileOrderByWithAggregationInput | filestore_fileOrderByWithAggregationInput[]
    by: Filestore_fileScalarFieldEnum[] | Filestore_fileScalarFieldEnum
    having?: filestore_fileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Filestore_fileCountAggregateInputType | true
    _avg?: Filestore_fileAvgAggregateInputType
    _sum?: Filestore_fileSumAggregateInputType
    _min?: Filestore_fileMinAggregateInputType
    _max?: Filestore_fileMaxAggregateInputType
  }

  export type Filestore_fileGroupByOutputType = {
    id: number
    filestore_type_id: number
    filestore_volume_id: number
    filename: string
    original_filename: string | null
    filesize: number
    filenum: number
    deleted: $Enums.filestore_file_deleted
    _count: Filestore_fileCountAggregateOutputType | null
    _avg: Filestore_fileAvgAggregateOutputType | null
    _sum: Filestore_fileSumAggregateOutputType | null
    _min: Filestore_fileMinAggregateOutputType | null
    _max: Filestore_fileMaxAggregateOutputType | null
  }

  type GetFilestore_fileGroupByPayload<T extends filestore_fileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Filestore_fileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Filestore_fileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Filestore_fileGroupByOutputType[P]>
            : GetScalarType<T[P], Filestore_fileGroupByOutputType[P]>
        }
      >
    >


  export type filestore_fileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    filestore_type_id?: boolean
    filestore_volume_id?: boolean
    filename?: boolean
    original_filename?: boolean
    filesize?: boolean
    filenum?: boolean
    deleted?: boolean
  }, ExtArgs["result"]["filestore_file"]>

  export type filestore_fileSelectScalar = {
    id?: boolean
    filestore_type_id?: boolean
    filestore_volume_id?: boolean
    filename?: boolean
    original_filename?: boolean
    filesize?: boolean
    filenum?: boolean
    deleted?: boolean
  }


  export type $filestore_filePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "filestore_file"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      filestore_type_id: number
      filestore_volume_id: number
      filename: string
      original_filename: string | null
      filesize: number
      filenum: number
      deleted: $Enums.filestore_file_deleted
    }, ExtArgs["result"]["filestore_file"]>
    composites: {}
  }


  type filestore_fileGetPayload<S extends boolean | null | undefined | filestore_fileDefaultArgs> = $Result.GetResult<Prisma.$filestore_filePayload, S>

  type filestore_fileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<filestore_fileFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Filestore_fileCountAggregateInputType | true
    }

  export interface filestore_fileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['filestore_file'], meta: { name: 'filestore_file' } }
    /**
     * Find zero or one Filestore_file that matches the filter.
     * @param {filestore_fileFindUniqueArgs} args - Arguments to find a Filestore_file
     * @example
     * // Get one Filestore_file
     * const filestore_file = await prisma.filestore_file.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends filestore_fileFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, filestore_fileFindUniqueArgs<ExtArgs>>
    ): Prisma__filestore_fileClient<$Result.GetResult<Prisma.$filestore_filePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Filestore_file that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {filestore_fileFindUniqueOrThrowArgs} args - Arguments to find a Filestore_file
     * @example
     * // Get one Filestore_file
     * const filestore_file = await prisma.filestore_file.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends filestore_fileFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, filestore_fileFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__filestore_fileClient<$Result.GetResult<Prisma.$filestore_filePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Filestore_file that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {filestore_fileFindFirstArgs} args - Arguments to find a Filestore_file
     * @example
     * // Get one Filestore_file
     * const filestore_file = await prisma.filestore_file.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends filestore_fileFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, filestore_fileFindFirstArgs<ExtArgs>>
    ): Prisma__filestore_fileClient<$Result.GetResult<Prisma.$filestore_filePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Filestore_file that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {filestore_fileFindFirstOrThrowArgs} args - Arguments to find a Filestore_file
     * @example
     * // Get one Filestore_file
     * const filestore_file = await prisma.filestore_file.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends filestore_fileFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, filestore_fileFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__filestore_fileClient<$Result.GetResult<Prisma.$filestore_filePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Filestore_files that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {filestore_fileFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Filestore_files
     * const filestore_files = await prisma.filestore_file.findMany()
     * 
     * // Get first 10 Filestore_files
     * const filestore_files = await prisma.filestore_file.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const filestore_fileWithIdOnly = await prisma.filestore_file.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends filestore_fileFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, filestore_fileFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$filestore_filePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Filestore_file.
     * @param {filestore_fileCreateArgs} args - Arguments to create a Filestore_file.
     * @example
     * // Create one Filestore_file
     * const Filestore_file = await prisma.filestore_file.create({
     *   data: {
     *     // ... data to create a Filestore_file
     *   }
     * })
     * 
    **/
    create<T extends filestore_fileCreateArgs<ExtArgs>>(
      args: SelectSubset<T, filestore_fileCreateArgs<ExtArgs>>
    ): Prisma__filestore_fileClient<$Result.GetResult<Prisma.$filestore_filePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Filestore_files.
     *     @param {filestore_fileCreateManyArgs} args - Arguments to create many Filestore_files.
     *     @example
     *     // Create many Filestore_files
     *     const filestore_file = await prisma.filestore_file.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends filestore_fileCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, filestore_fileCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Filestore_file.
     * @param {filestore_fileDeleteArgs} args - Arguments to delete one Filestore_file.
     * @example
     * // Delete one Filestore_file
     * const Filestore_file = await prisma.filestore_file.delete({
     *   where: {
     *     // ... filter to delete one Filestore_file
     *   }
     * })
     * 
    **/
    delete<T extends filestore_fileDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, filestore_fileDeleteArgs<ExtArgs>>
    ): Prisma__filestore_fileClient<$Result.GetResult<Prisma.$filestore_filePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Filestore_file.
     * @param {filestore_fileUpdateArgs} args - Arguments to update one Filestore_file.
     * @example
     * // Update one Filestore_file
     * const filestore_file = await prisma.filestore_file.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends filestore_fileUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, filestore_fileUpdateArgs<ExtArgs>>
    ): Prisma__filestore_fileClient<$Result.GetResult<Prisma.$filestore_filePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Filestore_files.
     * @param {filestore_fileDeleteManyArgs} args - Arguments to filter Filestore_files to delete.
     * @example
     * // Delete a few Filestore_files
     * const { count } = await prisma.filestore_file.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends filestore_fileDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, filestore_fileDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Filestore_files.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {filestore_fileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Filestore_files
     * const filestore_file = await prisma.filestore_file.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends filestore_fileUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, filestore_fileUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Filestore_file.
     * @param {filestore_fileUpsertArgs} args - Arguments to update or create a Filestore_file.
     * @example
     * // Update or create a Filestore_file
     * const filestore_file = await prisma.filestore_file.upsert({
     *   create: {
     *     // ... data to create a Filestore_file
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Filestore_file we want to update
     *   }
     * })
    **/
    upsert<T extends filestore_fileUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, filestore_fileUpsertArgs<ExtArgs>>
    ): Prisma__filestore_fileClient<$Result.GetResult<Prisma.$filestore_filePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Filestore_files.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {filestore_fileCountArgs} args - Arguments to filter Filestore_files to count.
     * @example
     * // Count the number of Filestore_files
     * const count = await prisma.filestore_file.count({
     *   where: {
     *     // ... the filter for the Filestore_files we want to count
     *   }
     * })
    **/
    count<T extends filestore_fileCountArgs>(
      args?: Subset<T, filestore_fileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Filestore_fileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Filestore_file.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Filestore_fileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Filestore_fileAggregateArgs>(args: Subset<T, Filestore_fileAggregateArgs>): Prisma.PrismaPromise<GetFilestore_fileAggregateType<T>>

    /**
     * Group by Filestore_file.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {filestore_fileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends filestore_fileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: filestore_fileGroupByArgs['orderBy'] }
        : { orderBy?: filestore_fileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, filestore_fileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFilestore_fileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the filestore_file model
   */
  readonly fields: filestore_fileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for filestore_file.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__filestore_fileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the filestore_file model
   */ 
  interface filestore_fileFieldRefs {
    readonly id: FieldRef<"filestore_file", 'Int'>
    readonly filestore_type_id: FieldRef<"filestore_file", 'Int'>
    readonly filestore_volume_id: FieldRef<"filestore_file", 'Int'>
    readonly filename: FieldRef<"filestore_file", 'String'>
    readonly original_filename: FieldRef<"filestore_file", 'String'>
    readonly filesize: FieldRef<"filestore_file", 'Int'>
    readonly filenum: FieldRef<"filestore_file", 'Int'>
    readonly deleted: FieldRef<"filestore_file", 'filestore_file_deleted'>
  }
    

  // Custom InputTypes

  /**
   * filestore_file findUnique
   */
  export type filestore_fileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the filestore_file
     */
    select?: filestore_fileSelect<ExtArgs> | null
    /**
     * Filter, which filestore_file to fetch.
     */
    where: filestore_fileWhereUniqueInput
  }


  /**
   * filestore_file findUniqueOrThrow
   */
  export type filestore_fileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the filestore_file
     */
    select?: filestore_fileSelect<ExtArgs> | null
    /**
     * Filter, which filestore_file to fetch.
     */
    where: filestore_fileWhereUniqueInput
  }


  /**
   * filestore_file findFirst
   */
  export type filestore_fileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the filestore_file
     */
    select?: filestore_fileSelect<ExtArgs> | null
    /**
     * Filter, which filestore_file to fetch.
     */
    where?: filestore_fileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of filestore_files to fetch.
     */
    orderBy?: filestore_fileOrderByWithRelationInput | filestore_fileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for filestore_files.
     */
    cursor?: filestore_fileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` filestore_files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` filestore_files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of filestore_files.
     */
    distinct?: Filestore_fileScalarFieldEnum | Filestore_fileScalarFieldEnum[]
  }


  /**
   * filestore_file findFirstOrThrow
   */
  export type filestore_fileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the filestore_file
     */
    select?: filestore_fileSelect<ExtArgs> | null
    /**
     * Filter, which filestore_file to fetch.
     */
    where?: filestore_fileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of filestore_files to fetch.
     */
    orderBy?: filestore_fileOrderByWithRelationInput | filestore_fileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for filestore_files.
     */
    cursor?: filestore_fileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` filestore_files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` filestore_files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of filestore_files.
     */
    distinct?: Filestore_fileScalarFieldEnum | Filestore_fileScalarFieldEnum[]
  }


  /**
   * filestore_file findMany
   */
  export type filestore_fileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the filestore_file
     */
    select?: filestore_fileSelect<ExtArgs> | null
    /**
     * Filter, which filestore_files to fetch.
     */
    where?: filestore_fileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of filestore_files to fetch.
     */
    orderBy?: filestore_fileOrderByWithRelationInput | filestore_fileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing filestore_files.
     */
    cursor?: filestore_fileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` filestore_files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` filestore_files.
     */
    skip?: number
    distinct?: Filestore_fileScalarFieldEnum | Filestore_fileScalarFieldEnum[]
  }


  /**
   * filestore_file create
   */
  export type filestore_fileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the filestore_file
     */
    select?: filestore_fileSelect<ExtArgs> | null
    /**
     * The data needed to create a filestore_file.
     */
    data?: XOR<filestore_fileCreateInput, filestore_fileUncheckedCreateInput>
  }


  /**
   * filestore_file createMany
   */
  export type filestore_fileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many filestore_files.
     */
    data: filestore_fileCreateManyInput | filestore_fileCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * filestore_file update
   */
  export type filestore_fileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the filestore_file
     */
    select?: filestore_fileSelect<ExtArgs> | null
    /**
     * The data needed to update a filestore_file.
     */
    data: XOR<filestore_fileUpdateInput, filestore_fileUncheckedUpdateInput>
    /**
     * Choose, which filestore_file to update.
     */
    where: filestore_fileWhereUniqueInput
  }


  /**
   * filestore_file updateMany
   */
  export type filestore_fileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update filestore_files.
     */
    data: XOR<filestore_fileUpdateManyMutationInput, filestore_fileUncheckedUpdateManyInput>
    /**
     * Filter which filestore_files to update
     */
    where?: filestore_fileWhereInput
  }


  /**
   * filestore_file upsert
   */
  export type filestore_fileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the filestore_file
     */
    select?: filestore_fileSelect<ExtArgs> | null
    /**
     * The filter to search for the filestore_file to update in case it exists.
     */
    where: filestore_fileWhereUniqueInput
    /**
     * In case the filestore_file found by the `where` argument doesn't exist, create a new filestore_file with this data.
     */
    create: XOR<filestore_fileCreateInput, filestore_fileUncheckedCreateInput>
    /**
     * In case the filestore_file was found with the provided `where` argument, update it with this data.
     */
    update: XOR<filestore_fileUpdateInput, filestore_fileUncheckedUpdateInput>
  }


  /**
   * filestore_file delete
   */
  export type filestore_fileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the filestore_file
     */
    select?: filestore_fileSelect<ExtArgs> | null
    /**
     * Filter which filestore_file to delete.
     */
    where: filestore_fileWhereUniqueInput
  }


  /**
   * filestore_file deleteMany
   */
  export type filestore_fileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which filestore_files to delete
     */
    where?: filestore_fileWhereInput
  }


  /**
   * filestore_file without action
   */
  export type filestore_fileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the filestore_file
     */
    select?: filestore_fileSelect<ExtArgs> | null
  }



  /**
   * Model filestore_type
   */

  export type AggregateFilestore_type = {
    _count: Filestore_typeCountAggregateOutputType | null
    _avg: Filestore_typeAvgAggregateOutputType | null
    _sum: Filestore_typeSumAggregateOutputType | null
    _min: Filestore_typeMinAggregateOutputType | null
    _max: Filestore_typeMaxAggregateOutputType | null
  }

  export type Filestore_typeAvgAggregateOutputType = {
    id: number | null
  }

  export type Filestore_typeSumAggregateOutputType = {
    id: number | null
  }

  export type Filestore_typeMinAggregateOutputType = {
    id: number | null
    name: string | null
    mime_type: string | null
    extension: string | null
  }

  export type Filestore_typeMaxAggregateOutputType = {
    id: number | null
    name: string | null
    mime_type: string | null
    extension: string | null
  }

  export type Filestore_typeCountAggregateOutputType = {
    id: number
    name: number
    mime_type: number
    extension: number
    _all: number
  }


  export type Filestore_typeAvgAggregateInputType = {
    id?: true
  }

  export type Filestore_typeSumAggregateInputType = {
    id?: true
  }

  export type Filestore_typeMinAggregateInputType = {
    id?: true
    name?: true
    mime_type?: true
    extension?: true
  }

  export type Filestore_typeMaxAggregateInputType = {
    id?: true
    name?: true
    mime_type?: true
    extension?: true
  }

  export type Filestore_typeCountAggregateInputType = {
    id?: true
    name?: true
    mime_type?: true
    extension?: true
    _all?: true
  }

  export type Filestore_typeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which filestore_type to aggregate.
     */
    where?: filestore_typeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of filestore_types to fetch.
     */
    orderBy?: filestore_typeOrderByWithRelationInput | filestore_typeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: filestore_typeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` filestore_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` filestore_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned filestore_types
    **/
    _count?: true | Filestore_typeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Filestore_typeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Filestore_typeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Filestore_typeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Filestore_typeMaxAggregateInputType
  }

  export type GetFilestore_typeAggregateType<T extends Filestore_typeAggregateArgs> = {
        [P in keyof T & keyof AggregateFilestore_type]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFilestore_type[P]>
      : GetScalarType<T[P], AggregateFilestore_type[P]>
  }




  export type filestore_typeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: filestore_typeWhereInput
    orderBy?: filestore_typeOrderByWithAggregationInput | filestore_typeOrderByWithAggregationInput[]
    by: Filestore_typeScalarFieldEnum[] | Filestore_typeScalarFieldEnum
    having?: filestore_typeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Filestore_typeCountAggregateInputType | true
    _avg?: Filestore_typeAvgAggregateInputType
    _sum?: Filestore_typeSumAggregateInputType
    _min?: Filestore_typeMinAggregateInputType
    _max?: Filestore_typeMaxAggregateInputType
  }

  export type Filestore_typeGroupByOutputType = {
    id: number
    name: string | null
    mime_type: string
    extension: string | null
    _count: Filestore_typeCountAggregateOutputType | null
    _avg: Filestore_typeAvgAggregateOutputType | null
    _sum: Filestore_typeSumAggregateOutputType | null
    _min: Filestore_typeMinAggregateOutputType | null
    _max: Filestore_typeMaxAggregateOutputType | null
  }

  type GetFilestore_typeGroupByPayload<T extends filestore_typeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Filestore_typeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Filestore_typeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Filestore_typeGroupByOutputType[P]>
            : GetScalarType<T[P], Filestore_typeGroupByOutputType[P]>
        }
      >
    >


  export type filestore_typeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    mime_type?: boolean
    extension?: boolean
  }, ExtArgs["result"]["filestore_type"]>

  export type filestore_typeSelectScalar = {
    id?: boolean
    name?: boolean
    mime_type?: boolean
    extension?: boolean
  }


  export type $filestore_typePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "filestore_type"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string | null
      mime_type: string
      extension: string | null
    }, ExtArgs["result"]["filestore_type"]>
    composites: {}
  }


  type filestore_typeGetPayload<S extends boolean | null | undefined | filestore_typeDefaultArgs> = $Result.GetResult<Prisma.$filestore_typePayload, S>

  type filestore_typeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<filestore_typeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Filestore_typeCountAggregateInputType | true
    }

  export interface filestore_typeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['filestore_type'], meta: { name: 'filestore_type' } }
    /**
     * Find zero or one Filestore_type that matches the filter.
     * @param {filestore_typeFindUniqueArgs} args - Arguments to find a Filestore_type
     * @example
     * // Get one Filestore_type
     * const filestore_type = await prisma.filestore_type.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends filestore_typeFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, filestore_typeFindUniqueArgs<ExtArgs>>
    ): Prisma__filestore_typeClient<$Result.GetResult<Prisma.$filestore_typePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Filestore_type that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {filestore_typeFindUniqueOrThrowArgs} args - Arguments to find a Filestore_type
     * @example
     * // Get one Filestore_type
     * const filestore_type = await prisma.filestore_type.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends filestore_typeFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, filestore_typeFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__filestore_typeClient<$Result.GetResult<Prisma.$filestore_typePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Filestore_type that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {filestore_typeFindFirstArgs} args - Arguments to find a Filestore_type
     * @example
     * // Get one Filestore_type
     * const filestore_type = await prisma.filestore_type.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends filestore_typeFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, filestore_typeFindFirstArgs<ExtArgs>>
    ): Prisma__filestore_typeClient<$Result.GetResult<Prisma.$filestore_typePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Filestore_type that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {filestore_typeFindFirstOrThrowArgs} args - Arguments to find a Filestore_type
     * @example
     * // Get one Filestore_type
     * const filestore_type = await prisma.filestore_type.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends filestore_typeFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, filestore_typeFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__filestore_typeClient<$Result.GetResult<Prisma.$filestore_typePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Filestore_types that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {filestore_typeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Filestore_types
     * const filestore_types = await prisma.filestore_type.findMany()
     * 
     * // Get first 10 Filestore_types
     * const filestore_types = await prisma.filestore_type.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const filestore_typeWithIdOnly = await prisma.filestore_type.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends filestore_typeFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, filestore_typeFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$filestore_typePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Filestore_type.
     * @param {filestore_typeCreateArgs} args - Arguments to create a Filestore_type.
     * @example
     * // Create one Filestore_type
     * const Filestore_type = await prisma.filestore_type.create({
     *   data: {
     *     // ... data to create a Filestore_type
     *   }
     * })
     * 
    **/
    create<T extends filestore_typeCreateArgs<ExtArgs>>(
      args: SelectSubset<T, filestore_typeCreateArgs<ExtArgs>>
    ): Prisma__filestore_typeClient<$Result.GetResult<Prisma.$filestore_typePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Filestore_types.
     *     @param {filestore_typeCreateManyArgs} args - Arguments to create many Filestore_types.
     *     @example
     *     // Create many Filestore_types
     *     const filestore_type = await prisma.filestore_type.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends filestore_typeCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, filestore_typeCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Filestore_type.
     * @param {filestore_typeDeleteArgs} args - Arguments to delete one Filestore_type.
     * @example
     * // Delete one Filestore_type
     * const Filestore_type = await prisma.filestore_type.delete({
     *   where: {
     *     // ... filter to delete one Filestore_type
     *   }
     * })
     * 
    **/
    delete<T extends filestore_typeDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, filestore_typeDeleteArgs<ExtArgs>>
    ): Prisma__filestore_typeClient<$Result.GetResult<Prisma.$filestore_typePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Filestore_type.
     * @param {filestore_typeUpdateArgs} args - Arguments to update one Filestore_type.
     * @example
     * // Update one Filestore_type
     * const filestore_type = await prisma.filestore_type.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends filestore_typeUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, filestore_typeUpdateArgs<ExtArgs>>
    ): Prisma__filestore_typeClient<$Result.GetResult<Prisma.$filestore_typePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Filestore_types.
     * @param {filestore_typeDeleteManyArgs} args - Arguments to filter Filestore_types to delete.
     * @example
     * // Delete a few Filestore_types
     * const { count } = await prisma.filestore_type.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends filestore_typeDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, filestore_typeDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Filestore_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {filestore_typeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Filestore_types
     * const filestore_type = await prisma.filestore_type.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends filestore_typeUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, filestore_typeUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Filestore_type.
     * @param {filestore_typeUpsertArgs} args - Arguments to update or create a Filestore_type.
     * @example
     * // Update or create a Filestore_type
     * const filestore_type = await prisma.filestore_type.upsert({
     *   create: {
     *     // ... data to create a Filestore_type
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Filestore_type we want to update
     *   }
     * })
    **/
    upsert<T extends filestore_typeUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, filestore_typeUpsertArgs<ExtArgs>>
    ): Prisma__filestore_typeClient<$Result.GetResult<Prisma.$filestore_typePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Filestore_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {filestore_typeCountArgs} args - Arguments to filter Filestore_types to count.
     * @example
     * // Count the number of Filestore_types
     * const count = await prisma.filestore_type.count({
     *   where: {
     *     // ... the filter for the Filestore_types we want to count
     *   }
     * })
    **/
    count<T extends filestore_typeCountArgs>(
      args?: Subset<T, filestore_typeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Filestore_typeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Filestore_type.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Filestore_typeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Filestore_typeAggregateArgs>(args: Subset<T, Filestore_typeAggregateArgs>): Prisma.PrismaPromise<GetFilestore_typeAggregateType<T>>

    /**
     * Group by Filestore_type.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {filestore_typeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends filestore_typeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: filestore_typeGroupByArgs['orderBy'] }
        : { orderBy?: filestore_typeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, filestore_typeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFilestore_typeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the filestore_type model
   */
  readonly fields: filestore_typeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for filestore_type.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__filestore_typeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the filestore_type model
   */ 
  interface filestore_typeFieldRefs {
    readonly id: FieldRef<"filestore_type", 'Int'>
    readonly name: FieldRef<"filestore_type", 'String'>
    readonly mime_type: FieldRef<"filestore_type", 'String'>
    readonly extension: FieldRef<"filestore_type", 'String'>
  }
    

  // Custom InputTypes

  /**
   * filestore_type findUnique
   */
  export type filestore_typeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the filestore_type
     */
    select?: filestore_typeSelect<ExtArgs> | null
    /**
     * Filter, which filestore_type to fetch.
     */
    where: filestore_typeWhereUniqueInput
  }


  /**
   * filestore_type findUniqueOrThrow
   */
  export type filestore_typeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the filestore_type
     */
    select?: filestore_typeSelect<ExtArgs> | null
    /**
     * Filter, which filestore_type to fetch.
     */
    where: filestore_typeWhereUniqueInput
  }


  /**
   * filestore_type findFirst
   */
  export type filestore_typeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the filestore_type
     */
    select?: filestore_typeSelect<ExtArgs> | null
    /**
     * Filter, which filestore_type to fetch.
     */
    where?: filestore_typeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of filestore_types to fetch.
     */
    orderBy?: filestore_typeOrderByWithRelationInput | filestore_typeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for filestore_types.
     */
    cursor?: filestore_typeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` filestore_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` filestore_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of filestore_types.
     */
    distinct?: Filestore_typeScalarFieldEnum | Filestore_typeScalarFieldEnum[]
  }


  /**
   * filestore_type findFirstOrThrow
   */
  export type filestore_typeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the filestore_type
     */
    select?: filestore_typeSelect<ExtArgs> | null
    /**
     * Filter, which filestore_type to fetch.
     */
    where?: filestore_typeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of filestore_types to fetch.
     */
    orderBy?: filestore_typeOrderByWithRelationInput | filestore_typeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for filestore_types.
     */
    cursor?: filestore_typeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` filestore_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` filestore_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of filestore_types.
     */
    distinct?: Filestore_typeScalarFieldEnum | Filestore_typeScalarFieldEnum[]
  }


  /**
   * filestore_type findMany
   */
  export type filestore_typeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the filestore_type
     */
    select?: filestore_typeSelect<ExtArgs> | null
    /**
     * Filter, which filestore_types to fetch.
     */
    where?: filestore_typeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of filestore_types to fetch.
     */
    orderBy?: filestore_typeOrderByWithRelationInput | filestore_typeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing filestore_types.
     */
    cursor?: filestore_typeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` filestore_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` filestore_types.
     */
    skip?: number
    distinct?: Filestore_typeScalarFieldEnum | Filestore_typeScalarFieldEnum[]
  }


  /**
   * filestore_type create
   */
  export type filestore_typeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the filestore_type
     */
    select?: filestore_typeSelect<ExtArgs> | null
    /**
     * The data needed to create a filestore_type.
     */
    data?: XOR<filestore_typeCreateInput, filestore_typeUncheckedCreateInput>
  }


  /**
   * filestore_type createMany
   */
  export type filestore_typeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many filestore_types.
     */
    data: filestore_typeCreateManyInput | filestore_typeCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * filestore_type update
   */
  export type filestore_typeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the filestore_type
     */
    select?: filestore_typeSelect<ExtArgs> | null
    /**
     * The data needed to update a filestore_type.
     */
    data: XOR<filestore_typeUpdateInput, filestore_typeUncheckedUpdateInput>
    /**
     * Choose, which filestore_type to update.
     */
    where: filestore_typeWhereUniqueInput
  }


  /**
   * filestore_type updateMany
   */
  export type filestore_typeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update filestore_types.
     */
    data: XOR<filestore_typeUpdateManyMutationInput, filestore_typeUncheckedUpdateManyInput>
    /**
     * Filter which filestore_types to update
     */
    where?: filestore_typeWhereInput
  }


  /**
   * filestore_type upsert
   */
  export type filestore_typeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the filestore_type
     */
    select?: filestore_typeSelect<ExtArgs> | null
    /**
     * The filter to search for the filestore_type to update in case it exists.
     */
    where: filestore_typeWhereUniqueInput
    /**
     * In case the filestore_type found by the `where` argument doesn't exist, create a new filestore_type with this data.
     */
    create: XOR<filestore_typeCreateInput, filestore_typeUncheckedCreateInput>
    /**
     * In case the filestore_type was found with the provided `where` argument, update it with this data.
     */
    update: XOR<filestore_typeUpdateInput, filestore_typeUncheckedUpdateInput>
  }


  /**
   * filestore_type delete
   */
  export type filestore_typeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the filestore_type
     */
    select?: filestore_typeSelect<ExtArgs> | null
    /**
     * Filter which filestore_type to delete.
     */
    where: filestore_typeWhereUniqueInput
  }


  /**
   * filestore_type deleteMany
   */
  export type filestore_typeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which filestore_types to delete
     */
    where?: filestore_typeWhereInput
  }


  /**
   * filestore_type without action
   */
  export type filestore_typeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the filestore_type
     */
    select?: filestore_typeSelect<ExtArgs> | null
  }



  /**
   * Model filestore_volume
   */

  export type AggregateFilestore_volume = {
    _count: Filestore_volumeCountAggregateOutputType | null
    _avg: Filestore_volumeAvgAggregateOutputType | null
    _sum: Filestore_volumeSumAggregateOutputType | null
    _min: Filestore_volumeMinAggregateOutputType | null
    _max: Filestore_volumeMaxAggregateOutputType | null
  }

  export type Filestore_volumeAvgAggregateOutputType = {
    id: number | null
    total_space: number | null
    used_space: number | null
    stored_files_cnt: number | null
    last_filenum: number | null
  }

  export type Filestore_volumeSumAggregateOutputType = {
    id: number | null
    total_space: bigint | null
    used_space: bigint | null
    stored_files_cnt: number | null
    last_filenum: number | null
  }

  export type Filestore_volumeMinAggregateOutputType = {
    id: number | null
    name: string | null
    dirname: string | null
    total_space: bigint | null
    used_space: bigint | null
    stored_files_cnt: number | null
    enabled: $Enums.filestore_volume_enabled | null
    last_filenum: number | null
  }

  export type Filestore_volumeMaxAggregateOutputType = {
    id: number | null
    name: string | null
    dirname: string | null
    total_space: bigint | null
    used_space: bigint | null
    stored_files_cnt: number | null
    enabled: $Enums.filestore_volume_enabled | null
    last_filenum: number | null
  }

  export type Filestore_volumeCountAggregateOutputType = {
    id: number
    name: number
    dirname: number
    total_space: number
    used_space: number
    stored_files_cnt: number
    enabled: number
    last_filenum: number
    _all: number
  }


  export type Filestore_volumeAvgAggregateInputType = {
    id?: true
    total_space?: true
    used_space?: true
    stored_files_cnt?: true
    last_filenum?: true
  }

  export type Filestore_volumeSumAggregateInputType = {
    id?: true
    total_space?: true
    used_space?: true
    stored_files_cnt?: true
    last_filenum?: true
  }

  export type Filestore_volumeMinAggregateInputType = {
    id?: true
    name?: true
    dirname?: true
    total_space?: true
    used_space?: true
    stored_files_cnt?: true
    enabled?: true
    last_filenum?: true
  }

  export type Filestore_volumeMaxAggregateInputType = {
    id?: true
    name?: true
    dirname?: true
    total_space?: true
    used_space?: true
    stored_files_cnt?: true
    enabled?: true
    last_filenum?: true
  }

  export type Filestore_volumeCountAggregateInputType = {
    id?: true
    name?: true
    dirname?: true
    total_space?: true
    used_space?: true
    stored_files_cnt?: true
    enabled?: true
    last_filenum?: true
    _all?: true
  }

  export type Filestore_volumeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which filestore_volume to aggregate.
     */
    where?: filestore_volumeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of filestore_volumes to fetch.
     */
    orderBy?: filestore_volumeOrderByWithRelationInput | filestore_volumeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: filestore_volumeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` filestore_volumes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` filestore_volumes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned filestore_volumes
    **/
    _count?: true | Filestore_volumeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Filestore_volumeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Filestore_volumeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Filestore_volumeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Filestore_volumeMaxAggregateInputType
  }

  export type GetFilestore_volumeAggregateType<T extends Filestore_volumeAggregateArgs> = {
        [P in keyof T & keyof AggregateFilestore_volume]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFilestore_volume[P]>
      : GetScalarType<T[P], AggregateFilestore_volume[P]>
  }




  export type filestore_volumeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: filestore_volumeWhereInput
    orderBy?: filestore_volumeOrderByWithAggregationInput | filestore_volumeOrderByWithAggregationInput[]
    by: Filestore_volumeScalarFieldEnum[] | Filestore_volumeScalarFieldEnum
    having?: filestore_volumeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Filestore_volumeCountAggregateInputType | true
    _avg?: Filestore_volumeAvgAggregateInputType
    _sum?: Filestore_volumeSumAggregateInputType
    _min?: Filestore_volumeMinAggregateInputType
    _max?: Filestore_volumeMaxAggregateInputType
  }

  export type Filestore_volumeGroupByOutputType = {
    id: number
    name: string
    dirname: string
    total_space: bigint
    used_space: bigint
    stored_files_cnt: number
    enabled: $Enums.filestore_volume_enabled | null
    last_filenum: number | null
    _count: Filestore_volumeCountAggregateOutputType | null
    _avg: Filestore_volumeAvgAggregateOutputType | null
    _sum: Filestore_volumeSumAggregateOutputType | null
    _min: Filestore_volumeMinAggregateOutputType | null
    _max: Filestore_volumeMaxAggregateOutputType | null
  }

  type GetFilestore_volumeGroupByPayload<T extends filestore_volumeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Filestore_volumeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Filestore_volumeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Filestore_volumeGroupByOutputType[P]>
            : GetScalarType<T[P], Filestore_volumeGroupByOutputType[P]>
        }
      >
    >


  export type filestore_volumeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    dirname?: boolean
    total_space?: boolean
    used_space?: boolean
    stored_files_cnt?: boolean
    enabled?: boolean
    last_filenum?: boolean
  }, ExtArgs["result"]["filestore_volume"]>

  export type filestore_volumeSelectScalar = {
    id?: boolean
    name?: boolean
    dirname?: boolean
    total_space?: boolean
    used_space?: boolean
    stored_files_cnt?: boolean
    enabled?: boolean
    last_filenum?: boolean
  }


  export type $filestore_volumePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "filestore_volume"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      dirname: string
      total_space: bigint
      used_space: bigint
      stored_files_cnt: number
      enabled: $Enums.filestore_volume_enabled | null
      last_filenum: number | null
    }, ExtArgs["result"]["filestore_volume"]>
    composites: {}
  }


  type filestore_volumeGetPayload<S extends boolean | null | undefined | filestore_volumeDefaultArgs> = $Result.GetResult<Prisma.$filestore_volumePayload, S>

  type filestore_volumeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<filestore_volumeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Filestore_volumeCountAggregateInputType | true
    }

  export interface filestore_volumeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['filestore_volume'], meta: { name: 'filestore_volume' } }
    /**
     * Find zero or one Filestore_volume that matches the filter.
     * @param {filestore_volumeFindUniqueArgs} args - Arguments to find a Filestore_volume
     * @example
     * // Get one Filestore_volume
     * const filestore_volume = await prisma.filestore_volume.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends filestore_volumeFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, filestore_volumeFindUniqueArgs<ExtArgs>>
    ): Prisma__filestore_volumeClient<$Result.GetResult<Prisma.$filestore_volumePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Filestore_volume that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {filestore_volumeFindUniqueOrThrowArgs} args - Arguments to find a Filestore_volume
     * @example
     * // Get one Filestore_volume
     * const filestore_volume = await prisma.filestore_volume.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends filestore_volumeFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, filestore_volumeFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__filestore_volumeClient<$Result.GetResult<Prisma.$filestore_volumePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Filestore_volume that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {filestore_volumeFindFirstArgs} args - Arguments to find a Filestore_volume
     * @example
     * // Get one Filestore_volume
     * const filestore_volume = await prisma.filestore_volume.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends filestore_volumeFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, filestore_volumeFindFirstArgs<ExtArgs>>
    ): Prisma__filestore_volumeClient<$Result.GetResult<Prisma.$filestore_volumePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Filestore_volume that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {filestore_volumeFindFirstOrThrowArgs} args - Arguments to find a Filestore_volume
     * @example
     * // Get one Filestore_volume
     * const filestore_volume = await prisma.filestore_volume.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends filestore_volumeFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, filestore_volumeFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__filestore_volumeClient<$Result.GetResult<Prisma.$filestore_volumePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Filestore_volumes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {filestore_volumeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Filestore_volumes
     * const filestore_volumes = await prisma.filestore_volume.findMany()
     * 
     * // Get first 10 Filestore_volumes
     * const filestore_volumes = await prisma.filestore_volume.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const filestore_volumeWithIdOnly = await prisma.filestore_volume.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends filestore_volumeFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, filestore_volumeFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$filestore_volumePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Filestore_volume.
     * @param {filestore_volumeCreateArgs} args - Arguments to create a Filestore_volume.
     * @example
     * // Create one Filestore_volume
     * const Filestore_volume = await prisma.filestore_volume.create({
     *   data: {
     *     // ... data to create a Filestore_volume
     *   }
     * })
     * 
    **/
    create<T extends filestore_volumeCreateArgs<ExtArgs>>(
      args: SelectSubset<T, filestore_volumeCreateArgs<ExtArgs>>
    ): Prisma__filestore_volumeClient<$Result.GetResult<Prisma.$filestore_volumePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Filestore_volumes.
     *     @param {filestore_volumeCreateManyArgs} args - Arguments to create many Filestore_volumes.
     *     @example
     *     // Create many Filestore_volumes
     *     const filestore_volume = await prisma.filestore_volume.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends filestore_volumeCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, filestore_volumeCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Filestore_volume.
     * @param {filestore_volumeDeleteArgs} args - Arguments to delete one Filestore_volume.
     * @example
     * // Delete one Filestore_volume
     * const Filestore_volume = await prisma.filestore_volume.delete({
     *   where: {
     *     // ... filter to delete one Filestore_volume
     *   }
     * })
     * 
    **/
    delete<T extends filestore_volumeDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, filestore_volumeDeleteArgs<ExtArgs>>
    ): Prisma__filestore_volumeClient<$Result.GetResult<Prisma.$filestore_volumePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Filestore_volume.
     * @param {filestore_volumeUpdateArgs} args - Arguments to update one Filestore_volume.
     * @example
     * // Update one Filestore_volume
     * const filestore_volume = await prisma.filestore_volume.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends filestore_volumeUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, filestore_volumeUpdateArgs<ExtArgs>>
    ): Prisma__filestore_volumeClient<$Result.GetResult<Prisma.$filestore_volumePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Filestore_volumes.
     * @param {filestore_volumeDeleteManyArgs} args - Arguments to filter Filestore_volumes to delete.
     * @example
     * // Delete a few Filestore_volumes
     * const { count } = await prisma.filestore_volume.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends filestore_volumeDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, filestore_volumeDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Filestore_volumes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {filestore_volumeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Filestore_volumes
     * const filestore_volume = await prisma.filestore_volume.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends filestore_volumeUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, filestore_volumeUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Filestore_volume.
     * @param {filestore_volumeUpsertArgs} args - Arguments to update or create a Filestore_volume.
     * @example
     * // Update or create a Filestore_volume
     * const filestore_volume = await prisma.filestore_volume.upsert({
     *   create: {
     *     // ... data to create a Filestore_volume
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Filestore_volume we want to update
     *   }
     * })
    **/
    upsert<T extends filestore_volumeUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, filestore_volumeUpsertArgs<ExtArgs>>
    ): Prisma__filestore_volumeClient<$Result.GetResult<Prisma.$filestore_volumePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Filestore_volumes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {filestore_volumeCountArgs} args - Arguments to filter Filestore_volumes to count.
     * @example
     * // Count the number of Filestore_volumes
     * const count = await prisma.filestore_volume.count({
     *   where: {
     *     // ... the filter for the Filestore_volumes we want to count
     *   }
     * })
    **/
    count<T extends filestore_volumeCountArgs>(
      args?: Subset<T, filestore_volumeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Filestore_volumeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Filestore_volume.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Filestore_volumeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Filestore_volumeAggregateArgs>(args: Subset<T, Filestore_volumeAggregateArgs>): Prisma.PrismaPromise<GetFilestore_volumeAggregateType<T>>

    /**
     * Group by Filestore_volume.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {filestore_volumeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends filestore_volumeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: filestore_volumeGroupByArgs['orderBy'] }
        : { orderBy?: filestore_volumeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, filestore_volumeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFilestore_volumeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the filestore_volume model
   */
  readonly fields: filestore_volumeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for filestore_volume.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__filestore_volumeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the filestore_volume model
   */ 
  interface filestore_volumeFieldRefs {
    readonly id: FieldRef<"filestore_volume", 'Int'>
    readonly name: FieldRef<"filestore_volume", 'String'>
    readonly dirname: FieldRef<"filestore_volume", 'String'>
    readonly total_space: FieldRef<"filestore_volume", 'BigInt'>
    readonly used_space: FieldRef<"filestore_volume", 'BigInt'>
    readonly stored_files_cnt: FieldRef<"filestore_volume", 'Int'>
    readonly enabled: FieldRef<"filestore_volume", 'filestore_volume_enabled'>
    readonly last_filenum: FieldRef<"filestore_volume", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * filestore_volume findUnique
   */
  export type filestore_volumeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the filestore_volume
     */
    select?: filestore_volumeSelect<ExtArgs> | null
    /**
     * Filter, which filestore_volume to fetch.
     */
    where: filestore_volumeWhereUniqueInput
  }


  /**
   * filestore_volume findUniqueOrThrow
   */
  export type filestore_volumeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the filestore_volume
     */
    select?: filestore_volumeSelect<ExtArgs> | null
    /**
     * Filter, which filestore_volume to fetch.
     */
    where: filestore_volumeWhereUniqueInput
  }


  /**
   * filestore_volume findFirst
   */
  export type filestore_volumeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the filestore_volume
     */
    select?: filestore_volumeSelect<ExtArgs> | null
    /**
     * Filter, which filestore_volume to fetch.
     */
    where?: filestore_volumeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of filestore_volumes to fetch.
     */
    orderBy?: filestore_volumeOrderByWithRelationInput | filestore_volumeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for filestore_volumes.
     */
    cursor?: filestore_volumeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` filestore_volumes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` filestore_volumes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of filestore_volumes.
     */
    distinct?: Filestore_volumeScalarFieldEnum | Filestore_volumeScalarFieldEnum[]
  }


  /**
   * filestore_volume findFirstOrThrow
   */
  export type filestore_volumeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the filestore_volume
     */
    select?: filestore_volumeSelect<ExtArgs> | null
    /**
     * Filter, which filestore_volume to fetch.
     */
    where?: filestore_volumeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of filestore_volumes to fetch.
     */
    orderBy?: filestore_volumeOrderByWithRelationInput | filestore_volumeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for filestore_volumes.
     */
    cursor?: filestore_volumeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` filestore_volumes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` filestore_volumes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of filestore_volumes.
     */
    distinct?: Filestore_volumeScalarFieldEnum | Filestore_volumeScalarFieldEnum[]
  }


  /**
   * filestore_volume findMany
   */
  export type filestore_volumeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the filestore_volume
     */
    select?: filestore_volumeSelect<ExtArgs> | null
    /**
     * Filter, which filestore_volumes to fetch.
     */
    where?: filestore_volumeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of filestore_volumes to fetch.
     */
    orderBy?: filestore_volumeOrderByWithRelationInput | filestore_volumeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing filestore_volumes.
     */
    cursor?: filestore_volumeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` filestore_volumes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` filestore_volumes.
     */
    skip?: number
    distinct?: Filestore_volumeScalarFieldEnum | Filestore_volumeScalarFieldEnum[]
  }


  /**
   * filestore_volume create
   */
  export type filestore_volumeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the filestore_volume
     */
    select?: filestore_volumeSelect<ExtArgs> | null
    /**
     * The data needed to create a filestore_volume.
     */
    data?: XOR<filestore_volumeCreateInput, filestore_volumeUncheckedCreateInput>
  }


  /**
   * filestore_volume createMany
   */
  export type filestore_volumeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many filestore_volumes.
     */
    data: filestore_volumeCreateManyInput | filestore_volumeCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * filestore_volume update
   */
  export type filestore_volumeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the filestore_volume
     */
    select?: filestore_volumeSelect<ExtArgs> | null
    /**
     * The data needed to update a filestore_volume.
     */
    data: XOR<filestore_volumeUpdateInput, filestore_volumeUncheckedUpdateInput>
    /**
     * Choose, which filestore_volume to update.
     */
    where: filestore_volumeWhereUniqueInput
  }


  /**
   * filestore_volume updateMany
   */
  export type filestore_volumeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update filestore_volumes.
     */
    data: XOR<filestore_volumeUpdateManyMutationInput, filestore_volumeUncheckedUpdateManyInput>
    /**
     * Filter which filestore_volumes to update
     */
    where?: filestore_volumeWhereInput
  }


  /**
   * filestore_volume upsert
   */
  export type filestore_volumeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the filestore_volume
     */
    select?: filestore_volumeSelect<ExtArgs> | null
    /**
     * The filter to search for the filestore_volume to update in case it exists.
     */
    where: filestore_volumeWhereUniqueInput
    /**
     * In case the filestore_volume found by the `where` argument doesn't exist, create a new filestore_volume with this data.
     */
    create: XOR<filestore_volumeCreateInput, filestore_volumeUncheckedCreateInput>
    /**
     * In case the filestore_volume was found with the provided `where` argument, update it with this data.
     */
    update: XOR<filestore_volumeUpdateInput, filestore_volumeUncheckedUpdateInput>
  }


  /**
   * filestore_volume delete
   */
  export type filestore_volumeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the filestore_volume
     */
    select?: filestore_volumeSelect<ExtArgs> | null
    /**
     * Filter which filestore_volume to delete.
     */
    where: filestore_volumeWhereUniqueInput
  }


  /**
   * filestore_volume deleteMany
   */
  export type filestore_volumeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which filestore_volumes to delete
     */
    where?: filestore_volumeWhereInput
  }


  /**
   * filestore_volume without action
   */
  export type filestore_volumeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the filestore_volume
     */
    select?: filestore_volumeSelect<ExtArgs> | null
  }



  /**
   * Model audit_logs
   */

  export type AggregateAudit_logs = {
    _count: Audit_logsCountAggregateOutputType | null
    _avg: Audit_logsAvgAggregateOutputType | null
    _sum: Audit_logsSumAggregateOutputType | null
    _min: Audit_logsMinAggregateOutputType | null
    _max: Audit_logsMaxAggregateOutputType | null
  }

  export type Audit_logsAvgAggregateOutputType = {
    id: number | null
  }

  export type Audit_logsSumAggregateOutputType = {
    id: number | null
  }

  export type Audit_logsMinAggregateOutputType = {
    id: number | null
    timestamp: Date | null
    action: string | null
    entity: string | null
    entity_id: string | null
    details: string | null
    user: string | null
    ip_address: string | null
  }

  export type Audit_logsMaxAggregateOutputType = {
    id: number | null
    timestamp: Date | null
    action: string | null
    entity: string | null
    entity_id: string | null
    details: string | null
    user: string | null
    ip_address: string | null
  }

  export type Audit_logsCountAggregateOutputType = {
    id: number
    timestamp: number
    action: number
    entity: number
    entity_id: number
    details: number
    user: number
    ip_address: number
    _all: number
  }


  export type Audit_logsAvgAggregateInputType = {
    id?: true
  }

  export type Audit_logsSumAggregateInputType = {
    id?: true
  }

  export type Audit_logsMinAggregateInputType = {
    id?: true
    timestamp?: true
    action?: true
    entity?: true
    entity_id?: true
    details?: true
    user?: true
    ip_address?: true
  }

  export type Audit_logsMaxAggregateInputType = {
    id?: true
    timestamp?: true
    action?: true
    entity?: true
    entity_id?: true
    details?: true
    user?: true
    ip_address?: true
  }

  export type Audit_logsCountAggregateInputType = {
    id?: true
    timestamp?: true
    action?: true
    entity?: true
    entity_id?: true
    details?: true
    user?: true
    ip_address?: true
    _all?: true
  }

  export type Audit_logsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which audit_logs to aggregate.
     */
    where?: audit_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of audit_logs to fetch.
     */
    orderBy?: audit_logsOrderByWithRelationInput | audit_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: audit_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` audit_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` audit_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned audit_logs
    **/
    _count?: true | Audit_logsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Audit_logsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Audit_logsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Audit_logsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Audit_logsMaxAggregateInputType
  }

  export type GetAudit_logsAggregateType<T extends Audit_logsAggregateArgs> = {
        [P in keyof T & keyof AggregateAudit_logs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAudit_logs[P]>
      : GetScalarType<T[P], AggregateAudit_logs[P]>
  }




  export type audit_logsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: audit_logsWhereInput
    orderBy?: audit_logsOrderByWithAggregationInput | audit_logsOrderByWithAggregationInput[]
    by: Audit_logsScalarFieldEnum[] | Audit_logsScalarFieldEnum
    having?: audit_logsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Audit_logsCountAggregateInputType | true
    _avg?: Audit_logsAvgAggregateInputType
    _sum?: Audit_logsSumAggregateInputType
    _min?: Audit_logsMinAggregateInputType
    _max?: Audit_logsMaxAggregateInputType
  }

  export type Audit_logsGroupByOutputType = {
    id: number
    timestamp: Date
    action: string
    entity: string
    entity_id: string
    details: string | null
    user: string | null
    ip_address: string | null
    _count: Audit_logsCountAggregateOutputType | null
    _avg: Audit_logsAvgAggregateOutputType | null
    _sum: Audit_logsSumAggregateOutputType | null
    _min: Audit_logsMinAggregateOutputType | null
    _max: Audit_logsMaxAggregateOutputType | null
  }

  type GetAudit_logsGroupByPayload<T extends audit_logsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Audit_logsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Audit_logsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Audit_logsGroupByOutputType[P]>
            : GetScalarType<T[P], Audit_logsGroupByOutputType[P]>
        }
      >
    >


  export type audit_logsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    timestamp?: boolean
    action?: boolean
    entity?: boolean
    entity_id?: boolean
    details?: boolean
    user?: boolean
    ip_address?: boolean
  }, ExtArgs["result"]["audit_logs"]>

  export type audit_logsSelectScalar = {
    id?: boolean
    timestamp?: boolean
    action?: boolean
    entity?: boolean
    entity_id?: boolean
    details?: boolean
    user?: boolean
    ip_address?: boolean
  }


  export type $audit_logsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "audit_logs"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      timestamp: Date
      action: string
      entity: string
      entity_id: string
      details: string | null
      user: string | null
      ip_address: string | null
    }, ExtArgs["result"]["audit_logs"]>
    composites: {}
  }


  type audit_logsGetPayload<S extends boolean | null | undefined | audit_logsDefaultArgs> = $Result.GetResult<Prisma.$audit_logsPayload, S>

  type audit_logsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<audit_logsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Audit_logsCountAggregateInputType | true
    }

  export interface audit_logsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['audit_logs'], meta: { name: 'audit_logs' } }
    /**
     * Find zero or one Audit_logs that matches the filter.
     * @param {audit_logsFindUniqueArgs} args - Arguments to find a Audit_logs
     * @example
     * // Get one Audit_logs
     * const audit_logs = await prisma.audit_logs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends audit_logsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, audit_logsFindUniqueArgs<ExtArgs>>
    ): Prisma__audit_logsClient<$Result.GetResult<Prisma.$audit_logsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Audit_logs that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {audit_logsFindUniqueOrThrowArgs} args - Arguments to find a Audit_logs
     * @example
     * // Get one Audit_logs
     * const audit_logs = await prisma.audit_logs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends audit_logsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, audit_logsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__audit_logsClient<$Result.GetResult<Prisma.$audit_logsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Audit_logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {audit_logsFindFirstArgs} args - Arguments to find a Audit_logs
     * @example
     * // Get one Audit_logs
     * const audit_logs = await prisma.audit_logs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends audit_logsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, audit_logsFindFirstArgs<ExtArgs>>
    ): Prisma__audit_logsClient<$Result.GetResult<Prisma.$audit_logsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Audit_logs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {audit_logsFindFirstOrThrowArgs} args - Arguments to find a Audit_logs
     * @example
     * // Get one Audit_logs
     * const audit_logs = await prisma.audit_logs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends audit_logsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, audit_logsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__audit_logsClient<$Result.GetResult<Prisma.$audit_logsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Audit_logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {audit_logsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Audit_logs
     * const audit_logs = await prisma.audit_logs.findMany()
     * 
     * // Get first 10 Audit_logs
     * const audit_logs = await prisma.audit_logs.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const audit_logsWithIdOnly = await prisma.audit_logs.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends audit_logsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, audit_logsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$audit_logsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Audit_logs.
     * @param {audit_logsCreateArgs} args - Arguments to create a Audit_logs.
     * @example
     * // Create one Audit_logs
     * const Audit_logs = await prisma.audit_logs.create({
     *   data: {
     *     // ... data to create a Audit_logs
     *   }
     * })
     * 
    **/
    create<T extends audit_logsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, audit_logsCreateArgs<ExtArgs>>
    ): Prisma__audit_logsClient<$Result.GetResult<Prisma.$audit_logsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Audit_logs.
     *     @param {audit_logsCreateManyArgs} args - Arguments to create many Audit_logs.
     *     @example
     *     // Create many Audit_logs
     *     const audit_logs = await prisma.audit_logs.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends audit_logsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, audit_logsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Audit_logs.
     * @param {audit_logsDeleteArgs} args - Arguments to delete one Audit_logs.
     * @example
     * // Delete one Audit_logs
     * const Audit_logs = await prisma.audit_logs.delete({
     *   where: {
     *     // ... filter to delete one Audit_logs
     *   }
     * })
     * 
    **/
    delete<T extends audit_logsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, audit_logsDeleteArgs<ExtArgs>>
    ): Prisma__audit_logsClient<$Result.GetResult<Prisma.$audit_logsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Audit_logs.
     * @param {audit_logsUpdateArgs} args - Arguments to update one Audit_logs.
     * @example
     * // Update one Audit_logs
     * const audit_logs = await prisma.audit_logs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends audit_logsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, audit_logsUpdateArgs<ExtArgs>>
    ): Prisma__audit_logsClient<$Result.GetResult<Prisma.$audit_logsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Audit_logs.
     * @param {audit_logsDeleteManyArgs} args - Arguments to filter Audit_logs to delete.
     * @example
     * // Delete a few Audit_logs
     * const { count } = await prisma.audit_logs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends audit_logsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, audit_logsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Audit_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {audit_logsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Audit_logs
     * const audit_logs = await prisma.audit_logs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends audit_logsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, audit_logsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Audit_logs.
     * @param {audit_logsUpsertArgs} args - Arguments to update or create a Audit_logs.
     * @example
     * // Update or create a Audit_logs
     * const audit_logs = await prisma.audit_logs.upsert({
     *   create: {
     *     // ... data to create a Audit_logs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Audit_logs we want to update
     *   }
     * })
    **/
    upsert<T extends audit_logsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, audit_logsUpsertArgs<ExtArgs>>
    ): Prisma__audit_logsClient<$Result.GetResult<Prisma.$audit_logsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Audit_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {audit_logsCountArgs} args - Arguments to filter Audit_logs to count.
     * @example
     * // Count the number of Audit_logs
     * const count = await prisma.audit_logs.count({
     *   where: {
     *     // ... the filter for the Audit_logs we want to count
     *   }
     * })
    **/
    count<T extends audit_logsCountArgs>(
      args?: Subset<T, audit_logsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Audit_logsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Audit_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Audit_logsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Audit_logsAggregateArgs>(args: Subset<T, Audit_logsAggregateArgs>): Prisma.PrismaPromise<GetAudit_logsAggregateType<T>>

    /**
     * Group by Audit_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {audit_logsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends audit_logsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: audit_logsGroupByArgs['orderBy'] }
        : { orderBy?: audit_logsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, audit_logsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAudit_logsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the audit_logs model
   */
  readonly fields: audit_logsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for audit_logs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__audit_logsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the audit_logs model
   */ 
  interface audit_logsFieldRefs {
    readonly id: FieldRef<"audit_logs", 'Int'>
    readonly timestamp: FieldRef<"audit_logs", 'DateTime'>
    readonly action: FieldRef<"audit_logs", 'String'>
    readonly entity: FieldRef<"audit_logs", 'String'>
    readonly entity_id: FieldRef<"audit_logs", 'String'>
    readonly details: FieldRef<"audit_logs", 'String'>
    readonly user: FieldRef<"audit_logs", 'String'>
    readonly ip_address: FieldRef<"audit_logs", 'String'>
  }
    

  // Custom InputTypes

  /**
   * audit_logs findUnique
   */
  export type audit_logsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the audit_logs
     */
    select?: audit_logsSelect<ExtArgs> | null
    /**
     * Filter, which audit_logs to fetch.
     */
    where: audit_logsWhereUniqueInput
  }


  /**
   * audit_logs findUniqueOrThrow
   */
  export type audit_logsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the audit_logs
     */
    select?: audit_logsSelect<ExtArgs> | null
    /**
     * Filter, which audit_logs to fetch.
     */
    where: audit_logsWhereUniqueInput
  }


  /**
   * audit_logs findFirst
   */
  export type audit_logsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the audit_logs
     */
    select?: audit_logsSelect<ExtArgs> | null
    /**
     * Filter, which audit_logs to fetch.
     */
    where?: audit_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of audit_logs to fetch.
     */
    orderBy?: audit_logsOrderByWithRelationInput | audit_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for audit_logs.
     */
    cursor?: audit_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` audit_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` audit_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of audit_logs.
     */
    distinct?: Audit_logsScalarFieldEnum | Audit_logsScalarFieldEnum[]
  }


  /**
   * audit_logs findFirstOrThrow
   */
  export type audit_logsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the audit_logs
     */
    select?: audit_logsSelect<ExtArgs> | null
    /**
     * Filter, which audit_logs to fetch.
     */
    where?: audit_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of audit_logs to fetch.
     */
    orderBy?: audit_logsOrderByWithRelationInput | audit_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for audit_logs.
     */
    cursor?: audit_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` audit_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` audit_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of audit_logs.
     */
    distinct?: Audit_logsScalarFieldEnum | Audit_logsScalarFieldEnum[]
  }


  /**
   * audit_logs findMany
   */
  export type audit_logsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the audit_logs
     */
    select?: audit_logsSelect<ExtArgs> | null
    /**
     * Filter, which audit_logs to fetch.
     */
    where?: audit_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of audit_logs to fetch.
     */
    orderBy?: audit_logsOrderByWithRelationInput | audit_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing audit_logs.
     */
    cursor?: audit_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` audit_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` audit_logs.
     */
    skip?: number
    distinct?: Audit_logsScalarFieldEnum | Audit_logsScalarFieldEnum[]
  }


  /**
   * audit_logs create
   */
  export type audit_logsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the audit_logs
     */
    select?: audit_logsSelect<ExtArgs> | null
    /**
     * The data needed to create a audit_logs.
     */
    data: XOR<audit_logsCreateInput, audit_logsUncheckedCreateInput>
  }


  /**
   * audit_logs createMany
   */
  export type audit_logsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many audit_logs.
     */
    data: audit_logsCreateManyInput | audit_logsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * audit_logs update
   */
  export type audit_logsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the audit_logs
     */
    select?: audit_logsSelect<ExtArgs> | null
    /**
     * The data needed to update a audit_logs.
     */
    data: XOR<audit_logsUpdateInput, audit_logsUncheckedUpdateInput>
    /**
     * Choose, which audit_logs to update.
     */
    where: audit_logsWhereUniqueInput
  }


  /**
   * audit_logs updateMany
   */
  export type audit_logsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update audit_logs.
     */
    data: XOR<audit_logsUpdateManyMutationInput, audit_logsUncheckedUpdateManyInput>
    /**
     * Filter which audit_logs to update
     */
    where?: audit_logsWhereInput
  }


  /**
   * audit_logs upsert
   */
  export type audit_logsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the audit_logs
     */
    select?: audit_logsSelect<ExtArgs> | null
    /**
     * The filter to search for the audit_logs to update in case it exists.
     */
    where: audit_logsWhereUniqueInput
    /**
     * In case the audit_logs found by the `where` argument doesn't exist, create a new audit_logs with this data.
     */
    create: XOR<audit_logsCreateInput, audit_logsUncheckedCreateInput>
    /**
     * In case the audit_logs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<audit_logsUpdateInput, audit_logsUncheckedUpdateInput>
  }


  /**
   * audit_logs delete
   */
  export type audit_logsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the audit_logs
     */
    select?: audit_logsSelect<ExtArgs> | null
    /**
     * Filter which audit_logs to delete.
     */
    where: audit_logsWhereUniqueInput
  }


  /**
   * audit_logs deleteMany
   */
  export type audit_logsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which audit_logs to delete
     */
    where?: audit_logsWhereInput
  }


  /**
   * audit_logs without action
   */
  export type audit_logsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the audit_logs
     */
    select?: audit_logsSelect<ExtArgs> | null
  }



  /**
   * Model logs_edit
   */

  export type AggregateLogs_edit = {
    _count: Logs_editCountAggregateOutputType | null
    _avg: Logs_editAvgAggregateOutputType | null
    _sum: Logs_editSumAggregateOutputType | null
    _min: Logs_editMinAggregateOutputType | null
    _max: Logs_editMaxAggregateOutputType | null
  }

  export type Logs_editAvgAggregateOutputType = {
    id: number | null
  }

  export type Logs_editSumAggregateOutputType = {
    id: number | null
  }

  export type Logs_editMinAggregateOutputType = {
    id: number | null
    timestamp: Date | null
    desc: string | null
    code: string | null
    line: string | null
    user: string | null
  }

  export type Logs_editMaxAggregateOutputType = {
    id: number | null
    timestamp: Date | null
    desc: string | null
    code: string | null
    line: string | null
    user: string | null
  }

  export type Logs_editCountAggregateOutputType = {
    id: number
    timestamp: number
    desc: number
    code: number
    line: number
    user: number
    _all: number
  }


  export type Logs_editAvgAggregateInputType = {
    id?: true
  }

  export type Logs_editSumAggregateInputType = {
    id?: true
  }

  export type Logs_editMinAggregateInputType = {
    id?: true
    timestamp?: true
    desc?: true
    code?: true
    line?: true
    user?: true
  }

  export type Logs_editMaxAggregateInputType = {
    id?: true
    timestamp?: true
    desc?: true
    code?: true
    line?: true
    user?: true
  }

  export type Logs_editCountAggregateInputType = {
    id?: true
    timestamp?: true
    desc?: true
    code?: true
    line?: true
    user?: true
    _all?: true
  }

  export type Logs_editAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which logs_edit to aggregate.
     */
    where?: logs_editWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of logs_edits to fetch.
     */
    orderBy?: logs_editOrderByWithRelationInput | logs_editOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: logs_editWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` logs_edits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` logs_edits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned logs_edits
    **/
    _count?: true | Logs_editCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Logs_editAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Logs_editSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Logs_editMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Logs_editMaxAggregateInputType
  }

  export type GetLogs_editAggregateType<T extends Logs_editAggregateArgs> = {
        [P in keyof T & keyof AggregateLogs_edit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLogs_edit[P]>
      : GetScalarType<T[P], AggregateLogs_edit[P]>
  }




  export type logs_editGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: logs_editWhereInput
    orderBy?: logs_editOrderByWithAggregationInput | logs_editOrderByWithAggregationInput[]
    by: Logs_editScalarFieldEnum[] | Logs_editScalarFieldEnum
    having?: logs_editScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Logs_editCountAggregateInputType | true
    _avg?: Logs_editAvgAggregateInputType
    _sum?: Logs_editSumAggregateInputType
    _min?: Logs_editMinAggregateInputType
    _max?: Logs_editMaxAggregateInputType
  }

  export type Logs_editGroupByOutputType = {
    id: number
    timestamp: Date
    desc: string
    code: string
    line: string
    user: string
    _count: Logs_editCountAggregateOutputType | null
    _avg: Logs_editAvgAggregateOutputType | null
    _sum: Logs_editSumAggregateOutputType | null
    _min: Logs_editMinAggregateOutputType | null
    _max: Logs_editMaxAggregateOutputType | null
  }

  type GetLogs_editGroupByPayload<T extends logs_editGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Logs_editGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Logs_editGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Logs_editGroupByOutputType[P]>
            : GetScalarType<T[P], Logs_editGroupByOutputType[P]>
        }
      >
    >


  export type logs_editSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    timestamp?: boolean
    desc?: boolean
    code?: boolean
    line?: boolean
    user?: boolean
  }, ExtArgs["result"]["logs_edit"]>

  export type logs_editSelectScalar = {
    id?: boolean
    timestamp?: boolean
    desc?: boolean
    code?: boolean
    line?: boolean
    user?: boolean
  }


  export type $logs_editPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "logs_edit"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      timestamp: Date
      desc: string
      code: string
      line: string
      user: string
    }, ExtArgs["result"]["logs_edit"]>
    composites: {}
  }


  type logs_editGetPayload<S extends boolean | null | undefined | logs_editDefaultArgs> = $Result.GetResult<Prisma.$logs_editPayload, S>

  type logs_editCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<logs_editFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Logs_editCountAggregateInputType | true
    }

  export interface logs_editDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['logs_edit'], meta: { name: 'logs_edit' } }
    /**
     * Find zero or one Logs_edit that matches the filter.
     * @param {logs_editFindUniqueArgs} args - Arguments to find a Logs_edit
     * @example
     * // Get one Logs_edit
     * const logs_edit = await prisma.logs_edit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends logs_editFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, logs_editFindUniqueArgs<ExtArgs>>
    ): Prisma__logs_editClient<$Result.GetResult<Prisma.$logs_editPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Logs_edit that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {logs_editFindUniqueOrThrowArgs} args - Arguments to find a Logs_edit
     * @example
     * // Get one Logs_edit
     * const logs_edit = await prisma.logs_edit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends logs_editFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, logs_editFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__logs_editClient<$Result.GetResult<Prisma.$logs_editPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Logs_edit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {logs_editFindFirstArgs} args - Arguments to find a Logs_edit
     * @example
     * // Get one Logs_edit
     * const logs_edit = await prisma.logs_edit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends logs_editFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, logs_editFindFirstArgs<ExtArgs>>
    ): Prisma__logs_editClient<$Result.GetResult<Prisma.$logs_editPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Logs_edit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {logs_editFindFirstOrThrowArgs} args - Arguments to find a Logs_edit
     * @example
     * // Get one Logs_edit
     * const logs_edit = await prisma.logs_edit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends logs_editFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, logs_editFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__logs_editClient<$Result.GetResult<Prisma.$logs_editPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Logs_edits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {logs_editFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Logs_edits
     * const logs_edits = await prisma.logs_edit.findMany()
     * 
     * // Get first 10 Logs_edits
     * const logs_edits = await prisma.logs_edit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const logs_editWithIdOnly = await prisma.logs_edit.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends logs_editFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, logs_editFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$logs_editPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Logs_edit.
     * @param {logs_editCreateArgs} args - Arguments to create a Logs_edit.
     * @example
     * // Create one Logs_edit
     * const Logs_edit = await prisma.logs_edit.create({
     *   data: {
     *     // ... data to create a Logs_edit
     *   }
     * })
     * 
    **/
    create<T extends logs_editCreateArgs<ExtArgs>>(
      args: SelectSubset<T, logs_editCreateArgs<ExtArgs>>
    ): Prisma__logs_editClient<$Result.GetResult<Prisma.$logs_editPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Logs_edits.
     *     @param {logs_editCreateManyArgs} args - Arguments to create many Logs_edits.
     *     @example
     *     // Create many Logs_edits
     *     const logs_edit = await prisma.logs_edit.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends logs_editCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, logs_editCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Logs_edit.
     * @param {logs_editDeleteArgs} args - Arguments to delete one Logs_edit.
     * @example
     * // Delete one Logs_edit
     * const Logs_edit = await prisma.logs_edit.delete({
     *   where: {
     *     // ... filter to delete one Logs_edit
     *   }
     * })
     * 
    **/
    delete<T extends logs_editDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, logs_editDeleteArgs<ExtArgs>>
    ): Prisma__logs_editClient<$Result.GetResult<Prisma.$logs_editPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Logs_edit.
     * @param {logs_editUpdateArgs} args - Arguments to update one Logs_edit.
     * @example
     * // Update one Logs_edit
     * const logs_edit = await prisma.logs_edit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends logs_editUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, logs_editUpdateArgs<ExtArgs>>
    ): Prisma__logs_editClient<$Result.GetResult<Prisma.$logs_editPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Logs_edits.
     * @param {logs_editDeleteManyArgs} args - Arguments to filter Logs_edits to delete.
     * @example
     * // Delete a few Logs_edits
     * const { count } = await prisma.logs_edit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends logs_editDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, logs_editDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Logs_edits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {logs_editUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Logs_edits
     * const logs_edit = await prisma.logs_edit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends logs_editUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, logs_editUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Logs_edit.
     * @param {logs_editUpsertArgs} args - Arguments to update or create a Logs_edit.
     * @example
     * // Update or create a Logs_edit
     * const logs_edit = await prisma.logs_edit.upsert({
     *   create: {
     *     // ... data to create a Logs_edit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Logs_edit we want to update
     *   }
     * })
    **/
    upsert<T extends logs_editUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, logs_editUpsertArgs<ExtArgs>>
    ): Prisma__logs_editClient<$Result.GetResult<Prisma.$logs_editPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Logs_edits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {logs_editCountArgs} args - Arguments to filter Logs_edits to count.
     * @example
     * // Count the number of Logs_edits
     * const count = await prisma.logs_edit.count({
     *   where: {
     *     // ... the filter for the Logs_edits we want to count
     *   }
     * })
    **/
    count<T extends logs_editCountArgs>(
      args?: Subset<T, logs_editCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Logs_editCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Logs_edit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Logs_editAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Logs_editAggregateArgs>(args: Subset<T, Logs_editAggregateArgs>): Prisma.PrismaPromise<GetLogs_editAggregateType<T>>

    /**
     * Group by Logs_edit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {logs_editGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends logs_editGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: logs_editGroupByArgs['orderBy'] }
        : { orderBy?: logs_editGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, logs_editGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLogs_editGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the logs_edit model
   */
  readonly fields: logs_editFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for logs_edit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__logs_editClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the logs_edit model
   */ 
  interface logs_editFieldRefs {
    readonly id: FieldRef<"logs_edit", 'Int'>
    readonly timestamp: FieldRef<"logs_edit", 'DateTime'>
    readonly desc: FieldRef<"logs_edit", 'String'>
    readonly code: FieldRef<"logs_edit", 'String'>
    readonly line: FieldRef<"logs_edit", 'String'>
    readonly user: FieldRef<"logs_edit", 'String'>
  }
    

  // Custom InputTypes

  /**
   * logs_edit findUnique
   */
  export type logs_editFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the logs_edit
     */
    select?: logs_editSelect<ExtArgs> | null
    /**
     * Filter, which logs_edit to fetch.
     */
    where: logs_editWhereUniqueInput
  }


  /**
   * logs_edit findUniqueOrThrow
   */
  export type logs_editFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the logs_edit
     */
    select?: logs_editSelect<ExtArgs> | null
    /**
     * Filter, which logs_edit to fetch.
     */
    where: logs_editWhereUniqueInput
  }


  /**
   * logs_edit findFirst
   */
  export type logs_editFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the logs_edit
     */
    select?: logs_editSelect<ExtArgs> | null
    /**
     * Filter, which logs_edit to fetch.
     */
    where?: logs_editWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of logs_edits to fetch.
     */
    orderBy?: logs_editOrderByWithRelationInput | logs_editOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for logs_edits.
     */
    cursor?: logs_editWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` logs_edits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` logs_edits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of logs_edits.
     */
    distinct?: Logs_editScalarFieldEnum | Logs_editScalarFieldEnum[]
  }


  /**
   * logs_edit findFirstOrThrow
   */
  export type logs_editFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the logs_edit
     */
    select?: logs_editSelect<ExtArgs> | null
    /**
     * Filter, which logs_edit to fetch.
     */
    where?: logs_editWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of logs_edits to fetch.
     */
    orderBy?: logs_editOrderByWithRelationInput | logs_editOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for logs_edits.
     */
    cursor?: logs_editWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` logs_edits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` logs_edits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of logs_edits.
     */
    distinct?: Logs_editScalarFieldEnum | Logs_editScalarFieldEnum[]
  }


  /**
   * logs_edit findMany
   */
  export type logs_editFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the logs_edit
     */
    select?: logs_editSelect<ExtArgs> | null
    /**
     * Filter, which logs_edits to fetch.
     */
    where?: logs_editWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of logs_edits to fetch.
     */
    orderBy?: logs_editOrderByWithRelationInput | logs_editOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing logs_edits.
     */
    cursor?: logs_editWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` logs_edits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` logs_edits.
     */
    skip?: number
    distinct?: Logs_editScalarFieldEnum | Logs_editScalarFieldEnum[]
  }


  /**
   * logs_edit create
   */
  export type logs_editCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the logs_edit
     */
    select?: logs_editSelect<ExtArgs> | null
    /**
     * The data needed to create a logs_edit.
     */
    data: XOR<logs_editCreateInput, logs_editUncheckedCreateInput>
  }


  /**
   * logs_edit createMany
   */
  export type logs_editCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many logs_edits.
     */
    data: logs_editCreateManyInput | logs_editCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * logs_edit update
   */
  export type logs_editUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the logs_edit
     */
    select?: logs_editSelect<ExtArgs> | null
    /**
     * The data needed to update a logs_edit.
     */
    data: XOR<logs_editUpdateInput, logs_editUncheckedUpdateInput>
    /**
     * Choose, which logs_edit to update.
     */
    where: logs_editWhereUniqueInput
  }


  /**
   * logs_edit updateMany
   */
  export type logs_editUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update logs_edits.
     */
    data: XOR<logs_editUpdateManyMutationInput, logs_editUncheckedUpdateManyInput>
    /**
     * Filter which logs_edits to update
     */
    where?: logs_editWhereInput
  }


  /**
   * logs_edit upsert
   */
  export type logs_editUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the logs_edit
     */
    select?: logs_editSelect<ExtArgs> | null
    /**
     * The filter to search for the logs_edit to update in case it exists.
     */
    where: logs_editWhereUniqueInput
    /**
     * In case the logs_edit found by the `where` argument doesn't exist, create a new logs_edit with this data.
     */
    create: XOR<logs_editCreateInput, logs_editUncheckedCreateInput>
    /**
     * In case the logs_edit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<logs_editUpdateInput, logs_editUncheckedUpdateInput>
  }


  /**
   * logs_edit delete
   */
  export type logs_editDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the logs_edit
     */
    select?: logs_editSelect<ExtArgs> | null
    /**
     * Filter which logs_edit to delete.
     */
    where: logs_editWhereUniqueInput
  }


  /**
   * logs_edit deleteMany
   */
  export type logs_editDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which logs_edits to delete
     */
    where?: logs_editWhereInput
  }


  /**
   * logs_edit without action
   */
  export type logs_editDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the logs_edit
     */
    select?: logs_editSelect<ExtArgs> | null
  }



  /**
   * Model meter_type
   */

  export type AggregateMeter_type = {
    _count: Meter_typeCountAggregateOutputType | null
    _avg: Meter_typeAvgAggregateOutputType | null
    _sum: Meter_typeSumAggregateOutputType | null
    _min: Meter_typeMinAggregateOutputType | null
    _max: Meter_typeMaxAggregateOutputType | null
  }

  export type Meter_typeAvgAggregateOutputType = {
    id: number | null
    validation_length: number | null
    length: number | null
  }

  export type Meter_typeSumAggregateOutputType = {
    id: number | null
    validation_length: number | null
    length: number | null
  }

  export type Meter_typeMinAggregateOutputType = {
    id: number | null
    value: string | null
    phase: string | null
    validation: string | null
    validation_length: number | null
    length: number | null
    pln_code: string | null
    card_validation: $Enums.meter_type_card_validation | null
    validation_type: $Enums.meter_type_validation_type | null
    daily_reset: $Enums.meter_type_daily_reset | null
    numeric_only: $Enums.meter_type_numeric_only | null
    surpass_target: $Enums.meter_type_surpass_target | null
    run_by_sequence: $Enums.meter_type_run_by_sequence | null
    start_reset: string | null
    end_reset: string | null
  }

  export type Meter_typeMaxAggregateOutputType = {
    id: number | null
    value: string | null
    phase: string | null
    validation: string | null
    validation_length: number | null
    length: number | null
    pln_code: string | null
    card_validation: $Enums.meter_type_card_validation | null
    validation_type: $Enums.meter_type_validation_type | null
    daily_reset: $Enums.meter_type_daily_reset | null
    numeric_only: $Enums.meter_type_numeric_only | null
    surpass_target: $Enums.meter_type_surpass_target | null
    run_by_sequence: $Enums.meter_type_run_by_sequence | null
    start_reset: string | null
    end_reset: string | null
  }

  export type Meter_typeCountAggregateOutputType = {
    id: number
    value: number
    phase: number
    validation: number
    validation_length: number
    length: number
    pln_code: number
    card_validation: number
    validation_type: number
    daily_reset: number
    numeric_only: number
    surpass_target: number
    run_by_sequence: number
    start_reset: number
    end_reset: number
    _all: number
  }


  export type Meter_typeAvgAggregateInputType = {
    id?: true
    validation_length?: true
    length?: true
  }

  export type Meter_typeSumAggregateInputType = {
    id?: true
    validation_length?: true
    length?: true
  }

  export type Meter_typeMinAggregateInputType = {
    id?: true
    value?: true
    phase?: true
    validation?: true
    validation_length?: true
    length?: true
    pln_code?: true
    card_validation?: true
    validation_type?: true
    daily_reset?: true
    numeric_only?: true
    surpass_target?: true
    run_by_sequence?: true
    start_reset?: true
    end_reset?: true
  }

  export type Meter_typeMaxAggregateInputType = {
    id?: true
    value?: true
    phase?: true
    validation?: true
    validation_length?: true
    length?: true
    pln_code?: true
    card_validation?: true
    validation_type?: true
    daily_reset?: true
    numeric_only?: true
    surpass_target?: true
    run_by_sequence?: true
    start_reset?: true
    end_reset?: true
  }

  export type Meter_typeCountAggregateInputType = {
    id?: true
    value?: true
    phase?: true
    validation?: true
    validation_length?: true
    length?: true
    pln_code?: true
    card_validation?: true
    validation_type?: true
    daily_reset?: true
    numeric_only?: true
    surpass_target?: true
    run_by_sequence?: true
    start_reset?: true
    end_reset?: true
    _all?: true
  }

  export type Meter_typeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which meter_type to aggregate.
     */
    where?: meter_typeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of meter_types to fetch.
     */
    orderBy?: meter_typeOrderByWithRelationInput | meter_typeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: meter_typeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` meter_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` meter_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned meter_types
    **/
    _count?: true | Meter_typeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Meter_typeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Meter_typeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Meter_typeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Meter_typeMaxAggregateInputType
  }

  export type GetMeter_typeAggregateType<T extends Meter_typeAggregateArgs> = {
        [P in keyof T & keyof AggregateMeter_type]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMeter_type[P]>
      : GetScalarType<T[P], AggregateMeter_type[P]>
  }




  export type meter_typeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: meter_typeWhereInput
    orderBy?: meter_typeOrderByWithAggregationInput | meter_typeOrderByWithAggregationInput[]
    by: Meter_typeScalarFieldEnum[] | Meter_typeScalarFieldEnum
    having?: meter_typeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Meter_typeCountAggregateInputType | true
    _avg?: Meter_typeAvgAggregateInputType
    _sum?: Meter_typeSumAggregateInputType
    _min?: Meter_typeMinAggregateInputType
    _max?: Meter_typeMaxAggregateInputType
  }

  export type Meter_typeGroupByOutputType = {
    id: number
    value: string
    phase: string
    validation: string
    validation_length: number
    length: number
    pln_code: string
    card_validation: $Enums.meter_type_card_validation
    validation_type: $Enums.meter_type_validation_type | null
    daily_reset: $Enums.meter_type_daily_reset
    numeric_only: $Enums.meter_type_numeric_only
    surpass_target: $Enums.meter_type_surpass_target
    run_by_sequence: $Enums.meter_type_run_by_sequence
    start_reset: string
    end_reset: string
    _count: Meter_typeCountAggregateOutputType | null
    _avg: Meter_typeAvgAggregateOutputType | null
    _sum: Meter_typeSumAggregateOutputType | null
    _min: Meter_typeMinAggregateOutputType | null
    _max: Meter_typeMaxAggregateOutputType | null
  }

  type GetMeter_typeGroupByPayload<T extends meter_typeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Meter_typeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Meter_typeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Meter_typeGroupByOutputType[P]>
            : GetScalarType<T[P], Meter_typeGroupByOutputType[P]>
        }
      >
    >


  export type meter_typeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
    phase?: boolean
    validation?: boolean
    validation_length?: boolean
    length?: boolean
    pln_code?: boolean
    card_validation?: boolean
    validation_type?: boolean
    daily_reset?: boolean
    numeric_only?: boolean
    surpass_target?: boolean
    run_by_sequence?: boolean
    start_reset?: boolean
    end_reset?: boolean
  }, ExtArgs["result"]["meter_type"]>

  export type meter_typeSelectScalar = {
    id?: boolean
    value?: boolean
    phase?: boolean
    validation?: boolean
    validation_length?: boolean
    length?: boolean
    pln_code?: boolean
    card_validation?: boolean
    validation_type?: boolean
    daily_reset?: boolean
    numeric_only?: boolean
    surpass_target?: boolean
    run_by_sequence?: boolean
    start_reset?: boolean
    end_reset?: boolean
  }


  export type $meter_typePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "meter_type"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      value: string
      phase: string
      validation: string
      validation_length: number
      length: number
      pln_code: string
      card_validation: $Enums.meter_type_card_validation
      validation_type: $Enums.meter_type_validation_type | null
      daily_reset: $Enums.meter_type_daily_reset
      numeric_only: $Enums.meter_type_numeric_only
      surpass_target: $Enums.meter_type_surpass_target
      run_by_sequence: $Enums.meter_type_run_by_sequence
      start_reset: string
      end_reset: string
    }, ExtArgs["result"]["meter_type"]>
    composites: {}
  }


  type meter_typeGetPayload<S extends boolean | null | undefined | meter_typeDefaultArgs> = $Result.GetResult<Prisma.$meter_typePayload, S>

  type meter_typeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<meter_typeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Meter_typeCountAggregateInputType | true
    }

  export interface meter_typeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['meter_type'], meta: { name: 'meter_type' } }
    /**
     * Find zero or one Meter_type that matches the filter.
     * @param {meter_typeFindUniqueArgs} args - Arguments to find a Meter_type
     * @example
     * // Get one Meter_type
     * const meter_type = await prisma.meter_type.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends meter_typeFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, meter_typeFindUniqueArgs<ExtArgs>>
    ): Prisma__meter_typeClient<$Result.GetResult<Prisma.$meter_typePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Meter_type that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {meter_typeFindUniqueOrThrowArgs} args - Arguments to find a Meter_type
     * @example
     * // Get one Meter_type
     * const meter_type = await prisma.meter_type.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends meter_typeFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, meter_typeFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__meter_typeClient<$Result.GetResult<Prisma.$meter_typePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Meter_type that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {meter_typeFindFirstArgs} args - Arguments to find a Meter_type
     * @example
     * // Get one Meter_type
     * const meter_type = await prisma.meter_type.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends meter_typeFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, meter_typeFindFirstArgs<ExtArgs>>
    ): Prisma__meter_typeClient<$Result.GetResult<Prisma.$meter_typePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Meter_type that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {meter_typeFindFirstOrThrowArgs} args - Arguments to find a Meter_type
     * @example
     * // Get one Meter_type
     * const meter_type = await prisma.meter_type.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends meter_typeFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, meter_typeFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__meter_typeClient<$Result.GetResult<Prisma.$meter_typePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Meter_types that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {meter_typeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Meter_types
     * const meter_types = await prisma.meter_type.findMany()
     * 
     * // Get first 10 Meter_types
     * const meter_types = await prisma.meter_type.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const meter_typeWithIdOnly = await prisma.meter_type.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends meter_typeFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, meter_typeFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$meter_typePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Meter_type.
     * @param {meter_typeCreateArgs} args - Arguments to create a Meter_type.
     * @example
     * // Create one Meter_type
     * const Meter_type = await prisma.meter_type.create({
     *   data: {
     *     // ... data to create a Meter_type
     *   }
     * })
     * 
    **/
    create<T extends meter_typeCreateArgs<ExtArgs>>(
      args: SelectSubset<T, meter_typeCreateArgs<ExtArgs>>
    ): Prisma__meter_typeClient<$Result.GetResult<Prisma.$meter_typePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Meter_types.
     *     @param {meter_typeCreateManyArgs} args - Arguments to create many Meter_types.
     *     @example
     *     // Create many Meter_types
     *     const meter_type = await prisma.meter_type.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends meter_typeCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, meter_typeCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Meter_type.
     * @param {meter_typeDeleteArgs} args - Arguments to delete one Meter_type.
     * @example
     * // Delete one Meter_type
     * const Meter_type = await prisma.meter_type.delete({
     *   where: {
     *     // ... filter to delete one Meter_type
     *   }
     * })
     * 
    **/
    delete<T extends meter_typeDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, meter_typeDeleteArgs<ExtArgs>>
    ): Prisma__meter_typeClient<$Result.GetResult<Prisma.$meter_typePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Meter_type.
     * @param {meter_typeUpdateArgs} args - Arguments to update one Meter_type.
     * @example
     * // Update one Meter_type
     * const meter_type = await prisma.meter_type.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends meter_typeUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, meter_typeUpdateArgs<ExtArgs>>
    ): Prisma__meter_typeClient<$Result.GetResult<Prisma.$meter_typePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Meter_types.
     * @param {meter_typeDeleteManyArgs} args - Arguments to filter Meter_types to delete.
     * @example
     * // Delete a few Meter_types
     * const { count } = await prisma.meter_type.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends meter_typeDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, meter_typeDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Meter_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {meter_typeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Meter_types
     * const meter_type = await prisma.meter_type.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends meter_typeUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, meter_typeUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Meter_type.
     * @param {meter_typeUpsertArgs} args - Arguments to update or create a Meter_type.
     * @example
     * // Update or create a Meter_type
     * const meter_type = await prisma.meter_type.upsert({
     *   create: {
     *     // ... data to create a Meter_type
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Meter_type we want to update
     *   }
     * })
    **/
    upsert<T extends meter_typeUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, meter_typeUpsertArgs<ExtArgs>>
    ): Prisma__meter_typeClient<$Result.GetResult<Prisma.$meter_typePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Meter_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {meter_typeCountArgs} args - Arguments to filter Meter_types to count.
     * @example
     * // Count the number of Meter_types
     * const count = await prisma.meter_type.count({
     *   where: {
     *     // ... the filter for the Meter_types we want to count
     *   }
     * })
    **/
    count<T extends meter_typeCountArgs>(
      args?: Subset<T, meter_typeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Meter_typeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Meter_type.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Meter_typeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Meter_typeAggregateArgs>(args: Subset<T, Meter_typeAggregateArgs>): Prisma.PrismaPromise<GetMeter_typeAggregateType<T>>

    /**
     * Group by Meter_type.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {meter_typeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends meter_typeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: meter_typeGroupByArgs['orderBy'] }
        : { orderBy?: meter_typeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, meter_typeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMeter_typeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the meter_type model
   */
  readonly fields: meter_typeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for meter_type.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__meter_typeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the meter_type model
   */ 
  interface meter_typeFieldRefs {
    readonly id: FieldRef<"meter_type", 'Int'>
    readonly value: FieldRef<"meter_type", 'String'>
    readonly phase: FieldRef<"meter_type", 'String'>
    readonly validation: FieldRef<"meter_type", 'String'>
    readonly validation_length: FieldRef<"meter_type", 'Int'>
    readonly length: FieldRef<"meter_type", 'Int'>
    readonly pln_code: FieldRef<"meter_type", 'String'>
    readonly card_validation: FieldRef<"meter_type", 'meter_type_card_validation'>
    readonly validation_type: FieldRef<"meter_type", 'meter_type_validation_type'>
    readonly daily_reset: FieldRef<"meter_type", 'meter_type_daily_reset'>
    readonly numeric_only: FieldRef<"meter_type", 'meter_type_numeric_only'>
    readonly surpass_target: FieldRef<"meter_type", 'meter_type_surpass_target'>
    readonly run_by_sequence: FieldRef<"meter_type", 'meter_type_run_by_sequence'>
    readonly start_reset: FieldRef<"meter_type", 'String'>
    readonly end_reset: FieldRef<"meter_type", 'String'>
  }
    

  // Custom InputTypes

  /**
   * meter_type findUnique
   */
  export type meter_typeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meter_type
     */
    select?: meter_typeSelect<ExtArgs> | null
    /**
     * Filter, which meter_type to fetch.
     */
    where: meter_typeWhereUniqueInput
  }


  /**
   * meter_type findUniqueOrThrow
   */
  export type meter_typeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meter_type
     */
    select?: meter_typeSelect<ExtArgs> | null
    /**
     * Filter, which meter_type to fetch.
     */
    where: meter_typeWhereUniqueInput
  }


  /**
   * meter_type findFirst
   */
  export type meter_typeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meter_type
     */
    select?: meter_typeSelect<ExtArgs> | null
    /**
     * Filter, which meter_type to fetch.
     */
    where?: meter_typeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of meter_types to fetch.
     */
    orderBy?: meter_typeOrderByWithRelationInput | meter_typeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for meter_types.
     */
    cursor?: meter_typeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` meter_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` meter_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of meter_types.
     */
    distinct?: Meter_typeScalarFieldEnum | Meter_typeScalarFieldEnum[]
  }


  /**
   * meter_type findFirstOrThrow
   */
  export type meter_typeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meter_type
     */
    select?: meter_typeSelect<ExtArgs> | null
    /**
     * Filter, which meter_type to fetch.
     */
    where?: meter_typeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of meter_types to fetch.
     */
    orderBy?: meter_typeOrderByWithRelationInput | meter_typeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for meter_types.
     */
    cursor?: meter_typeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` meter_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` meter_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of meter_types.
     */
    distinct?: Meter_typeScalarFieldEnum | Meter_typeScalarFieldEnum[]
  }


  /**
   * meter_type findMany
   */
  export type meter_typeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meter_type
     */
    select?: meter_typeSelect<ExtArgs> | null
    /**
     * Filter, which meter_types to fetch.
     */
    where?: meter_typeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of meter_types to fetch.
     */
    orderBy?: meter_typeOrderByWithRelationInput | meter_typeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing meter_types.
     */
    cursor?: meter_typeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` meter_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` meter_types.
     */
    skip?: number
    distinct?: Meter_typeScalarFieldEnum | Meter_typeScalarFieldEnum[]
  }


  /**
   * meter_type create
   */
  export type meter_typeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meter_type
     */
    select?: meter_typeSelect<ExtArgs> | null
    /**
     * The data needed to create a meter_type.
     */
    data: XOR<meter_typeCreateInput, meter_typeUncheckedCreateInput>
  }


  /**
   * meter_type createMany
   */
  export type meter_typeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many meter_types.
     */
    data: meter_typeCreateManyInput | meter_typeCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * meter_type update
   */
  export type meter_typeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meter_type
     */
    select?: meter_typeSelect<ExtArgs> | null
    /**
     * The data needed to update a meter_type.
     */
    data: XOR<meter_typeUpdateInput, meter_typeUncheckedUpdateInput>
    /**
     * Choose, which meter_type to update.
     */
    where: meter_typeWhereUniqueInput
  }


  /**
   * meter_type updateMany
   */
  export type meter_typeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update meter_types.
     */
    data: XOR<meter_typeUpdateManyMutationInput, meter_typeUncheckedUpdateManyInput>
    /**
     * Filter which meter_types to update
     */
    where?: meter_typeWhereInput
  }


  /**
   * meter_type upsert
   */
  export type meter_typeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meter_type
     */
    select?: meter_typeSelect<ExtArgs> | null
    /**
     * The filter to search for the meter_type to update in case it exists.
     */
    where: meter_typeWhereUniqueInput
    /**
     * In case the meter_type found by the `where` argument doesn't exist, create a new meter_type with this data.
     */
    create: XOR<meter_typeCreateInput, meter_typeUncheckedCreateInput>
    /**
     * In case the meter_type was found with the provided `where` argument, update it with this data.
     */
    update: XOR<meter_typeUpdateInput, meter_typeUncheckedUpdateInput>
  }


  /**
   * meter_type delete
   */
  export type meter_typeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meter_type
     */
    select?: meter_typeSelect<ExtArgs> | null
    /**
     * Filter which meter_type to delete.
     */
    where: meter_typeWhereUniqueInput
  }


  /**
   * meter_type deleteMany
   */
  export type meter_typeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which meter_types to delete
     */
    where?: meter_typeWhereInput
  }


  /**
   * meter_type without action
   */
  export type meter_typeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meter_type
     */
    select?: meter_typeSelect<ExtArgs> | null
  }



  /**
   * Model module_list
   */

  export type AggregateModule_list = {
    _count: Module_listCountAggregateOutputType | null
    _avg: Module_listAvgAggregateOutputType | null
    _sum: Module_listSumAggregateOutputType | null
    _min: Module_listMinAggregateOutputType | null
    _max: Module_listMaxAggregateOutputType | null
  }

  export type Module_listAvgAggregateOutputType = {
    module_id: number | null
  }

  export type Module_listSumAggregateOutputType = {
    module_id: number | null
  }

  export type Module_listMinAggregateOutputType = {
    module_id: number | null
    module_serial: string | null
  }

  export type Module_listMaxAggregateOutputType = {
    module_id: number | null
    module_serial: string | null
  }

  export type Module_listCountAggregateOutputType = {
    module_id: number
    module_serial: number
    _all: number
  }


  export type Module_listAvgAggregateInputType = {
    module_id?: true
  }

  export type Module_listSumAggregateInputType = {
    module_id?: true
  }

  export type Module_listMinAggregateInputType = {
    module_id?: true
    module_serial?: true
  }

  export type Module_listMaxAggregateInputType = {
    module_id?: true
    module_serial?: true
  }

  export type Module_listCountAggregateInputType = {
    module_id?: true
    module_serial?: true
    _all?: true
  }

  export type Module_listAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which module_list to aggregate.
     */
    where?: module_listWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of module_lists to fetch.
     */
    orderBy?: module_listOrderByWithRelationInput | module_listOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: module_listWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` module_lists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` module_lists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned module_lists
    **/
    _count?: true | Module_listCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Module_listAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Module_listSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Module_listMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Module_listMaxAggregateInputType
  }

  export type GetModule_listAggregateType<T extends Module_listAggregateArgs> = {
        [P in keyof T & keyof AggregateModule_list]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateModule_list[P]>
      : GetScalarType<T[P], AggregateModule_list[P]>
  }




  export type module_listGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: module_listWhereInput
    orderBy?: module_listOrderByWithAggregationInput | module_listOrderByWithAggregationInput[]
    by: Module_listScalarFieldEnum[] | Module_listScalarFieldEnum
    having?: module_listScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Module_listCountAggregateInputType | true
    _avg?: Module_listAvgAggregateInputType
    _sum?: Module_listSumAggregateInputType
    _min?: Module_listMinAggregateInputType
    _max?: Module_listMaxAggregateInputType
  }

  export type Module_listGroupByOutputType = {
    module_id: number
    module_serial: string
    _count: Module_listCountAggregateOutputType | null
    _avg: Module_listAvgAggregateOutputType | null
    _sum: Module_listSumAggregateOutputType | null
    _min: Module_listMinAggregateOutputType | null
    _max: Module_listMaxAggregateOutputType | null
  }

  type GetModule_listGroupByPayload<T extends module_listGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Module_listGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Module_listGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Module_listGroupByOutputType[P]>
            : GetScalarType<T[P], Module_listGroupByOutputType[P]>
        }
      >
    >


  export type module_listSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    module_id?: boolean
    module_serial?: boolean
  }, ExtArgs["result"]["module_list"]>

  export type module_listSelectScalar = {
    module_id?: boolean
    module_serial?: boolean
  }


  export type $module_listPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "module_list"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      module_id: number
      module_serial: string
    }, ExtArgs["result"]["module_list"]>
    composites: {}
  }


  type module_listGetPayload<S extends boolean | null | undefined | module_listDefaultArgs> = $Result.GetResult<Prisma.$module_listPayload, S>

  type module_listCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<module_listFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Module_listCountAggregateInputType | true
    }

  export interface module_listDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['module_list'], meta: { name: 'module_list' } }
    /**
     * Find zero or one Module_list that matches the filter.
     * @param {module_listFindUniqueArgs} args - Arguments to find a Module_list
     * @example
     * // Get one Module_list
     * const module_list = await prisma.module_list.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends module_listFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, module_listFindUniqueArgs<ExtArgs>>
    ): Prisma__module_listClient<$Result.GetResult<Prisma.$module_listPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Module_list that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {module_listFindUniqueOrThrowArgs} args - Arguments to find a Module_list
     * @example
     * // Get one Module_list
     * const module_list = await prisma.module_list.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends module_listFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, module_listFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__module_listClient<$Result.GetResult<Prisma.$module_listPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Module_list that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {module_listFindFirstArgs} args - Arguments to find a Module_list
     * @example
     * // Get one Module_list
     * const module_list = await prisma.module_list.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends module_listFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, module_listFindFirstArgs<ExtArgs>>
    ): Prisma__module_listClient<$Result.GetResult<Prisma.$module_listPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Module_list that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {module_listFindFirstOrThrowArgs} args - Arguments to find a Module_list
     * @example
     * // Get one Module_list
     * const module_list = await prisma.module_list.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends module_listFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, module_listFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__module_listClient<$Result.GetResult<Prisma.$module_listPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Module_lists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {module_listFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Module_lists
     * const module_lists = await prisma.module_list.findMany()
     * 
     * // Get first 10 Module_lists
     * const module_lists = await prisma.module_list.findMany({ take: 10 })
     * 
     * // Only select the `module_id`
     * const module_listWithModule_idOnly = await prisma.module_list.findMany({ select: { module_id: true } })
     * 
    **/
    findMany<T extends module_listFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, module_listFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$module_listPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Module_list.
     * @param {module_listCreateArgs} args - Arguments to create a Module_list.
     * @example
     * // Create one Module_list
     * const Module_list = await prisma.module_list.create({
     *   data: {
     *     // ... data to create a Module_list
     *   }
     * })
     * 
    **/
    create<T extends module_listCreateArgs<ExtArgs>>(
      args: SelectSubset<T, module_listCreateArgs<ExtArgs>>
    ): Prisma__module_listClient<$Result.GetResult<Prisma.$module_listPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Module_lists.
     *     @param {module_listCreateManyArgs} args - Arguments to create many Module_lists.
     *     @example
     *     // Create many Module_lists
     *     const module_list = await prisma.module_list.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends module_listCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, module_listCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Module_list.
     * @param {module_listDeleteArgs} args - Arguments to delete one Module_list.
     * @example
     * // Delete one Module_list
     * const Module_list = await prisma.module_list.delete({
     *   where: {
     *     // ... filter to delete one Module_list
     *   }
     * })
     * 
    **/
    delete<T extends module_listDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, module_listDeleteArgs<ExtArgs>>
    ): Prisma__module_listClient<$Result.GetResult<Prisma.$module_listPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Module_list.
     * @param {module_listUpdateArgs} args - Arguments to update one Module_list.
     * @example
     * // Update one Module_list
     * const module_list = await prisma.module_list.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends module_listUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, module_listUpdateArgs<ExtArgs>>
    ): Prisma__module_listClient<$Result.GetResult<Prisma.$module_listPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Module_lists.
     * @param {module_listDeleteManyArgs} args - Arguments to filter Module_lists to delete.
     * @example
     * // Delete a few Module_lists
     * const { count } = await prisma.module_list.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends module_listDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, module_listDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Module_lists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {module_listUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Module_lists
     * const module_list = await prisma.module_list.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends module_listUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, module_listUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Module_list.
     * @param {module_listUpsertArgs} args - Arguments to update or create a Module_list.
     * @example
     * // Update or create a Module_list
     * const module_list = await prisma.module_list.upsert({
     *   create: {
     *     // ... data to create a Module_list
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Module_list we want to update
     *   }
     * })
    **/
    upsert<T extends module_listUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, module_listUpsertArgs<ExtArgs>>
    ): Prisma__module_listClient<$Result.GetResult<Prisma.$module_listPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Module_lists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {module_listCountArgs} args - Arguments to filter Module_lists to count.
     * @example
     * // Count the number of Module_lists
     * const count = await prisma.module_list.count({
     *   where: {
     *     // ... the filter for the Module_lists we want to count
     *   }
     * })
    **/
    count<T extends module_listCountArgs>(
      args?: Subset<T, module_listCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Module_listCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Module_list.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Module_listAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Module_listAggregateArgs>(args: Subset<T, Module_listAggregateArgs>): Prisma.PrismaPromise<GetModule_listAggregateType<T>>

    /**
     * Group by Module_list.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {module_listGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends module_listGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: module_listGroupByArgs['orderBy'] }
        : { orderBy?: module_listGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, module_listGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetModule_listGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the module_list model
   */
  readonly fields: module_listFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for module_list.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__module_listClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the module_list model
   */ 
  interface module_listFieldRefs {
    readonly module_id: FieldRef<"module_list", 'Int'>
    readonly module_serial: FieldRef<"module_list", 'String'>
  }
    

  // Custom InputTypes

  /**
   * module_list findUnique
   */
  export type module_listFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the module_list
     */
    select?: module_listSelect<ExtArgs> | null
    /**
     * Filter, which module_list to fetch.
     */
    where: module_listWhereUniqueInput
  }


  /**
   * module_list findUniqueOrThrow
   */
  export type module_listFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the module_list
     */
    select?: module_listSelect<ExtArgs> | null
    /**
     * Filter, which module_list to fetch.
     */
    where: module_listWhereUniqueInput
  }


  /**
   * module_list findFirst
   */
  export type module_listFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the module_list
     */
    select?: module_listSelect<ExtArgs> | null
    /**
     * Filter, which module_list to fetch.
     */
    where?: module_listWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of module_lists to fetch.
     */
    orderBy?: module_listOrderByWithRelationInput | module_listOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for module_lists.
     */
    cursor?: module_listWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` module_lists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` module_lists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of module_lists.
     */
    distinct?: Module_listScalarFieldEnum | Module_listScalarFieldEnum[]
  }


  /**
   * module_list findFirstOrThrow
   */
  export type module_listFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the module_list
     */
    select?: module_listSelect<ExtArgs> | null
    /**
     * Filter, which module_list to fetch.
     */
    where?: module_listWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of module_lists to fetch.
     */
    orderBy?: module_listOrderByWithRelationInput | module_listOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for module_lists.
     */
    cursor?: module_listWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` module_lists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` module_lists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of module_lists.
     */
    distinct?: Module_listScalarFieldEnum | Module_listScalarFieldEnum[]
  }


  /**
   * module_list findMany
   */
  export type module_listFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the module_list
     */
    select?: module_listSelect<ExtArgs> | null
    /**
     * Filter, which module_lists to fetch.
     */
    where?: module_listWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of module_lists to fetch.
     */
    orderBy?: module_listOrderByWithRelationInput | module_listOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing module_lists.
     */
    cursor?: module_listWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` module_lists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` module_lists.
     */
    skip?: number
    distinct?: Module_listScalarFieldEnum | Module_listScalarFieldEnum[]
  }


  /**
   * module_list create
   */
  export type module_listCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the module_list
     */
    select?: module_listSelect<ExtArgs> | null
    /**
     * The data needed to create a module_list.
     */
    data: XOR<module_listCreateInput, module_listUncheckedCreateInput>
  }


  /**
   * module_list createMany
   */
  export type module_listCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many module_lists.
     */
    data: module_listCreateManyInput | module_listCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * module_list update
   */
  export type module_listUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the module_list
     */
    select?: module_listSelect<ExtArgs> | null
    /**
     * The data needed to update a module_list.
     */
    data: XOR<module_listUpdateInput, module_listUncheckedUpdateInput>
    /**
     * Choose, which module_list to update.
     */
    where: module_listWhereUniqueInput
  }


  /**
   * module_list updateMany
   */
  export type module_listUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update module_lists.
     */
    data: XOR<module_listUpdateManyMutationInput, module_listUncheckedUpdateManyInput>
    /**
     * Filter which module_lists to update
     */
    where?: module_listWhereInput
  }


  /**
   * module_list upsert
   */
  export type module_listUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the module_list
     */
    select?: module_listSelect<ExtArgs> | null
    /**
     * The filter to search for the module_list to update in case it exists.
     */
    where: module_listWhereUniqueInput
    /**
     * In case the module_list found by the `where` argument doesn't exist, create a new module_list with this data.
     */
    create: XOR<module_listCreateInput, module_listUncheckedCreateInput>
    /**
     * In case the module_list was found with the provided `where` argument, update it with this data.
     */
    update: XOR<module_listUpdateInput, module_listUncheckedUpdateInput>
  }


  /**
   * module_list delete
   */
  export type module_listDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the module_list
     */
    select?: module_listSelect<ExtArgs> | null
    /**
     * Filter which module_list to delete.
     */
    where: module_listWhereUniqueInput
  }


  /**
   * module_list deleteMany
   */
  export type module_listDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which module_lists to delete
     */
    where?: module_listWhereInput
  }


  /**
   * module_list without action
   */
  export type module_listDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the module_list
     */
    select?: module_listSelect<ExtArgs> | null
  }



  /**
   * Model order_num
   */

  export type AggregateOrder_num = {
    _count: Order_numCountAggregateOutputType | null
    _avg: Order_numAvgAggregateOutputType | null
    _sum: Order_numSumAggregateOutputType | null
    _min: Order_numMinAggregateOutputType | null
    _max: Order_numMaxAggregateOutputType | null
  }

  export type Order_numAvgAggregateOutputType = {
    id: number | null
    counter: number | null
  }

  export type Order_numSumAggregateOutputType = {
    id: number | null
    counter: number | null
  }

  export type Order_numMinAggregateOutputType = {
    id: number | null
    value: string | null
    counter: number | null
  }

  export type Order_numMaxAggregateOutputType = {
    id: number | null
    value: string | null
    counter: number | null
  }

  export type Order_numCountAggregateOutputType = {
    id: number
    value: number
    counter: number
    _all: number
  }


  export type Order_numAvgAggregateInputType = {
    id?: true
    counter?: true
  }

  export type Order_numSumAggregateInputType = {
    id?: true
    counter?: true
  }

  export type Order_numMinAggregateInputType = {
    id?: true
    value?: true
    counter?: true
  }

  export type Order_numMaxAggregateInputType = {
    id?: true
    value?: true
    counter?: true
  }

  export type Order_numCountAggregateInputType = {
    id?: true
    value?: true
    counter?: true
    _all?: true
  }

  export type Order_numAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which order_num to aggregate.
     */
    where?: order_numWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of order_nums to fetch.
     */
    orderBy?: order_numOrderByWithRelationInput | order_numOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: order_numWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` order_nums from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` order_nums.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned order_nums
    **/
    _count?: true | Order_numCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Order_numAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Order_numSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Order_numMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Order_numMaxAggregateInputType
  }

  export type GetOrder_numAggregateType<T extends Order_numAggregateArgs> = {
        [P in keyof T & keyof AggregateOrder_num]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrder_num[P]>
      : GetScalarType<T[P], AggregateOrder_num[P]>
  }




  export type order_numGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: order_numWhereInput
    orderBy?: order_numOrderByWithAggregationInput | order_numOrderByWithAggregationInput[]
    by: Order_numScalarFieldEnum[] | Order_numScalarFieldEnum
    having?: order_numScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Order_numCountAggregateInputType | true
    _avg?: Order_numAvgAggregateInputType
    _sum?: Order_numSumAggregateInputType
    _min?: Order_numMinAggregateInputType
    _max?: Order_numMaxAggregateInputType
  }

  export type Order_numGroupByOutputType = {
    id: number
    value: string
    counter: number
    _count: Order_numCountAggregateOutputType | null
    _avg: Order_numAvgAggregateOutputType | null
    _sum: Order_numSumAggregateOutputType | null
    _min: Order_numMinAggregateOutputType | null
    _max: Order_numMaxAggregateOutputType | null
  }

  type GetOrder_numGroupByPayload<T extends order_numGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Order_numGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Order_numGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Order_numGroupByOutputType[P]>
            : GetScalarType<T[P], Order_numGroupByOutputType[P]>
        }
      >
    >


  export type order_numSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
    counter?: boolean
  }, ExtArgs["result"]["order_num"]>

  export type order_numSelectScalar = {
    id?: boolean
    value?: boolean
    counter?: boolean
  }


  export type $order_numPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "order_num"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      value: string
      counter: number
    }, ExtArgs["result"]["order_num"]>
    composites: {}
  }


  type order_numGetPayload<S extends boolean | null | undefined | order_numDefaultArgs> = $Result.GetResult<Prisma.$order_numPayload, S>

  type order_numCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<order_numFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Order_numCountAggregateInputType | true
    }

  export interface order_numDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['order_num'], meta: { name: 'order_num' } }
    /**
     * Find zero or one Order_num that matches the filter.
     * @param {order_numFindUniqueArgs} args - Arguments to find a Order_num
     * @example
     * // Get one Order_num
     * const order_num = await prisma.order_num.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends order_numFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, order_numFindUniqueArgs<ExtArgs>>
    ): Prisma__order_numClient<$Result.GetResult<Prisma.$order_numPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Order_num that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {order_numFindUniqueOrThrowArgs} args - Arguments to find a Order_num
     * @example
     * // Get one Order_num
     * const order_num = await prisma.order_num.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends order_numFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, order_numFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__order_numClient<$Result.GetResult<Prisma.$order_numPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Order_num that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {order_numFindFirstArgs} args - Arguments to find a Order_num
     * @example
     * // Get one Order_num
     * const order_num = await prisma.order_num.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends order_numFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, order_numFindFirstArgs<ExtArgs>>
    ): Prisma__order_numClient<$Result.GetResult<Prisma.$order_numPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Order_num that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {order_numFindFirstOrThrowArgs} args - Arguments to find a Order_num
     * @example
     * // Get one Order_num
     * const order_num = await prisma.order_num.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends order_numFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, order_numFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__order_numClient<$Result.GetResult<Prisma.$order_numPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Order_nums that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {order_numFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Order_nums
     * const order_nums = await prisma.order_num.findMany()
     * 
     * // Get first 10 Order_nums
     * const order_nums = await prisma.order_num.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const order_numWithIdOnly = await prisma.order_num.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends order_numFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, order_numFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$order_numPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Order_num.
     * @param {order_numCreateArgs} args - Arguments to create a Order_num.
     * @example
     * // Create one Order_num
     * const Order_num = await prisma.order_num.create({
     *   data: {
     *     // ... data to create a Order_num
     *   }
     * })
     * 
    **/
    create<T extends order_numCreateArgs<ExtArgs>>(
      args: SelectSubset<T, order_numCreateArgs<ExtArgs>>
    ): Prisma__order_numClient<$Result.GetResult<Prisma.$order_numPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Order_nums.
     *     @param {order_numCreateManyArgs} args - Arguments to create many Order_nums.
     *     @example
     *     // Create many Order_nums
     *     const order_num = await prisma.order_num.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends order_numCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, order_numCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Order_num.
     * @param {order_numDeleteArgs} args - Arguments to delete one Order_num.
     * @example
     * // Delete one Order_num
     * const Order_num = await prisma.order_num.delete({
     *   where: {
     *     // ... filter to delete one Order_num
     *   }
     * })
     * 
    **/
    delete<T extends order_numDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, order_numDeleteArgs<ExtArgs>>
    ): Prisma__order_numClient<$Result.GetResult<Prisma.$order_numPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Order_num.
     * @param {order_numUpdateArgs} args - Arguments to update one Order_num.
     * @example
     * // Update one Order_num
     * const order_num = await prisma.order_num.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends order_numUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, order_numUpdateArgs<ExtArgs>>
    ): Prisma__order_numClient<$Result.GetResult<Prisma.$order_numPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Order_nums.
     * @param {order_numDeleteManyArgs} args - Arguments to filter Order_nums to delete.
     * @example
     * // Delete a few Order_nums
     * const { count } = await prisma.order_num.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends order_numDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, order_numDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Order_nums.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {order_numUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Order_nums
     * const order_num = await prisma.order_num.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends order_numUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, order_numUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Order_num.
     * @param {order_numUpsertArgs} args - Arguments to update or create a Order_num.
     * @example
     * // Update or create a Order_num
     * const order_num = await prisma.order_num.upsert({
     *   create: {
     *     // ... data to create a Order_num
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Order_num we want to update
     *   }
     * })
    **/
    upsert<T extends order_numUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, order_numUpsertArgs<ExtArgs>>
    ): Prisma__order_numClient<$Result.GetResult<Prisma.$order_numPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Order_nums.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {order_numCountArgs} args - Arguments to filter Order_nums to count.
     * @example
     * // Count the number of Order_nums
     * const count = await prisma.order_num.count({
     *   where: {
     *     // ... the filter for the Order_nums we want to count
     *   }
     * })
    **/
    count<T extends order_numCountArgs>(
      args?: Subset<T, order_numCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Order_numCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Order_num.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Order_numAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Order_numAggregateArgs>(args: Subset<T, Order_numAggregateArgs>): Prisma.PrismaPromise<GetOrder_numAggregateType<T>>

    /**
     * Group by Order_num.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {order_numGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends order_numGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: order_numGroupByArgs['orderBy'] }
        : { orderBy?: order_numGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, order_numGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrder_numGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the order_num model
   */
  readonly fields: order_numFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for order_num.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__order_numClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the order_num model
   */ 
  interface order_numFieldRefs {
    readonly id: FieldRef<"order_num", 'Int'>
    readonly value: FieldRef<"order_num", 'String'>
    readonly counter: FieldRef<"order_num", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * order_num findUnique
   */
  export type order_numFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_num
     */
    select?: order_numSelect<ExtArgs> | null
    /**
     * Filter, which order_num to fetch.
     */
    where: order_numWhereUniqueInput
  }


  /**
   * order_num findUniqueOrThrow
   */
  export type order_numFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_num
     */
    select?: order_numSelect<ExtArgs> | null
    /**
     * Filter, which order_num to fetch.
     */
    where: order_numWhereUniqueInput
  }


  /**
   * order_num findFirst
   */
  export type order_numFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_num
     */
    select?: order_numSelect<ExtArgs> | null
    /**
     * Filter, which order_num to fetch.
     */
    where?: order_numWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of order_nums to fetch.
     */
    orderBy?: order_numOrderByWithRelationInput | order_numOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for order_nums.
     */
    cursor?: order_numWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` order_nums from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` order_nums.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of order_nums.
     */
    distinct?: Order_numScalarFieldEnum | Order_numScalarFieldEnum[]
  }


  /**
   * order_num findFirstOrThrow
   */
  export type order_numFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_num
     */
    select?: order_numSelect<ExtArgs> | null
    /**
     * Filter, which order_num to fetch.
     */
    where?: order_numWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of order_nums to fetch.
     */
    orderBy?: order_numOrderByWithRelationInput | order_numOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for order_nums.
     */
    cursor?: order_numWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` order_nums from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` order_nums.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of order_nums.
     */
    distinct?: Order_numScalarFieldEnum | Order_numScalarFieldEnum[]
  }


  /**
   * order_num findMany
   */
  export type order_numFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_num
     */
    select?: order_numSelect<ExtArgs> | null
    /**
     * Filter, which order_nums to fetch.
     */
    where?: order_numWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of order_nums to fetch.
     */
    orderBy?: order_numOrderByWithRelationInput | order_numOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing order_nums.
     */
    cursor?: order_numWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` order_nums from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` order_nums.
     */
    skip?: number
    distinct?: Order_numScalarFieldEnum | Order_numScalarFieldEnum[]
  }


  /**
   * order_num create
   */
  export type order_numCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_num
     */
    select?: order_numSelect<ExtArgs> | null
    /**
     * The data needed to create a order_num.
     */
    data: XOR<order_numCreateInput, order_numUncheckedCreateInput>
  }


  /**
   * order_num createMany
   */
  export type order_numCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many order_nums.
     */
    data: order_numCreateManyInput | order_numCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * order_num update
   */
  export type order_numUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_num
     */
    select?: order_numSelect<ExtArgs> | null
    /**
     * The data needed to update a order_num.
     */
    data: XOR<order_numUpdateInput, order_numUncheckedUpdateInput>
    /**
     * Choose, which order_num to update.
     */
    where: order_numWhereUniqueInput
  }


  /**
   * order_num updateMany
   */
  export type order_numUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update order_nums.
     */
    data: XOR<order_numUpdateManyMutationInput, order_numUncheckedUpdateManyInput>
    /**
     * Filter which order_nums to update
     */
    where?: order_numWhereInput
  }


  /**
   * order_num upsert
   */
  export type order_numUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_num
     */
    select?: order_numSelect<ExtArgs> | null
    /**
     * The filter to search for the order_num to update in case it exists.
     */
    where: order_numWhereUniqueInput
    /**
     * In case the order_num found by the `where` argument doesn't exist, create a new order_num with this data.
     */
    create: XOR<order_numCreateInput, order_numUncheckedCreateInput>
    /**
     * In case the order_num was found with the provided `where` argument, update it with this data.
     */
    update: XOR<order_numUpdateInput, order_numUncheckedUpdateInput>
  }


  /**
   * order_num delete
   */
  export type order_numDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_num
     */
    select?: order_numSelect<ExtArgs> | null
    /**
     * Filter which order_num to delete.
     */
    where: order_numWhereUniqueInput
  }


  /**
   * order_num deleteMany
   */
  export type order_numDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which order_nums to delete
     */
    where?: order_numWhereInput
  }


  /**
   * order_num without action
   */
  export type order_numDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_num
     */
    select?: order_numSelect<ExtArgs> | null
  }



  /**
   * Model out_110
   */

  export type AggregateOut_110 = {
    _count: Out_110CountAggregateOutputType | null
    _avg: Out_110AvgAggregateOutputType | null
    _sum: Out_110SumAggregateOutputType | null
    _min: Out_110MinAggregateOutputType | null
    _max: Out_110MaxAggregateOutputType | null
  }

  export type Out_110AvgAggregateOutputType = {
    id: number | null
    receive_id: number | null
  }

  export type Out_110SumAggregateOutputType = {
    id: number | null
    receive_id: number | null
  }

  export type Out_110MinAggregateOutputType = {
    id: number | null
    serial: string | null
    qr_serial: string | null
    timestamp: Date | null
    receive_id: number | null
  }

  export type Out_110MaxAggregateOutputType = {
    id: number | null
    serial: string | null
    qr_serial: string | null
    timestamp: Date | null
    receive_id: number | null
  }

  export type Out_110CountAggregateOutputType = {
    id: number
    serial: number
    qr_serial: number
    timestamp: number
    receive_id: number
    _all: number
  }


  export type Out_110AvgAggregateInputType = {
    id?: true
    receive_id?: true
  }

  export type Out_110SumAggregateInputType = {
    id?: true
    receive_id?: true
  }

  export type Out_110MinAggregateInputType = {
    id?: true
    serial?: true
    qr_serial?: true
    timestamp?: true
    receive_id?: true
  }

  export type Out_110MaxAggregateInputType = {
    id?: true
    serial?: true
    qr_serial?: true
    timestamp?: true
    receive_id?: true
  }

  export type Out_110CountAggregateInputType = {
    id?: true
    serial?: true
    qr_serial?: true
    timestamp?: true
    receive_id?: true
    _all?: true
  }

  export type Out_110AggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which out_110 to aggregate.
     */
    where?: out_110WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of out_110s to fetch.
     */
    orderBy?: out_110OrderByWithRelationInput | out_110OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: out_110WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` out_110s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` out_110s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned out_110s
    **/
    _count?: true | Out_110CountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Out_110AvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Out_110SumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Out_110MinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Out_110MaxAggregateInputType
  }

  export type GetOut_110AggregateType<T extends Out_110AggregateArgs> = {
        [P in keyof T & keyof AggregateOut_110]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOut_110[P]>
      : GetScalarType<T[P], AggregateOut_110[P]>
  }




  export type out_110GroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: out_110WhereInput
    orderBy?: out_110OrderByWithAggregationInput | out_110OrderByWithAggregationInput[]
    by: Out_110ScalarFieldEnum[] | Out_110ScalarFieldEnum
    having?: out_110ScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Out_110CountAggregateInputType | true
    _avg?: Out_110AvgAggregateInputType
    _sum?: Out_110SumAggregateInputType
    _min?: Out_110MinAggregateInputType
    _max?: Out_110MaxAggregateInputType
  }

  export type Out_110GroupByOutputType = {
    id: number
    serial: string
    qr_serial: string
    timestamp: Date
    receive_id: number
    _count: Out_110CountAggregateOutputType | null
    _avg: Out_110AvgAggregateOutputType | null
    _sum: Out_110SumAggregateOutputType | null
    _min: Out_110MinAggregateOutputType | null
    _max: Out_110MaxAggregateOutputType | null
  }

  type GetOut_110GroupByPayload<T extends out_110GroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Out_110GroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Out_110GroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Out_110GroupByOutputType[P]>
            : GetScalarType<T[P], Out_110GroupByOutputType[P]>
        }
      >
    >


  export type out_110Select<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serial?: boolean
    qr_serial?: boolean
    timestamp?: boolean
    receive_id?: boolean
  }, ExtArgs["result"]["out_110"]>

  export type out_110SelectScalar = {
    id?: boolean
    serial?: boolean
    qr_serial?: boolean
    timestamp?: boolean
    receive_id?: boolean
  }


  export type $out_110Payload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "out_110"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      serial: string
      qr_serial: string
      timestamp: Date
      receive_id: number
    }, ExtArgs["result"]["out_110"]>
    composites: {}
  }


  type out_110GetPayload<S extends boolean | null | undefined | out_110DefaultArgs> = $Result.GetResult<Prisma.$out_110Payload, S>

  type out_110CountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<out_110FindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Out_110CountAggregateInputType | true
    }

  export interface out_110Delegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['out_110'], meta: { name: 'out_110' } }
    /**
     * Find zero or one Out_110 that matches the filter.
     * @param {out_110FindUniqueArgs} args - Arguments to find a Out_110
     * @example
     * // Get one Out_110
     * const out_110 = await prisma.out_110.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends out_110FindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, out_110FindUniqueArgs<ExtArgs>>
    ): Prisma__out_110Client<$Result.GetResult<Prisma.$out_110Payload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Out_110 that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {out_110FindUniqueOrThrowArgs} args - Arguments to find a Out_110
     * @example
     * // Get one Out_110
     * const out_110 = await prisma.out_110.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends out_110FindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, out_110FindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__out_110Client<$Result.GetResult<Prisma.$out_110Payload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Out_110 that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {out_110FindFirstArgs} args - Arguments to find a Out_110
     * @example
     * // Get one Out_110
     * const out_110 = await prisma.out_110.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends out_110FindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, out_110FindFirstArgs<ExtArgs>>
    ): Prisma__out_110Client<$Result.GetResult<Prisma.$out_110Payload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Out_110 that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {out_110FindFirstOrThrowArgs} args - Arguments to find a Out_110
     * @example
     * // Get one Out_110
     * const out_110 = await prisma.out_110.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends out_110FindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, out_110FindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__out_110Client<$Result.GetResult<Prisma.$out_110Payload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Out_110s that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {out_110FindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Out_110s
     * const out_110s = await prisma.out_110.findMany()
     * 
     * // Get first 10 Out_110s
     * const out_110s = await prisma.out_110.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const out_110WithIdOnly = await prisma.out_110.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends out_110FindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, out_110FindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$out_110Payload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Out_110.
     * @param {out_110CreateArgs} args - Arguments to create a Out_110.
     * @example
     * // Create one Out_110
     * const Out_110 = await prisma.out_110.create({
     *   data: {
     *     // ... data to create a Out_110
     *   }
     * })
     * 
    **/
    create<T extends out_110CreateArgs<ExtArgs>>(
      args: SelectSubset<T, out_110CreateArgs<ExtArgs>>
    ): Prisma__out_110Client<$Result.GetResult<Prisma.$out_110Payload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Out_110s.
     *     @param {out_110CreateManyArgs} args - Arguments to create many Out_110s.
     *     @example
     *     // Create many Out_110s
     *     const out_110 = await prisma.out_110.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends out_110CreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, out_110CreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Out_110.
     * @param {out_110DeleteArgs} args - Arguments to delete one Out_110.
     * @example
     * // Delete one Out_110
     * const Out_110 = await prisma.out_110.delete({
     *   where: {
     *     // ... filter to delete one Out_110
     *   }
     * })
     * 
    **/
    delete<T extends out_110DeleteArgs<ExtArgs>>(
      args: SelectSubset<T, out_110DeleteArgs<ExtArgs>>
    ): Prisma__out_110Client<$Result.GetResult<Prisma.$out_110Payload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Out_110.
     * @param {out_110UpdateArgs} args - Arguments to update one Out_110.
     * @example
     * // Update one Out_110
     * const out_110 = await prisma.out_110.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends out_110UpdateArgs<ExtArgs>>(
      args: SelectSubset<T, out_110UpdateArgs<ExtArgs>>
    ): Prisma__out_110Client<$Result.GetResult<Prisma.$out_110Payload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Out_110s.
     * @param {out_110DeleteManyArgs} args - Arguments to filter Out_110s to delete.
     * @example
     * // Delete a few Out_110s
     * const { count } = await prisma.out_110.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends out_110DeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, out_110DeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Out_110s.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {out_110UpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Out_110s
     * const out_110 = await prisma.out_110.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends out_110UpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, out_110UpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Out_110.
     * @param {out_110UpsertArgs} args - Arguments to update or create a Out_110.
     * @example
     * // Update or create a Out_110
     * const out_110 = await prisma.out_110.upsert({
     *   create: {
     *     // ... data to create a Out_110
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Out_110 we want to update
     *   }
     * })
    **/
    upsert<T extends out_110UpsertArgs<ExtArgs>>(
      args: SelectSubset<T, out_110UpsertArgs<ExtArgs>>
    ): Prisma__out_110Client<$Result.GetResult<Prisma.$out_110Payload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Out_110s.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {out_110CountArgs} args - Arguments to filter Out_110s to count.
     * @example
     * // Count the number of Out_110s
     * const count = await prisma.out_110.count({
     *   where: {
     *     // ... the filter for the Out_110s we want to count
     *   }
     * })
    **/
    count<T extends out_110CountArgs>(
      args?: Subset<T, out_110CountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Out_110CountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Out_110.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Out_110AggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Out_110AggregateArgs>(args: Subset<T, Out_110AggregateArgs>): Prisma.PrismaPromise<GetOut_110AggregateType<T>>

    /**
     * Group by Out_110.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {out_110GroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends out_110GroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: out_110GroupByArgs['orderBy'] }
        : { orderBy?: out_110GroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, out_110GroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOut_110GroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the out_110 model
   */
  readonly fields: out_110FieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for out_110.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__out_110Client<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the out_110 model
   */ 
  interface out_110FieldRefs {
    readonly id: FieldRef<"out_110", 'Int'>
    readonly serial: FieldRef<"out_110", 'String'>
    readonly qr_serial: FieldRef<"out_110", 'String'>
    readonly timestamp: FieldRef<"out_110", 'DateTime'>
    readonly receive_id: FieldRef<"out_110", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * out_110 findUnique
   */
  export type out_110FindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the out_110
     */
    select?: out_110Select<ExtArgs> | null
    /**
     * Filter, which out_110 to fetch.
     */
    where: out_110WhereUniqueInput
  }


  /**
   * out_110 findUniqueOrThrow
   */
  export type out_110FindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the out_110
     */
    select?: out_110Select<ExtArgs> | null
    /**
     * Filter, which out_110 to fetch.
     */
    where: out_110WhereUniqueInput
  }


  /**
   * out_110 findFirst
   */
  export type out_110FindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the out_110
     */
    select?: out_110Select<ExtArgs> | null
    /**
     * Filter, which out_110 to fetch.
     */
    where?: out_110WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of out_110s to fetch.
     */
    orderBy?: out_110OrderByWithRelationInput | out_110OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for out_110s.
     */
    cursor?: out_110WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` out_110s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` out_110s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of out_110s.
     */
    distinct?: Out_110ScalarFieldEnum | Out_110ScalarFieldEnum[]
  }


  /**
   * out_110 findFirstOrThrow
   */
  export type out_110FindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the out_110
     */
    select?: out_110Select<ExtArgs> | null
    /**
     * Filter, which out_110 to fetch.
     */
    where?: out_110WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of out_110s to fetch.
     */
    orderBy?: out_110OrderByWithRelationInput | out_110OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for out_110s.
     */
    cursor?: out_110WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` out_110s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` out_110s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of out_110s.
     */
    distinct?: Out_110ScalarFieldEnum | Out_110ScalarFieldEnum[]
  }


  /**
   * out_110 findMany
   */
  export type out_110FindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the out_110
     */
    select?: out_110Select<ExtArgs> | null
    /**
     * Filter, which out_110s to fetch.
     */
    where?: out_110WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of out_110s to fetch.
     */
    orderBy?: out_110OrderByWithRelationInput | out_110OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing out_110s.
     */
    cursor?: out_110WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` out_110s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` out_110s.
     */
    skip?: number
    distinct?: Out_110ScalarFieldEnum | Out_110ScalarFieldEnum[]
  }


  /**
   * out_110 create
   */
  export type out_110CreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the out_110
     */
    select?: out_110Select<ExtArgs> | null
    /**
     * The data needed to create a out_110.
     */
    data: XOR<out_110CreateInput, out_110UncheckedCreateInput>
  }


  /**
   * out_110 createMany
   */
  export type out_110CreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many out_110s.
     */
    data: out_110CreateManyInput | out_110CreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * out_110 update
   */
  export type out_110UpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the out_110
     */
    select?: out_110Select<ExtArgs> | null
    /**
     * The data needed to update a out_110.
     */
    data: XOR<out_110UpdateInput, out_110UncheckedUpdateInput>
    /**
     * Choose, which out_110 to update.
     */
    where: out_110WhereUniqueInput
  }


  /**
   * out_110 updateMany
   */
  export type out_110UpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update out_110s.
     */
    data: XOR<out_110UpdateManyMutationInput, out_110UncheckedUpdateManyInput>
    /**
     * Filter which out_110s to update
     */
    where?: out_110WhereInput
  }


  /**
   * out_110 upsert
   */
  export type out_110UpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the out_110
     */
    select?: out_110Select<ExtArgs> | null
    /**
     * The filter to search for the out_110 to update in case it exists.
     */
    where: out_110WhereUniqueInput
    /**
     * In case the out_110 found by the `where` argument doesn't exist, create a new out_110 with this data.
     */
    create: XOR<out_110CreateInput, out_110UncheckedCreateInput>
    /**
     * In case the out_110 was found with the provided `where` argument, update it with this data.
     */
    update: XOR<out_110UpdateInput, out_110UncheckedUpdateInput>
  }


  /**
   * out_110 delete
   */
  export type out_110DeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the out_110
     */
    select?: out_110Select<ExtArgs> | null
    /**
     * Filter which out_110 to delete.
     */
    where: out_110WhereUniqueInput
  }


  /**
   * out_110 deleteMany
   */
  export type out_110DeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which out_110s to delete
     */
    where?: out_110WhereInput
  }


  /**
   * out_110 without action
   */
  export type out_110DefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the out_110
     */
    select?: out_110Select<ExtArgs> | null
  }



  /**
   * Model output_target
   */

  export type AggregateOutput_target = {
    _count: Output_targetCountAggregateOutputType | null
    _avg: Output_targetAvgAggregateOutputType | null
    _sum: Output_targetSumAggregateOutputType | null
    _min: Output_targetMinAggregateOutputType | null
    _max: Output_targetMaxAggregateOutputType | null
  }

  export type Output_targetAvgAggregateOutputType = {
    id: number | null
  }

  export type Output_targetSumAggregateOutputType = {
    id: number | null
  }

  export type Output_targetMinAggregateOutputType = {
    id: number | null
    output: string | null
    type: string | null
    waktu: string | null
    line: string | null
    timestamp: Date | null
  }

  export type Output_targetMaxAggregateOutputType = {
    id: number | null
    output: string | null
    type: string | null
    waktu: string | null
    line: string | null
    timestamp: Date | null
  }

  export type Output_targetCountAggregateOutputType = {
    id: number
    output: number
    type: number
    waktu: number
    line: number
    timestamp: number
    _all: number
  }


  export type Output_targetAvgAggregateInputType = {
    id?: true
  }

  export type Output_targetSumAggregateInputType = {
    id?: true
  }

  export type Output_targetMinAggregateInputType = {
    id?: true
    output?: true
    type?: true
    waktu?: true
    line?: true
    timestamp?: true
  }

  export type Output_targetMaxAggregateInputType = {
    id?: true
    output?: true
    type?: true
    waktu?: true
    line?: true
    timestamp?: true
  }

  export type Output_targetCountAggregateInputType = {
    id?: true
    output?: true
    type?: true
    waktu?: true
    line?: true
    timestamp?: true
    _all?: true
  }

  export type Output_targetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which output_target to aggregate.
     */
    where?: output_targetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of output_targets to fetch.
     */
    orderBy?: output_targetOrderByWithRelationInput | output_targetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: output_targetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` output_targets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` output_targets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned output_targets
    **/
    _count?: true | Output_targetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Output_targetAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Output_targetSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Output_targetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Output_targetMaxAggregateInputType
  }

  export type GetOutput_targetAggregateType<T extends Output_targetAggregateArgs> = {
        [P in keyof T & keyof AggregateOutput_target]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOutput_target[P]>
      : GetScalarType<T[P], AggregateOutput_target[P]>
  }




  export type output_targetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: output_targetWhereInput
    orderBy?: output_targetOrderByWithAggregationInput | output_targetOrderByWithAggregationInput[]
    by: Output_targetScalarFieldEnum[] | Output_targetScalarFieldEnum
    having?: output_targetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Output_targetCountAggregateInputType | true
    _avg?: Output_targetAvgAggregateInputType
    _sum?: Output_targetSumAggregateInputType
    _min?: Output_targetMinAggregateInputType
    _max?: Output_targetMaxAggregateInputType
  }

  export type Output_targetGroupByOutputType = {
    id: number
    output: string
    type: string
    waktu: string
    line: string
    timestamp: Date
    _count: Output_targetCountAggregateOutputType | null
    _avg: Output_targetAvgAggregateOutputType | null
    _sum: Output_targetSumAggregateOutputType | null
    _min: Output_targetMinAggregateOutputType | null
    _max: Output_targetMaxAggregateOutputType | null
  }

  type GetOutput_targetGroupByPayload<T extends output_targetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Output_targetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Output_targetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Output_targetGroupByOutputType[P]>
            : GetScalarType<T[P], Output_targetGroupByOutputType[P]>
        }
      >
    >


  export type output_targetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    output?: boolean
    type?: boolean
    waktu?: boolean
    line?: boolean
    timestamp?: boolean
  }, ExtArgs["result"]["output_target"]>

  export type output_targetSelectScalar = {
    id?: boolean
    output?: boolean
    type?: boolean
    waktu?: boolean
    line?: boolean
    timestamp?: boolean
  }


  export type $output_targetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "output_target"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      output: string
      type: string
      waktu: string
      line: string
      timestamp: Date
    }, ExtArgs["result"]["output_target"]>
    composites: {}
  }


  type output_targetGetPayload<S extends boolean | null | undefined | output_targetDefaultArgs> = $Result.GetResult<Prisma.$output_targetPayload, S>

  type output_targetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<output_targetFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Output_targetCountAggregateInputType | true
    }

  export interface output_targetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['output_target'], meta: { name: 'output_target' } }
    /**
     * Find zero or one Output_target that matches the filter.
     * @param {output_targetFindUniqueArgs} args - Arguments to find a Output_target
     * @example
     * // Get one Output_target
     * const output_target = await prisma.output_target.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends output_targetFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, output_targetFindUniqueArgs<ExtArgs>>
    ): Prisma__output_targetClient<$Result.GetResult<Prisma.$output_targetPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Output_target that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {output_targetFindUniqueOrThrowArgs} args - Arguments to find a Output_target
     * @example
     * // Get one Output_target
     * const output_target = await prisma.output_target.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends output_targetFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, output_targetFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__output_targetClient<$Result.GetResult<Prisma.$output_targetPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Output_target that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {output_targetFindFirstArgs} args - Arguments to find a Output_target
     * @example
     * // Get one Output_target
     * const output_target = await prisma.output_target.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends output_targetFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, output_targetFindFirstArgs<ExtArgs>>
    ): Prisma__output_targetClient<$Result.GetResult<Prisma.$output_targetPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Output_target that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {output_targetFindFirstOrThrowArgs} args - Arguments to find a Output_target
     * @example
     * // Get one Output_target
     * const output_target = await prisma.output_target.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends output_targetFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, output_targetFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__output_targetClient<$Result.GetResult<Prisma.$output_targetPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Output_targets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {output_targetFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Output_targets
     * const output_targets = await prisma.output_target.findMany()
     * 
     * // Get first 10 Output_targets
     * const output_targets = await prisma.output_target.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const output_targetWithIdOnly = await prisma.output_target.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends output_targetFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, output_targetFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$output_targetPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Output_target.
     * @param {output_targetCreateArgs} args - Arguments to create a Output_target.
     * @example
     * // Create one Output_target
     * const Output_target = await prisma.output_target.create({
     *   data: {
     *     // ... data to create a Output_target
     *   }
     * })
     * 
    **/
    create<T extends output_targetCreateArgs<ExtArgs>>(
      args: SelectSubset<T, output_targetCreateArgs<ExtArgs>>
    ): Prisma__output_targetClient<$Result.GetResult<Prisma.$output_targetPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Output_targets.
     *     @param {output_targetCreateManyArgs} args - Arguments to create many Output_targets.
     *     @example
     *     // Create many Output_targets
     *     const output_target = await prisma.output_target.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends output_targetCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, output_targetCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Output_target.
     * @param {output_targetDeleteArgs} args - Arguments to delete one Output_target.
     * @example
     * // Delete one Output_target
     * const Output_target = await prisma.output_target.delete({
     *   where: {
     *     // ... filter to delete one Output_target
     *   }
     * })
     * 
    **/
    delete<T extends output_targetDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, output_targetDeleteArgs<ExtArgs>>
    ): Prisma__output_targetClient<$Result.GetResult<Prisma.$output_targetPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Output_target.
     * @param {output_targetUpdateArgs} args - Arguments to update one Output_target.
     * @example
     * // Update one Output_target
     * const output_target = await prisma.output_target.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends output_targetUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, output_targetUpdateArgs<ExtArgs>>
    ): Prisma__output_targetClient<$Result.GetResult<Prisma.$output_targetPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Output_targets.
     * @param {output_targetDeleteManyArgs} args - Arguments to filter Output_targets to delete.
     * @example
     * // Delete a few Output_targets
     * const { count } = await prisma.output_target.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends output_targetDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, output_targetDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Output_targets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {output_targetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Output_targets
     * const output_target = await prisma.output_target.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends output_targetUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, output_targetUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Output_target.
     * @param {output_targetUpsertArgs} args - Arguments to update or create a Output_target.
     * @example
     * // Update or create a Output_target
     * const output_target = await prisma.output_target.upsert({
     *   create: {
     *     // ... data to create a Output_target
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Output_target we want to update
     *   }
     * })
    **/
    upsert<T extends output_targetUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, output_targetUpsertArgs<ExtArgs>>
    ): Prisma__output_targetClient<$Result.GetResult<Prisma.$output_targetPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Output_targets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {output_targetCountArgs} args - Arguments to filter Output_targets to count.
     * @example
     * // Count the number of Output_targets
     * const count = await prisma.output_target.count({
     *   where: {
     *     // ... the filter for the Output_targets we want to count
     *   }
     * })
    **/
    count<T extends output_targetCountArgs>(
      args?: Subset<T, output_targetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Output_targetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Output_target.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Output_targetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Output_targetAggregateArgs>(args: Subset<T, Output_targetAggregateArgs>): Prisma.PrismaPromise<GetOutput_targetAggregateType<T>>

    /**
     * Group by Output_target.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {output_targetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends output_targetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: output_targetGroupByArgs['orderBy'] }
        : { orderBy?: output_targetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, output_targetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOutput_targetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the output_target model
   */
  readonly fields: output_targetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for output_target.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__output_targetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the output_target model
   */ 
  interface output_targetFieldRefs {
    readonly id: FieldRef<"output_target", 'Int'>
    readonly output: FieldRef<"output_target", 'String'>
    readonly type: FieldRef<"output_target", 'String'>
    readonly waktu: FieldRef<"output_target", 'String'>
    readonly line: FieldRef<"output_target", 'String'>
    readonly timestamp: FieldRef<"output_target", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * output_target findUnique
   */
  export type output_targetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the output_target
     */
    select?: output_targetSelect<ExtArgs> | null
    /**
     * Filter, which output_target to fetch.
     */
    where: output_targetWhereUniqueInput
  }


  /**
   * output_target findUniqueOrThrow
   */
  export type output_targetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the output_target
     */
    select?: output_targetSelect<ExtArgs> | null
    /**
     * Filter, which output_target to fetch.
     */
    where: output_targetWhereUniqueInput
  }


  /**
   * output_target findFirst
   */
  export type output_targetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the output_target
     */
    select?: output_targetSelect<ExtArgs> | null
    /**
     * Filter, which output_target to fetch.
     */
    where?: output_targetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of output_targets to fetch.
     */
    orderBy?: output_targetOrderByWithRelationInput | output_targetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for output_targets.
     */
    cursor?: output_targetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` output_targets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` output_targets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of output_targets.
     */
    distinct?: Output_targetScalarFieldEnum | Output_targetScalarFieldEnum[]
  }


  /**
   * output_target findFirstOrThrow
   */
  export type output_targetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the output_target
     */
    select?: output_targetSelect<ExtArgs> | null
    /**
     * Filter, which output_target to fetch.
     */
    where?: output_targetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of output_targets to fetch.
     */
    orderBy?: output_targetOrderByWithRelationInput | output_targetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for output_targets.
     */
    cursor?: output_targetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` output_targets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` output_targets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of output_targets.
     */
    distinct?: Output_targetScalarFieldEnum | Output_targetScalarFieldEnum[]
  }


  /**
   * output_target findMany
   */
  export type output_targetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the output_target
     */
    select?: output_targetSelect<ExtArgs> | null
    /**
     * Filter, which output_targets to fetch.
     */
    where?: output_targetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of output_targets to fetch.
     */
    orderBy?: output_targetOrderByWithRelationInput | output_targetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing output_targets.
     */
    cursor?: output_targetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` output_targets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` output_targets.
     */
    skip?: number
    distinct?: Output_targetScalarFieldEnum | Output_targetScalarFieldEnum[]
  }


  /**
   * output_target create
   */
  export type output_targetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the output_target
     */
    select?: output_targetSelect<ExtArgs> | null
    /**
     * The data needed to create a output_target.
     */
    data: XOR<output_targetCreateInput, output_targetUncheckedCreateInput>
  }


  /**
   * output_target createMany
   */
  export type output_targetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many output_targets.
     */
    data: output_targetCreateManyInput | output_targetCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * output_target update
   */
  export type output_targetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the output_target
     */
    select?: output_targetSelect<ExtArgs> | null
    /**
     * The data needed to update a output_target.
     */
    data: XOR<output_targetUpdateInput, output_targetUncheckedUpdateInput>
    /**
     * Choose, which output_target to update.
     */
    where: output_targetWhereUniqueInput
  }


  /**
   * output_target updateMany
   */
  export type output_targetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update output_targets.
     */
    data: XOR<output_targetUpdateManyMutationInput, output_targetUncheckedUpdateManyInput>
    /**
     * Filter which output_targets to update
     */
    where?: output_targetWhereInput
  }


  /**
   * output_target upsert
   */
  export type output_targetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the output_target
     */
    select?: output_targetSelect<ExtArgs> | null
    /**
     * The filter to search for the output_target to update in case it exists.
     */
    where: output_targetWhereUniqueInput
    /**
     * In case the output_target found by the `where` argument doesn't exist, create a new output_target with this data.
     */
    create: XOR<output_targetCreateInput, output_targetUncheckedCreateInput>
    /**
     * In case the output_target was found with the provided `where` argument, update it with this data.
     */
    update: XOR<output_targetUpdateInput, output_targetUncheckedUpdateInput>
  }


  /**
   * output_target delete
   */
  export type output_targetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the output_target
     */
    select?: output_targetSelect<ExtArgs> | null
    /**
     * Filter which output_target to delete.
     */
    where: output_targetWhereUniqueInput
  }


  /**
   * output_target deleteMany
   */
  export type output_targetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which output_targets to delete
     */
    where?: output_targetWhereInput
  }


  /**
   * output_target without action
   */
  export type output_targetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the output_target
     */
    select?: output_targetSelect<ExtArgs> | null
  }



  /**
   * Model output_temp
   */

  export type AggregateOutput_temp = {
    _count: Output_tempCountAggregateOutputType | null
    _avg: Output_tempAvgAggregateOutputType | null
    _sum: Output_tempSumAggregateOutputType | null
    _min: Output_tempMinAggregateOutputType | null
    _max: Output_tempMaxAggregateOutputType | null
  }

  export type Output_tempAvgAggregateOutputType = {
    id: number | null
    total_output: number | null
    total_bigbox: number | null
    total_pallet: number | null
    target: number | null
    target_hour: number | null
    hour1: number | null
    hour2: number | null
    hour3: number | null
    hour4: number | null
    hour5: number | null
    hour6: number | null
    hour7: number | null
    hour8: number | null
    hour9: number | null
    hour10: number | null
    hour11: number | null
    hour12: number | null
  }

  export type Output_tempSumAggregateOutputType = {
    id: number | null
    total_output: number | null
    total_bigbox: number | null
    total_pallet: number | null
    target: number | null
    target_hour: number | null
    hour1: number | null
    hour2: number | null
    hour3: number | null
    hour4: number | null
    hour5: number | null
    hour6: number | null
    hour7: number | null
    hour8: number | null
    hour9: number | null
    hour10: number | null
    hour11: number | null
    hour12: number | null
  }

  export type Output_tempMinAggregateOutputType = {
    id: number | null
    type: string | null
    total_output: number | null
    line: string | null
    tahun: string | null
    timestamp: Date | null
    total_bigbox: number | null
    total_pallet: number | null
    target: number | null
    target_hour: number | null
    hour1: number | null
    hour2: number | null
    hour3: number | null
    hour4: number | null
    hour5: number | null
    hour6: number | null
    hour7: number | null
    hour8: number | null
    hour9: number | null
    hour10: number | null
    hour11: number | null
    hour12: number | null
  }

  export type Output_tempMaxAggregateOutputType = {
    id: number | null
    type: string | null
    total_output: number | null
    line: string | null
    tahun: string | null
    timestamp: Date | null
    total_bigbox: number | null
    total_pallet: number | null
    target: number | null
    target_hour: number | null
    hour1: number | null
    hour2: number | null
    hour3: number | null
    hour4: number | null
    hour5: number | null
    hour6: number | null
    hour7: number | null
    hour8: number | null
    hour9: number | null
    hour10: number | null
    hour11: number | null
    hour12: number | null
  }

  export type Output_tempCountAggregateOutputType = {
    id: number
    type: number
    total_output: number
    line: number
    tahun: number
    timestamp: number
    total_bigbox: number
    total_pallet: number
    target: number
    target_hour: number
    hour1: number
    hour2: number
    hour3: number
    hour4: number
    hour5: number
    hour6: number
    hour7: number
    hour8: number
    hour9: number
    hour10: number
    hour11: number
    hour12: number
    _all: number
  }


  export type Output_tempAvgAggregateInputType = {
    id?: true
    total_output?: true
    total_bigbox?: true
    total_pallet?: true
    target?: true
    target_hour?: true
    hour1?: true
    hour2?: true
    hour3?: true
    hour4?: true
    hour5?: true
    hour6?: true
    hour7?: true
    hour8?: true
    hour9?: true
    hour10?: true
    hour11?: true
    hour12?: true
  }

  export type Output_tempSumAggregateInputType = {
    id?: true
    total_output?: true
    total_bigbox?: true
    total_pallet?: true
    target?: true
    target_hour?: true
    hour1?: true
    hour2?: true
    hour3?: true
    hour4?: true
    hour5?: true
    hour6?: true
    hour7?: true
    hour8?: true
    hour9?: true
    hour10?: true
    hour11?: true
    hour12?: true
  }

  export type Output_tempMinAggregateInputType = {
    id?: true
    type?: true
    total_output?: true
    line?: true
    tahun?: true
    timestamp?: true
    total_bigbox?: true
    total_pallet?: true
    target?: true
    target_hour?: true
    hour1?: true
    hour2?: true
    hour3?: true
    hour4?: true
    hour5?: true
    hour6?: true
    hour7?: true
    hour8?: true
    hour9?: true
    hour10?: true
    hour11?: true
    hour12?: true
  }

  export type Output_tempMaxAggregateInputType = {
    id?: true
    type?: true
    total_output?: true
    line?: true
    tahun?: true
    timestamp?: true
    total_bigbox?: true
    total_pallet?: true
    target?: true
    target_hour?: true
    hour1?: true
    hour2?: true
    hour3?: true
    hour4?: true
    hour5?: true
    hour6?: true
    hour7?: true
    hour8?: true
    hour9?: true
    hour10?: true
    hour11?: true
    hour12?: true
  }

  export type Output_tempCountAggregateInputType = {
    id?: true
    type?: true
    total_output?: true
    line?: true
    tahun?: true
    timestamp?: true
    total_bigbox?: true
    total_pallet?: true
    target?: true
    target_hour?: true
    hour1?: true
    hour2?: true
    hour3?: true
    hour4?: true
    hour5?: true
    hour6?: true
    hour7?: true
    hour8?: true
    hour9?: true
    hour10?: true
    hour11?: true
    hour12?: true
    _all?: true
  }

  export type Output_tempAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which output_temp to aggregate.
     */
    where?: output_tempWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of output_temps to fetch.
     */
    orderBy?: output_tempOrderByWithRelationInput | output_tempOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: output_tempWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` output_temps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` output_temps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned output_temps
    **/
    _count?: true | Output_tempCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Output_tempAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Output_tempSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Output_tempMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Output_tempMaxAggregateInputType
  }

  export type GetOutput_tempAggregateType<T extends Output_tempAggregateArgs> = {
        [P in keyof T & keyof AggregateOutput_temp]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOutput_temp[P]>
      : GetScalarType<T[P], AggregateOutput_temp[P]>
  }




  export type output_tempGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: output_tempWhereInput
    orderBy?: output_tempOrderByWithAggregationInput | output_tempOrderByWithAggregationInput[]
    by: Output_tempScalarFieldEnum[] | Output_tempScalarFieldEnum
    having?: output_tempScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Output_tempCountAggregateInputType | true
    _avg?: Output_tempAvgAggregateInputType
    _sum?: Output_tempSumAggregateInputType
    _min?: Output_tempMinAggregateInputType
    _max?: Output_tempMaxAggregateInputType
  }

  export type Output_tempGroupByOutputType = {
    id: number
    type: string | null
    total_output: number
    line: string
    tahun: string | null
    timestamp: Date
    total_bigbox: number
    total_pallet: number
    target: number
    target_hour: number
    hour1: number
    hour2: number
    hour3: number
    hour4: number
    hour5: number
    hour6: number
    hour7: number
    hour8: number
    hour9: number
    hour10: number
    hour11: number
    hour12: number
    _count: Output_tempCountAggregateOutputType | null
    _avg: Output_tempAvgAggregateOutputType | null
    _sum: Output_tempSumAggregateOutputType | null
    _min: Output_tempMinAggregateOutputType | null
    _max: Output_tempMaxAggregateOutputType | null
  }

  type GetOutput_tempGroupByPayload<T extends output_tempGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Output_tempGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Output_tempGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Output_tempGroupByOutputType[P]>
            : GetScalarType<T[P], Output_tempGroupByOutputType[P]>
        }
      >
    >


  export type output_tempSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    total_output?: boolean
    line?: boolean
    tahun?: boolean
    timestamp?: boolean
    total_bigbox?: boolean
    total_pallet?: boolean
    target?: boolean
    target_hour?: boolean
    hour1?: boolean
    hour2?: boolean
    hour3?: boolean
    hour4?: boolean
    hour5?: boolean
    hour6?: boolean
    hour7?: boolean
    hour8?: boolean
    hour9?: boolean
    hour10?: boolean
    hour11?: boolean
    hour12?: boolean
  }, ExtArgs["result"]["output_temp"]>

  export type output_tempSelectScalar = {
    id?: boolean
    type?: boolean
    total_output?: boolean
    line?: boolean
    tahun?: boolean
    timestamp?: boolean
    total_bigbox?: boolean
    total_pallet?: boolean
    target?: boolean
    target_hour?: boolean
    hour1?: boolean
    hour2?: boolean
    hour3?: boolean
    hour4?: boolean
    hour5?: boolean
    hour6?: boolean
    hour7?: boolean
    hour8?: boolean
    hour9?: boolean
    hour10?: boolean
    hour11?: boolean
    hour12?: boolean
  }


  export type $output_tempPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "output_temp"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      type: string | null
      total_output: number
      line: string
      tahun: string | null
      timestamp: Date
      total_bigbox: number
      total_pallet: number
      target: number
      target_hour: number
      hour1: number
      hour2: number
      hour3: number
      hour4: number
      hour5: number
      hour6: number
      hour7: number
      hour8: number
      hour9: number
      hour10: number
      hour11: number
      hour12: number
    }, ExtArgs["result"]["output_temp"]>
    composites: {}
  }


  type output_tempGetPayload<S extends boolean | null | undefined | output_tempDefaultArgs> = $Result.GetResult<Prisma.$output_tempPayload, S>

  type output_tempCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<output_tempFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Output_tempCountAggregateInputType | true
    }

  export interface output_tempDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['output_temp'], meta: { name: 'output_temp' } }
    /**
     * Find zero or one Output_temp that matches the filter.
     * @param {output_tempFindUniqueArgs} args - Arguments to find a Output_temp
     * @example
     * // Get one Output_temp
     * const output_temp = await prisma.output_temp.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends output_tempFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, output_tempFindUniqueArgs<ExtArgs>>
    ): Prisma__output_tempClient<$Result.GetResult<Prisma.$output_tempPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Output_temp that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {output_tempFindUniqueOrThrowArgs} args - Arguments to find a Output_temp
     * @example
     * // Get one Output_temp
     * const output_temp = await prisma.output_temp.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends output_tempFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, output_tempFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__output_tempClient<$Result.GetResult<Prisma.$output_tempPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Output_temp that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {output_tempFindFirstArgs} args - Arguments to find a Output_temp
     * @example
     * // Get one Output_temp
     * const output_temp = await prisma.output_temp.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends output_tempFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, output_tempFindFirstArgs<ExtArgs>>
    ): Prisma__output_tempClient<$Result.GetResult<Prisma.$output_tempPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Output_temp that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {output_tempFindFirstOrThrowArgs} args - Arguments to find a Output_temp
     * @example
     * // Get one Output_temp
     * const output_temp = await prisma.output_temp.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends output_tempFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, output_tempFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__output_tempClient<$Result.GetResult<Prisma.$output_tempPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Output_temps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {output_tempFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Output_temps
     * const output_temps = await prisma.output_temp.findMany()
     * 
     * // Get first 10 Output_temps
     * const output_temps = await prisma.output_temp.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const output_tempWithIdOnly = await prisma.output_temp.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends output_tempFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, output_tempFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$output_tempPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Output_temp.
     * @param {output_tempCreateArgs} args - Arguments to create a Output_temp.
     * @example
     * // Create one Output_temp
     * const Output_temp = await prisma.output_temp.create({
     *   data: {
     *     // ... data to create a Output_temp
     *   }
     * })
     * 
    **/
    create<T extends output_tempCreateArgs<ExtArgs>>(
      args: SelectSubset<T, output_tempCreateArgs<ExtArgs>>
    ): Prisma__output_tempClient<$Result.GetResult<Prisma.$output_tempPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Output_temps.
     *     @param {output_tempCreateManyArgs} args - Arguments to create many Output_temps.
     *     @example
     *     // Create many Output_temps
     *     const output_temp = await prisma.output_temp.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends output_tempCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, output_tempCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Output_temp.
     * @param {output_tempDeleteArgs} args - Arguments to delete one Output_temp.
     * @example
     * // Delete one Output_temp
     * const Output_temp = await prisma.output_temp.delete({
     *   where: {
     *     // ... filter to delete one Output_temp
     *   }
     * })
     * 
    **/
    delete<T extends output_tempDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, output_tempDeleteArgs<ExtArgs>>
    ): Prisma__output_tempClient<$Result.GetResult<Prisma.$output_tempPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Output_temp.
     * @param {output_tempUpdateArgs} args - Arguments to update one Output_temp.
     * @example
     * // Update one Output_temp
     * const output_temp = await prisma.output_temp.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends output_tempUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, output_tempUpdateArgs<ExtArgs>>
    ): Prisma__output_tempClient<$Result.GetResult<Prisma.$output_tempPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Output_temps.
     * @param {output_tempDeleteManyArgs} args - Arguments to filter Output_temps to delete.
     * @example
     * // Delete a few Output_temps
     * const { count } = await prisma.output_temp.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends output_tempDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, output_tempDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Output_temps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {output_tempUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Output_temps
     * const output_temp = await prisma.output_temp.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends output_tempUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, output_tempUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Output_temp.
     * @param {output_tempUpsertArgs} args - Arguments to update or create a Output_temp.
     * @example
     * // Update or create a Output_temp
     * const output_temp = await prisma.output_temp.upsert({
     *   create: {
     *     // ... data to create a Output_temp
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Output_temp we want to update
     *   }
     * })
    **/
    upsert<T extends output_tempUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, output_tempUpsertArgs<ExtArgs>>
    ): Prisma__output_tempClient<$Result.GetResult<Prisma.$output_tempPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Output_temps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {output_tempCountArgs} args - Arguments to filter Output_temps to count.
     * @example
     * // Count the number of Output_temps
     * const count = await prisma.output_temp.count({
     *   where: {
     *     // ... the filter for the Output_temps we want to count
     *   }
     * })
    **/
    count<T extends output_tempCountArgs>(
      args?: Subset<T, output_tempCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Output_tempCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Output_temp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Output_tempAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Output_tempAggregateArgs>(args: Subset<T, Output_tempAggregateArgs>): Prisma.PrismaPromise<GetOutput_tempAggregateType<T>>

    /**
     * Group by Output_temp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {output_tempGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends output_tempGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: output_tempGroupByArgs['orderBy'] }
        : { orderBy?: output_tempGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, output_tempGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOutput_tempGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the output_temp model
   */
  readonly fields: output_tempFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for output_temp.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__output_tempClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the output_temp model
   */ 
  interface output_tempFieldRefs {
    readonly id: FieldRef<"output_temp", 'Int'>
    readonly type: FieldRef<"output_temp", 'String'>
    readonly total_output: FieldRef<"output_temp", 'Int'>
    readonly line: FieldRef<"output_temp", 'String'>
    readonly tahun: FieldRef<"output_temp", 'String'>
    readonly timestamp: FieldRef<"output_temp", 'DateTime'>
    readonly total_bigbox: FieldRef<"output_temp", 'Int'>
    readonly total_pallet: FieldRef<"output_temp", 'Int'>
    readonly target: FieldRef<"output_temp", 'Int'>
    readonly target_hour: FieldRef<"output_temp", 'Int'>
    readonly hour1: FieldRef<"output_temp", 'Int'>
    readonly hour2: FieldRef<"output_temp", 'Int'>
    readonly hour3: FieldRef<"output_temp", 'Int'>
    readonly hour4: FieldRef<"output_temp", 'Int'>
    readonly hour5: FieldRef<"output_temp", 'Int'>
    readonly hour6: FieldRef<"output_temp", 'Int'>
    readonly hour7: FieldRef<"output_temp", 'Int'>
    readonly hour8: FieldRef<"output_temp", 'Int'>
    readonly hour9: FieldRef<"output_temp", 'Int'>
    readonly hour10: FieldRef<"output_temp", 'Int'>
    readonly hour11: FieldRef<"output_temp", 'Int'>
    readonly hour12: FieldRef<"output_temp", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * output_temp findUnique
   */
  export type output_tempFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the output_temp
     */
    select?: output_tempSelect<ExtArgs> | null
    /**
     * Filter, which output_temp to fetch.
     */
    where: output_tempWhereUniqueInput
  }


  /**
   * output_temp findUniqueOrThrow
   */
  export type output_tempFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the output_temp
     */
    select?: output_tempSelect<ExtArgs> | null
    /**
     * Filter, which output_temp to fetch.
     */
    where: output_tempWhereUniqueInput
  }


  /**
   * output_temp findFirst
   */
  export type output_tempFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the output_temp
     */
    select?: output_tempSelect<ExtArgs> | null
    /**
     * Filter, which output_temp to fetch.
     */
    where?: output_tempWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of output_temps to fetch.
     */
    orderBy?: output_tempOrderByWithRelationInput | output_tempOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for output_temps.
     */
    cursor?: output_tempWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` output_temps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` output_temps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of output_temps.
     */
    distinct?: Output_tempScalarFieldEnum | Output_tempScalarFieldEnum[]
  }


  /**
   * output_temp findFirstOrThrow
   */
  export type output_tempFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the output_temp
     */
    select?: output_tempSelect<ExtArgs> | null
    /**
     * Filter, which output_temp to fetch.
     */
    where?: output_tempWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of output_temps to fetch.
     */
    orderBy?: output_tempOrderByWithRelationInput | output_tempOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for output_temps.
     */
    cursor?: output_tempWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` output_temps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` output_temps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of output_temps.
     */
    distinct?: Output_tempScalarFieldEnum | Output_tempScalarFieldEnum[]
  }


  /**
   * output_temp findMany
   */
  export type output_tempFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the output_temp
     */
    select?: output_tempSelect<ExtArgs> | null
    /**
     * Filter, which output_temps to fetch.
     */
    where?: output_tempWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of output_temps to fetch.
     */
    orderBy?: output_tempOrderByWithRelationInput | output_tempOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing output_temps.
     */
    cursor?: output_tempWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` output_temps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` output_temps.
     */
    skip?: number
    distinct?: Output_tempScalarFieldEnum | Output_tempScalarFieldEnum[]
  }


  /**
   * output_temp create
   */
  export type output_tempCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the output_temp
     */
    select?: output_tempSelect<ExtArgs> | null
    /**
     * The data needed to create a output_temp.
     */
    data: XOR<output_tempCreateInput, output_tempUncheckedCreateInput>
  }


  /**
   * output_temp createMany
   */
  export type output_tempCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many output_temps.
     */
    data: output_tempCreateManyInput | output_tempCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * output_temp update
   */
  export type output_tempUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the output_temp
     */
    select?: output_tempSelect<ExtArgs> | null
    /**
     * The data needed to update a output_temp.
     */
    data: XOR<output_tempUpdateInput, output_tempUncheckedUpdateInput>
    /**
     * Choose, which output_temp to update.
     */
    where: output_tempWhereUniqueInput
  }


  /**
   * output_temp updateMany
   */
  export type output_tempUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update output_temps.
     */
    data: XOR<output_tempUpdateManyMutationInput, output_tempUncheckedUpdateManyInput>
    /**
     * Filter which output_temps to update
     */
    where?: output_tempWhereInput
  }


  /**
   * output_temp upsert
   */
  export type output_tempUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the output_temp
     */
    select?: output_tempSelect<ExtArgs> | null
    /**
     * The filter to search for the output_temp to update in case it exists.
     */
    where: output_tempWhereUniqueInput
    /**
     * In case the output_temp found by the `where` argument doesn't exist, create a new output_temp with this data.
     */
    create: XOR<output_tempCreateInput, output_tempUncheckedCreateInput>
    /**
     * In case the output_temp was found with the provided `where` argument, update it with this data.
     */
    update: XOR<output_tempUpdateInput, output_tempUncheckedUpdateInput>
  }


  /**
   * output_temp delete
   */
  export type output_tempDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the output_temp
     */
    select?: output_tempSelect<ExtArgs> | null
    /**
     * Filter which output_temp to delete.
     */
    where: output_tempWhereUniqueInput
  }


  /**
   * output_temp deleteMany
   */
  export type output_tempDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which output_temps to delete
     */
    where?: output_tempWhereInput
  }


  /**
   * output_temp without action
   */
  export type output_tempDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the output_temp
     */
    select?: output_tempSelect<ExtArgs> | null
  }



  /**
   * Model pallete
   */

  export type AggregatePallete = {
    _count: PalleteCountAggregateOutputType | null
    _avg: PalleteAvgAggregateOutputType | null
    _sum: PalleteSumAggregateOutputType | null
    _min: PalleteMinAggregateOutputType | null
    _max: PalleteMaxAggregateOutputType | null
  }

  export type PalleteAvgAggregateOutputType = {
    id: number | null
  }

  export type PalleteSumAggregateOutputType = {
    id: number | null
  }

  export type PalleteMinAggregateOutputType = {
    id: number | null
    serial: string | null
    timestamp: Date | null
    line: string | null
    type: string | null
    location: string | null
  }

  export type PalleteMaxAggregateOutputType = {
    id: number | null
    serial: string | null
    timestamp: Date | null
    line: string | null
    type: string | null
    location: string | null
  }

  export type PalleteCountAggregateOutputType = {
    id: number
    serial: number
    timestamp: number
    line: number
    type: number
    location: number
    _all: number
  }


  export type PalleteAvgAggregateInputType = {
    id?: true
  }

  export type PalleteSumAggregateInputType = {
    id?: true
  }

  export type PalleteMinAggregateInputType = {
    id?: true
    serial?: true
    timestamp?: true
    line?: true
    type?: true
    location?: true
  }

  export type PalleteMaxAggregateInputType = {
    id?: true
    serial?: true
    timestamp?: true
    line?: true
    type?: true
    location?: true
  }

  export type PalleteCountAggregateInputType = {
    id?: true
    serial?: true
    timestamp?: true
    line?: true
    type?: true
    location?: true
    _all?: true
  }

  export type PalleteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which pallete to aggregate.
     */
    where?: palleteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of palletes to fetch.
     */
    orderBy?: palleteOrderByWithRelationInput | palleteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: palleteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` palletes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` palletes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned palletes
    **/
    _count?: true | PalleteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PalleteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PalleteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PalleteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PalleteMaxAggregateInputType
  }

  export type GetPalleteAggregateType<T extends PalleteAggregateArgs> = {
        [P in keyof T & keyof AggregatePallete]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePallete[P]>
      : GetScalarType<T[P], AggregatePallete[P]>
  }




  export type palleteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: palleteWhereInput
    orderBy?: palleteOrderByWithAggregationInput | palleteOrderByWithAggregationInput[]
    by: PalleteScalarFieldEnum[] | PalleteScalarFieldEnum
    having?: palleteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PalleteCountAggregateInputType | true
    _avg?: PalleteAvgAggregateInputType
    _sum?: PalleteSumAggregateInputType
    _min?: PalleteMinAggregateInputType
    _max?: PalleteMaxAggregateInputType
  }

  export type PalleteGroupByOutputType = {
    id: number
    serial: string
    timestamp: Date
    line: string
    type: string
    location: string
    _count: PalleteCountAggregateOutputType | null
    _avg: PalleteAvgAggregateOutputType | null
    _sum: PalleteSumAggregateOutputType | null
    _min: PalleteMinAggregateOutputType | null
    _max: PalleteMaxAggregateOutputType | null
  }

  type GetPalleteGroupByPayload<T extends palleteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PalleteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PalleteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PalleteGroupByOutputType[P]>
            : GetScalarType<T[P], PalleteGroupByOutputType[P]>
        }
      >
    >


  export type palleteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serial?: boolean
    timestamp?: boolean
    line?: boolean
    type?: boolean
    location?: boolean
  }, ExtArgs["result"]["pallete"]>

  export type palleteSelectScalar = {
    id?: boolean
    serial?: boolean
    timestamp?: boolean
    line?: boolean
    type?: boolean
    location?: boolean
  }


  export type $palletePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "pallete"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      serial: string
      timestamp: Date
      line: string
      type: string
      location: string
    }, ExtArgs["result"]["pallete"]>
    composites: {}
  }


  type palleteGetPayload<S extends boolean | null | undefined | palleteDefaultArgs> = $Result.GetResult<Prisma.$palletePayload, S>

  type palleteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<palleteFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PalleteCountAggregateInputType | true
    }

  export interface palleteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['pallete'], meta: { name: 'pallete' } }
    /**
     * Find zero or one Pallete that matches the filter.
     * @param {palleteFindUniqueArgs} args - Arguments to find a Pallete
     * @example
     * // Get one Pallete
     * const pallete = await prisma.pallete.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends palleteFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, palleteFindUniqueArgs<ExtArgs>>
    ): Prisma__palleteClient<$Result.GetResult<Prisma.$palletePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Pallete that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {palleteFindUniqueOrThrowArgs} args - Arguments to find a Pallete
     * @example
     * // Get one Pallete
     * const pallete = await prisma.pallete.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends palleteFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, palleteFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__palleteClient<$Result.GetResult<Prisma.$palletePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Pallete that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {palleteFindFirstArgs} args - Arguments to find a Pallete
     * @example
     * // Get one Pallete
     * const pallete = await prisma.pallete.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends palleteFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, palleteFindFirstArgs<ExtArgs>>
    ): Prisma__palleteClient<$Result.GetResult<Prisma.$palletePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Pallete that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {palleteFindFirstOrThrowArgs} args - Arguments to find a Pallete
     * @example
     * // Get one Pallete
     * const pallete = await prisma.pallete.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends palleteFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, palleteFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__palleteClient<$Result.GetResult<Prisma.$palletePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Palletes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {palleteFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Palletes
     * const palletes = await prisma.pallete.findMany()
     * 
     * // Get first 10 Palletes
     * const palletes = await prisma.pallete.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const palleteWithIdOnly = await prisma.pallete.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends palleteFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, palleteFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$palletePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Pallete.
     * @param {palleteCreateArgs} args - Arguments to create a Pallete.
     * @example
     * // Create one Pallete
     * const Pallete = await prisma.pallete.create({
     *   data: {
     *     // ... data to create a Pallete
     *   }
     * })
     * 
    **/
    create<T extends palleteCreateArgs<ExtArgs>>(
      args: SelectSubset<T, palleteCreateArgs<ExtArgs>>
    ): Prisma__palleteClient<$Result.GetResult<Prisma.$palletePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Palletes.
     *     @param {palleteCreateManyArgs} args - Arguments to create many Palletes.
     *     @example
     *     // Create many Palletes
     *     const pallete = await prisma.pallete.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends palleteCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, palleteCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Pallete.
     * @param {palleteDeleteArgs} args - Arguments to delete one Pallete.
     * @example
     * // Delete one Pallete
     * const Pallete = await prisma.pallete.delete({
     *   where: {
     *     // ... filter to delete one Pallete
     *   }
     * })
     * 
    **/
    delete<T extends palleteDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, palleteDeleteArgs<ExtArgs>>
    ): Prisma__palleteClient<$Result.GetResult<Prisma.$palletePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Pallete.
     * @param {palleteUpdateArgs} args - Arguments to update one Pallete.
     * @example
     * // Update one Pallete
     * const pallete = await prisma.pallete.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends palleteUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, palleteUpdateArgs<ExtArgs>>
    ): Prisma__palleteClient<$Result.GetResult<Prisma.$palletePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Palletes.
     * @param {palleteDeleteManyArgs} args - Arguments to filter Palletes to delete.
     * @example
     * // Delete a few Palletes
     * const { count } = await prisma.pallete.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends palleteDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, palleteDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Palletes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {palleteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Palletes
     * const pallete = await prisma.pallete.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends palleteUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, palleteUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Pallete.
     * @param {palleteUpsertArgs} args - Arguments to update or create a Pallete.
     * @example
     * // Update or create a Pallete
     * const pallete = await prisma.pallete.upsert({
     *   create: {
     *     // ... data to create a Pallete
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pallete we want to update
     *   }
     * })
    **/
    upsert<T extends palleteUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, palleteUpsertArgs<ExtArgs>>
    ): Prisma__palleteClient<$Result.GetResult<Prisma.$palletePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Palletes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {palleteCountArgs} args - Arguments to filter Palletes to count.
     * @example
     * // Count the number of Palletes
     * const count = await prisma.pallete.count({
     *   where: {
     *     // ... the filter for the Palletes we want to count
     *   }
     * })
    **/
    count<T extends palleteCountArgs>(
      args?: Subset<T, palleteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PalleteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pallete.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PalleteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PalleteAggregateArgs>(args: Subset<T, PalleteAggregateArgs>): Prisma.PrismaPromise<GetPalleteAggregateType<T>>

    /**
     * Group by Pallete.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {palleteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends palleteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: palleteGroupByArgs['orderBy'] }
        : { orderBy?: palleteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, palleteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPalleteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the pallete model
   */
  readonly fields: palleteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for pallete.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__palleteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the pallete model
   */ 
  interface palleteFieldRefs {
    readonly id: FieldRef<"pallete", 'Int'>
    readonly serial: FieldRef<"pallete", 'String'>
    readonly timestamp: FieldRef<"pallete", 'DateTime'>
    readonly line: FieldRef<"pallete", 'String'>
    readonly type: FieldRef<"pallete", 'String'>
    readonly location: FieldRef<"pallete", 'String'>
  }
    

  // Custom InputTypes

  /**
   * pallete findUnique
   */
  export type palleteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pallete
     */
    select?: palleteSelect<ExtArgs> | null
    /**
     * Filter, which pallete to fetch.
     */
    where: palleteWhereUniqueInput
  }


  /**
   * pallete findUniqueOrThrow
   */
  export type palleteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pallete
     */
    select?: palleteSelect<ExtArgs> | null
    /**
     * Filter, which pallete to fetch.
     */
    where: palleteWhereUniqueInput
  }


  /**
   * pallete findFirst
   */
  export type palleteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pallete
     */
    select?: palleteSelect<ExtArgs> | null
    /**
     * Filter, which pallete to fetch.
     */
    where?: palleteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of palletes to fetch.
     */
    orderBy?: palleteOrderByWithRelationInput | palleteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for palletes.
     */
    cursor?: palleteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` palletes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` palletes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of palletes.
     */
    distinct?: PalleteScalarFieldEnum | PalleteScalarFieldEnum[]
  }


  /**
   * pallete findFirstOrThrow
   */
  export type palleteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pallete
     */
    select?: palleteSelect<ExtArgs> | null
    /**
     * Filter, which pallete to fetch.
     */
    where?: palleteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of palletes to fetch.
     */
    orderBy?: palleteOrderByWithRelationInput | palleteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for palletes.
     */
    cursor?: palleteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` palletes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` palletes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of palletes.
     */
    distinct?: PalleteScalarFieldEnum | PalleteScalarFieldEnum[]
  }


  /**
   * pallete findMany
   */
  export type palleteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pallete
     */
    select?: palleteSelect<ExtArgs> | null
    /**
     * Filter, which palletes to fetch.
     */
    where?: palleteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of palletes to fetch.
     */
    orderBy?: palleteOrderByWithRelationInput | palleteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing palletes.
     */
    cursor?: palleteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` palletes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` palletes.
     */
    skip?: number
    distinct?: PalleteScalarFieldEnum | PalleteScalarFieldEnum[]
  }


  /**
   * pallete create
   */
  export type palleteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pallete
     */
    select?: palleteSelect<ExtArgs> | null
    /**
     * The data needed to create a pallete.
     */
    data: XOR<palleteCreateInput, palleteUncheckedCreateInput>
  }


  /**
   * pallete createMany
   */
  export type palleteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many palletes.
     */
    data: palleteCreateManyInput | palleteCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * pallete update
   */
  export type palleteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pallete
     */
    select?: palleteSelect<ExtArgs> | null
    /**
     * The data needed to update a pallete.
     */
    data: XOR<palleteUpdateInput, palleteUncheckedUpdateInput>
    /**
     * Choose, which pallete to update.
     */
    where: palleteWhereUniqueInput
  }


  /**
   * pallete updateMany
   */
  export type palleteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update palletes.
     */
    data: XOR<palleteUpdateManyMutationInput, palleteUncheckedUpdateManyInput>
    /**
     * Filter which palletes to update
     */
    where?: palleteWhereInput
  }


  /**
   * pallete upsert
   */
  export type palleteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pallete
     */
    select?: palleteSelect<ExtArgs> | null
    /**
     * The filter to search for the pallete to update in case it exists.
     */
    where: palleteWhereUniqueInput
    /**
     * In case the pallete found by the `where` argument doesn't exist, create a new pallete with this data.
     */
    create: XOR<palleteCreateInput, palleteUncheckedCreateInput>
    /**
     * In case the pallete was found with the provided `where` argument, update it with this data.
     */
    update: XOR<palleteUpdateInput, palleteUncheckedUpdateInput>
  }


  /**
   * pallete delete
   */
  export type palleteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pallete
     */
    select?: palleteSelect<ExtArgs> | null
    /**
     * Filter which pallete to delete.
     */
    where: palleteWhereUniqueInput
  }


  /**
   * pallete deleteMany
   */
  export type palleteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which palletes to delete
     */
    where?: palleteWhereInput
  }


  /**
   * pallete without action
   */
  export type palleteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pallete
     */
    select?: palleteSelect<ExtArgs> | null
  }



  /**
   * Model pln_code
   */

  export type AggregatePln_code = {
    _count: Pln_codeCountAggregateOutputType | null
    _avg: Pln_codeAvgAggregateOutputType | null
    _sum: Pln_codeSumAggregateOutputType | null
    _min: Pln_codeMinAggregateOutputType | null
    _max: Pln_codeMaxAggregateOutputType | null
  }

  export type Pln_codeAvgAggregateOutputType = {
    id: number | null
  }

  export type Pln_codeSumAggregateOutputType = {
    id: number | null
  }

  export type Pln_codeMinAggregateOutputType = {
    id: number | null
    value: string | null
  }

  export type Pln_codeMaxAggregateOutputType = {
    id: number | null
    value: string | null
  }

  export type Pln_codeCountAggregateOutputType = {
    id: number
    value: number
    _all: number
  }


  export type Pln_codeAvgAggregateInputType = {
    id?: true
  }

  export type Pln_codeSumAggregateInputType = {
    id?: true
  }

  export type Pln_codeMinAggregateInputType = {
    id?: true
    value?: true
  }

  export type Pln_codeMaxAggregateInputType = {
    id?: true
    value?: true
  }

  export type Pln_codeCountAggregateInputType = {
    id?: true
    value?: true
    _all?: true
  }

  export type Pln_codeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which pln_code to aggregate.
     */
    where?: pln_codeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pln_codes to fetch.
     */
    orderBy?: pln_codeOrderByWithRelationInput | pln_codeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: pln_codeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pln_codes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pln_codes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned pln_codes
    **/
    _count?: true | Pln_codeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Pln_codeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Pln_codeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Pln_codeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Pln_codeMaxAggregateInputType
  }

  export type GetPln_codeAggregateType<T extends Pln_codeAggregateArgs> = {
        [P in keyof T & keyof AggregatePln_code]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePln_code[P]>
      : GetScalarType<T[P], AggregatePln_code[P]>
  }




  export type pln_codeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: pln_codeWhereInput
    orderBy?: pln_codeOrderByWithAggregationInput | pln_codeOrderByWithAggregationInput[]
    by: Pln_codeScalarFieldEnum[] | Pln_codeScalarFieldEnum
    having?: pln_codeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Pln_codeCountAggregateInputType | true
    _avg?: Pln_codeAvgAggregateInputType
    _sum?: Pln_codeSumAggregateInputType
    _min?: Pln_codeMinAggregateInputType
    _max?: Pln_codeMaxAggregateInputType
  }

  export type Pln_codeGroupByOutputType = {
    id: number
    value: string
    _count: Pln_codeCountAggregateOutputType | null
    _avg: Pln_codeAvgAggregateOutputType | null
    _sum: Pln_codeSumAggregateOutputType | null
    _min: Pln_codeMinAggregateOutputType | null
    _max: Pln_codeMaxAggregateOutputType | null
  }

  type GetPln_codeGroupByPayload<T extends pln_codeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Pln_codeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Pln_codeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Pln_codeGroupByOutputType[P]>
            : GetScalarType<T[P], Pln_codeGroupByOutputType[P]>
        }
      >
    >


  export type pln_codeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
  }, ExtArgs["result"]["pln_code"]>

  export type pln_codeSelectScalar = {
    id?: boolean
    value?: boolean
  }


  export type $pln_codePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "pln_code"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      value: string
    }, ExtArgs["result"]["pln_code"]>
    composites: {}
  }


  type pln_codeGetPayload<S extends boolean | null | undefined | pln_codeDefaultArgs> = $Result.GetResult<Prisma.$pln_codePayload, S>

  type pln_codeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<pln_codeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Pln_codeCountAggregateInputType | true
    }

  export interface pln_codeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['pln_code'], meta: { name: 'pln_code' } }
    /**
     * Find zero or one Pln_code that matches the filter.
     * @param {pln_codeFindUniqueArgs} args - Arguments to find a Pln_code
     * @example
     * // Get one Pln_code
     * const pln_code = await prisma.pln_code.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends pln_codeFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, pln_codeFindUniqueArgs<ExtArgs>>
    ): Prisma__pln_codeClient<$Result.GetResult<Prisma.$pln_codePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Pln_code that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {pln_codeFindUniqueOrThrowArgs} args - Arguments to find a Pln_code
     * @example
     * // Get one Pln_code
     * const pln_code = await prisma.pln_code.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends pln_codeFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, pln_codeFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__pln_codeClient<$Result.GetResult<Prisma.$pln_codePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Pln_code that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pln_codeFindFirstArgs} args - Arguments to find a Pln_code
     * @example
     * // Get one Pln_code
     * const pln_code = await prisma.pln_code.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends pln_codeFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, pln_codeFindFirstArgs<ExtArgs>>
    ): Prisma__pln_codeClient<$Result.GetResult<Prisma.$pln_codePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Pln_code that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pln_codeFindFirstOrThrowArgs} args - Arguments to find a Pln_code
     * @example
     * // Get one Pln_code
     * const pln_code = await prisma.pln_code.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends pln_codeFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, pln_codeFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__pln_codeClient<$Result.GetResult<Prisma.$pln_codePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Pln_codes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pln_codeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pln_codes
     * const pln_codes = await prisma.pln_code.findMany()
     * 
     * // Get first 10 Pln_codes
     * const pln_codes = await prisma.pln_code.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pln_codeWithIdOnly = await prisma.pln_code.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends pln_codeFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, pln_codeFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pln_codePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Pln_code.
     * @param {pln_codeCreateArgs} args - Arguments to create a Pln_code.
     * @example
     * // Create one Pln_code
     * const Pln_code = await prisma.pln_code.create({
     *   data: {
     *     // ... data to create a Pln_code
     *   }
     * })
     * 
    **/
    create<T extends pln_codeCreateArgs<ExtArgs>>(
      args: SelectSubset<T, pln_codeCreateArgs<ExtArgs>>
    ): Prisma__pln_codeClient<$Result.GetResult<Prisma.$pln_codePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Pln_codes.
     *     @param {pln_codeCreateManyArgs} args - Arguments to create many Pln_codes.
     *     @example
     *     // Create many Pln_codes
     *     const pln_code = await prisma.pln_code.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends pln_codeCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, pln_codeCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Pln_code.
     * @param {pln_codeDeleteArgs} args - Arguments to delete one Pln_code.
     * @example
     * // Delete one Pln_code
     * const Pln_code = await prisma.pln_code.delete({
     *   where: {
     *     // ... filter to delete one Pln_code
     *   }
     * })
     * 
    **/
    delete<T extends pln_codeDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, pln_codeDeleteArgs<ExtArgs>>
    ): Prisma__pln_codeClient<$Result.GetResult<Prisma.$pln_codePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Pln_code.
     * @param {pln_codeUpdateArgs} args - Arguments to update one Pln_code.
     * @example
     * // Update one Pln_code
     * const pln_code = await prisma.pln_code.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends pln_codeUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, pln_codeUpdateArgs<ExtArgs>>
    ): Prisma__pln_codeClient<$Result.GetResult<Prisma.$pln_codePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Pln_codes.
     * @param {pln_codeDeleteManyArgs} args - Arguments to filter Pln_codes to delete.
     * @example
     * // Delete a few Pln_codes
     * const { count } = await prisma.pln_code.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends pln_codeDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, pln_codeDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pln_codes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pln_codeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pln_codes
     * const pln_code = await prisma.pln_code.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends pln_codeUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, pln_codeUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Pln_code.
     * @param {pln_codeUpsertArgs} args - Arguments to update or create a Pln_code.
     * @example
     * // Update or create a Pln_code
     * const pln_code = await prisma.pln_code.upsert({
     *   create: {
     *     // ... data to create a Pln_code
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pln_code we want to update
     *   }
     * })
    **/
    upsert<T extends pln_codeUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, pln_codeUpsertArgs<ExtArgs>>
    ): Prisma__pln_codeClient<$Result.GetResult<Prisma.$pln_codePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Pln_codes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pln_codeCountArgs} args - Arguments to filter Pln_codes to count.
     * @example
     * // Count the number of Pln_codes
     * const count = await prisma.pln_code.count({
     *   where: {
     *     // ... the filter for the Pln_codes we want to count
     *   }
     * })
    **/
    count<T extends pln_codeCountArgs>(
      args?: Subset<T, pln_codeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Pln_codeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pln_code.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Pln_codeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Pln_codeAggregateArgs>(args: Subset<T, Pln_codeAggregateArgs>): Prisma.PrismaPromise<GetPln_codeAggregateType<T>>

    /**
     * Group by Pln_code.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pln_codeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends pln_codeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: pln_codeGroupByArgs['orderBy'] }
        : { orderBy?: pln_codeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, pln_codeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPln_codeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the pln_code model
   */
  readonly fields: pln_codeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for pln_code.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__pln_codeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the pln_code model
   */ 
  interface pln_codeFieldRefs {
    readonly id: FieldRef<"pln_code", 'Int'>
    readonly value: FieldRef<"pln_code", 'String'>
  }
    

  // Custom InputTypes

  /**
   * pln_code findUnique
   */
  export type pln_codeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pln_code
     */
    select?: pln_codeSelect<ExtArgs> | null
    /**
     * Filter, which pln_code to fetch.
     */
    where: pln_codeWhereUniqueInput
  }


  /**
   * pln_code findUniqueOrThrow
   */
  export type pln_codeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pln_code
     */
    select?: pln_codeSelect<ExtArgs> | null
    /**
     * Filter, which pln_code to fetch.
     */
    where: pln_codeWhereUniqueInput
  }


  /**
   * pln_code findFirst
   */
  export type pln_codeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pln_code
     */
    select?: pln_codeSelect<ExtArgs> | null
    /**
     * Filter, which pln_code to fetch.
     */
    where?: pln_codeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pln_codes to fetch.
     */
    orderBy?: pln_codeOrderByWithRelationInput | pln_codeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pln_codes.
     */
    cursor?: pln_codeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pln_codes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pln_codes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pln_codes.
     */
    distinct?: Pln_codeScalarFieldEnum | Pln_codeScalarFieldEnum[]
  }


  /**
   * pln_code findFirstOrThrow
   */
  export type pln_codeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pln_code
     */
    select?: pln_codeSelect<ExtArgs> | null
    /**
     * Filter, which pln_code to fetch.
     */
    where?: pln_codeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pln_codes to fetch.
     */
    orderBy?: pln_codeOrderByWithRelationInput | pln_codeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pln_codes.
     */
    cursor?: pln_codeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pln_codes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pln_codes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pln_codes.
     */
    distinct?: Pln_codeScalarFieldEnum | Pln_codeScalarFieldEnum[]
  }


  /**
   * pln_code findMany
   */
  export type pln_codeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pln_code
     */
    select?: pln_codeSelect<ExtArgs> | null
    /**
     * Filter, which pln_codes to fetch.
     */
    where?: pln_codeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pln_codes to fetch.
     */
    orderBy?: pln_codeOrderByWithRelationInput | pln_codeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing pln_codes.
     */
    cursor?: pln_codeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pln_codes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pln_codes.
     */
    skip?: number
    distinct?: Pln_codeScalarFieldEnum | Pln_codeScalarFieldEnum[]
  }


  /**
   * pln_code create
   */
  export type pln_codeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pln_code
     */
    select?: pln_codeSelect<ExtArgs> | null
    /**
     * The data needed to create a pln_code.
     */
    data: XOR<pln_codeCreateInput, pln_codeUncheckedCreateInput>
  }


  /**
   * pln_code createMany
   */
  export type pln_codeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many pln_codes.
     */
    data: pln_codeCreateManyInput | pln_codeCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * pln_code update
   */
  export type pln_codeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pln_code
     */
    select?: pln_codeSelect<ExtArgs> | null
    /**
     * The data needed to update a pln_code.
     */
    data: XOR<pln_codeUpdateInput, pln_codeUncheckedUpdateInput>
    /**
     * Choose, which pln_code to update.
     */
    where: pln_codeWhereUniqueInput
  }


  /**
   * pln_code updateMany
   */
  export type pln_codeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update pln_codes.
     */
    data: XOR<pln_codeUpdateManyMutationInput, pln_codeUncheckedUpdateManyInput>
    /**
     * Filter which pln_codes to update
     */
    where?: pln_codeWhereInput
  }


  /**
   * pln_code upsert
   */
  export type pln_codeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pln_code
     */
    select?: pln_codeSelect<ExtArgs> | null
    /**
     * The filter to search for the pln_code to update in case it exists.
     */
    where: pln_codeWhereUniqueInput
    /**
     * In case the pln_code found by the `where` argument doesn't exist, create a new pln_code with this data.
     */
    create: XOR<pln_codeCreateInput, pln_codeUncheckedCreateInput>
    /**
     * In case the pln_code was found with the provided `where` argument, update it with this data.
     */
    update: XOR<pln_codeUpdateInput, pln_codeUncheckedUpdateInput>
  }


  /**
   * pln_code delete
   */
  export type pln_codeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pln_code
     */
    select?: pln_codeSelect<ExtArgs> | null
    /**
     * Filter which pln_code to delete.
     */
    where: pln_codeWhereUniqueInput
  }


  /**
   * pln_code deleteMany
   */
  export type pln_codeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which pln_codes to delete
     */
    where?: pln_codeWhereInput
  }


  /**
   * pln_code without action
   */
  export type pln_codeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pln_code
     */
    select?: pln_codeSelect<ExtArgs> | null
  }



  /**
   * Model product
   */

  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductAvgAggregateOutputType = {
    id: number | null
    box_id: number | null
    attachment_id: number | null
    attachment2_id: number | null
  }

  export type ProductSumAggregateOutputType = {
    id: number | null
    box_id: number | null
    attachment_id: number | null
    attachment2_id: number | null
  }

  export type ProductMinAggregateOutputType = {
    id: number | null
    serial: string | null
    module_serial: string | null
    timestamp: Date | null
    line: string | null
    type: string | null
    orderno: string | null
    area: string | null
    jenis: string | null
    box_id: number | null
    attachment_id: number | null
    attachment2_id: number | null
    remain: string | null
    garansi: string | null
  }

  export type ProductMaxAggregateOutputType = {
    id: number | null
    serial: string | null
    module_serial: string | null
    timestamp: Date | null
    line: string | null
    type: string | null
    orderno: string | null
    area: string | null
    jenis: string | null
    box_id: number | null
    attachment_id: number | null
    attachment2_id: number | null
    remain: string | null
    garansi: string | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    serial: number
    module_serial: number
    timestamp: number
    line: number
    type: number
    orderno: number
    area: number
    jenis: number
    box_id: number
    attachment_id: number
    attachment2_id: number
    remain: number
    garansi: number
    _all: number
  }


  export type ProductAvgAggregateInputType = {
    id?: true
    box_id?: true
    attachment_id?: true
    attachment2_id?: true
  }

  export type ProductSumAggregateInputType = {
    id?: true
    box_id?: true
    attachment_id?: true
    attachment2_id?: true
  }

  export type ProductMinAggregateInputType = {
    id?: true
    serial?: true
    module_serial?: true
    timestamp?: true
    line?: true
    type?: true
    orderno?: true
    area?: true
    jenis?: true
    box_id?: true
    attachment_id?: true
    attachment2_id?: true
    remain?: true
    garansi?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    serial?: true
    module_serial?: true
    timestamp?: true
    line?: true
    type?: true
    orderno?: true
    area?: true
    jenis?: true
    box_id?: true
    attachment_id?: true
    attachment2_id?: true
    remain?: true
    garansi?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    serial?: true
    module_serial?: true
    timestamp?: true
    line?: true
    type?: true
    orderno?: true
    area?: true
    jenis?: true
    box_id?: true
    attachment_id?: true
    attachment2_id?: true
    remain?: true
    garansi?: true
    _all?: true
  }

  export type ProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which product to aggregate.
     */
    where?: productWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of products to fetch.
     */
    orderBy?: productOrderByWithRelationInput | productOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: productWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type productGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: productWhereInput
    orderBy?: productOrderByWithAggregationInput | productOrderByWithAggregationInput[]
    by: ProductScalarFieldEnum[] | ProductScalarFieldEnum
    having?: productScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _avg?: ProductAvgAggregateInputType
    _sum?: ProductSumAggregateInputType
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }

  export type ProductGroupByOutputType = {
    id: number
    serial: string
    module_serial: string | null
    timestamp: Date
    line: string
    type: string
    orderno: string
    area: string | null
    jenis: string | null
    box_id: number | null
    attachment_id: number | null
    attachment2_id: number | null
    remain: string
    garansi: string | null
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends productGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type productSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serial?: boolean
    module_serial?: boolean
    timestamp?: boolean
    line?: boolean
    type?: boolean
    orderno?: boolean
    area?: boolean
    jenis?: boolean
    box_id?: boolean
    attachment_id?: boolean
    attachment2_id?: boolean
    remain?: boolean
    garansi?: boolean
  }, ExtArgs["result"]["product"]>

  export type productSelectScalar = {
    id?: boolean
    serial?: boolean
    module_serial?: boolean
    timestamp?: boolean
    line?: boolean
    type?: boolean
    orderno?: boolean
    area?: boolean
    jenis?: boolean
    box_id?: boolean
    attachment_id?: boolean
    attachment2_id?: boolean
    remain?: boolean
    garansi?: boolean
  }


  export type $productPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "product"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      serial: string
      module_serial: string | null
      timestamp: Date
      line: string
      type: string
      orderno: string
      area: string | null
      jenis: string | null
      box_id: number | null
      attachment_id: number | null
      attachment2_id: number | null
      remain: string
      garansi: string | null
    }, ExtArgs["result"]["product"]>
    composites: {}
  }


  type productGetPayload<S extends boolean | null | undefined | productDefaultArgs> = $Result.GetResult<Prisma.$productPayload, S>

  type productCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<productFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProductCountAggregateInputType | true
    }

  export interface productDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['product'], meta: { name: 'product' } }
    /**
     * Find zero or one Product that matches the filter.
     * @param {productFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends productFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, productFindUniqueArgs<ExtArgs>>
    ): Prisma__productClient<$Result.GetResult<Prisma.$productPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Product that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {productFindUniqueOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends productFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, productFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__productClient<$Result.GetResult<Prisma.$productPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends productFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, productFindFirstArgs<ExtArgs>>
    ): Prisma__productClient<$Result.GetResult<Prisma.$productPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Product that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productFindFirstOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends productFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, productFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__productClient<$Result.GetResult<Prisma.$productPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends productFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, productFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$productPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Product.
     * @param {productCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
    **/
    create<T extends productCreateArgs<ExtArgs>>(
      args: SelectSubset<T, productCreateArgs<ExtArgs>>
    ): Prisma__productClient<$Result.GetResult<Prisma.$productPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Products.
     *     @param {productCreateManyArgs} args - Arguments to create many Products.
     *     @example
     *     // Create many Products
     *     const product = await prisma.product.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends productCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, productCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Product.
     * @param {productDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
    **/
    delete<T extends productDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, productDeleteArgs<ExtArgs>>
    ): Prisma__productClient<$Result.GetResult<Prisma.$productPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Product.
     * @param {productUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends productUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, productUpdateArgs<ExtArgs>>
    ): Prisma__productClient<$Result.GetResult<Prisma.$productPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Products.
     * @param {productDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends productDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, productDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends productUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, productUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Product.
     * @param {productUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
    **/
    upsert<T extends productUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, productUpsertArgs<ExtArgs>>
    ): Prisma__productClient<$Result.GetResult<Prisma.$productPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends productCountArgs>(
      args?: Subset<T, productCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): Prisma.PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends productGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: productGroupByArgs['orderBy'] }
        : { orderBy?: productGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, productGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the product model
   */
  readonly fields: productFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__productClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the product model
   */ 
  interface productFieldRefs {
    readonly id: FieldRef<"product", 'Int'>
    readonly serial: FieldRef<"product", 'String'>
    readonly module_serial: FieldRef<"product", 'String'>
    readonly timestamp: FieldRef<"product", 'DateTime'>
    readonly line: FieldRef<"product", 'String'>
    readonly type: FieldRef<"product", 'String'>
    readonly orderno: FieldRef<"product", 'String'>
    readonly area: FieldRef<"product", 'String'>
    readonly jenis: FieldRef<"product", 'String'>
    readonly box_id: FieldRef<"product", 'Int'>
    readonly attachment_id: FieldRef<"product", 'Int'>
    readonly attachment2_id: FieldRef<"product", 'Int'>
    readonly remain: FieldRef<"product", 'String'>
    readonly garansi: FieldRef<"product", 'String'>
  }
    

  // Custom InputTypes

  /**
   * product findUnique
   */
  export type productFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect<ExtArgs> | null
    /**
     * Filter, which product to fetch.
     */
    where: productWhereUniqueInput
  }


  /**
   * product findUniqueOrThrow
   */
  export type productFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect<ExtArgs> | null
    /**
     * Filter, which product to fetch.
     */
    where: productWhereUniqueInput
  }


  /**
   * product findFirst
   */
  export type productFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect<ExtArgs> | null
    /**
     * Filter, which product to fetch.
     */
    where?: productWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of products to fetch.
     */
    orderBy?: productOrderByWithRelationInput | productOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for products.
     */
    cursor?: productWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }


  /**
   * product findFirstOrThrow
   */
  export type productFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect<ExtArgs> | null
    /**
     * Filter, which product to fetch.
     */
    where?: productWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of products to fetch.
     */
    orderBy?: productOrderByWithRelationInput | productOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for products.
     */
    cursor?: productWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }


  /**
   * product findMany
   */
  export type productFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect<ExtArgs> | null
    /**
     * Filter, which products to fetch.
     */
    where?: productWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of products to fetch.
     */
    orderBy?: productOrderByWithRelationInput | productOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing products.
     */
    cursor?: productWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` products.
     */
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }


  /**
   * product create
   */
  export type productCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect<ExtArgs> | null
    /**
     * The data needed to create a product.
     */
    data: XOR<productCreateInput, productUncheckedCreateInput>
  }


  /**
   * product createMany
   */
  export type productCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many products.
     */
    data: productCreateManyInput | productCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * product update
   */
  export type productUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect<ExtArgs> | null
    /**
     * The data needed to update a product.
     */
    data: XOR<productUpdateInput, productUncheckedUpdateInput>
    /**
     * Choose, which product to update.
     */
    where: productWhereUniqueInput
  }


  /**
   * product updateMany
   */
  export type productUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update products.
     */
    data: XOR<productUpdateManyMutationInput, productUncheckedUpdateManyInput>
    /**
     * Filter which products to update
     */
    where?: productWhereInput
  }


  /**
   * product upsert
   */
  export type productUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect<ExtArgs> | null
    /**
     * The filter to search for the product to update in case it exists.
     */
    where: productWhereUniqueInput
    /**
     * In case the product found by the `where` argument doesn't exist, create a new product with this data.
     */
    create: XOR<productCreateInput, productUncheckedCreateInput>
    /**
     * In case the product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<productUpdateInput, productUncheckedUpdateInput>
  }


  /**
   * product delete
   */
  export type productDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect<ExtArgs> | null
    /**
     * Filter which product to delete.
     */
    where: productWhereUniqueInput
  }


  /**
   * product deleteMany
   */
  export type productDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which products to delete
     */
    where?: productWhereInput
  }


  /**
   * product without action
   */
  export type productDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect<ExtArgs> | null
  }



  /**
   * Model production_ng
   */

  export type AggregateProduction_ng = {
    _count: Production_ngCountAggregateOutputType | null
    _avg: Production_ngAvgAggregateOutputType | null
    _sum: Production_ngSumAggregateOutputType | null
    _min: Production_ngMinAggregateOutputType | null
    _max: Production_ngMaxAggregateOutputType | null
  }

  export type Production_ngAvgAggregateOutputType = {
    id: number | null
  }

  export type Production_ngSumAggregateOutputType = {
    id: number | null
  }

  export type Production_ngMinAggregateOutputType = {
    id: number | null
    meter_type: string | null
    serial: string | null
    tanggal: Date | null
    station: string | null
    line: string | null
    defect: string | null
    category: string | null
    department: string | null
    action: string | null
    keterangan: string | null
    update_date: Date | null
    user: string | null
  }

  export type Production_ngMaxAggregateOutputType = {
    id: number | null
    meter_type: string | null
    serial: string | null
    tanggal: Date | null
    station: string | null
    line: string | null
    defect: string | null
    category: string | null
    department: string | null
    action: string | null
    keterangan: string | null
    update_date: Date | null
    user: string | null
  }

  export type Production_ngCountAggregateOutputType = {
    id: number
    meter_type: number
    serial: number
    tanggal: number
    station: number
    line: number
    defect: number
    category: number
    department: number
    action: number
    keterangan: number
    update_date: number
    user: number
    _all: number
  }


  export type Production_ngAvgAggregateInputType = {
    id?: true
  }

  export type Production_ngSumAggregateInputType = {
    id?: true
  }

  export type Production_ngMinAggregateInputType = {
    id?: true
    meter_type?: true
    serial?: true
    tanggal?: true
    station?: true
    line?: true
    defect?: true
    category?: true
    department?: true
    action?: true
    keterangan?: true
    update_date?: true
    user?: true
  }

  export type Production_ngMaxAggregateInputType = {
    id?: true
    meter_type?: true
    serial?: true
    tanggal?: true
    station?: true
    line?: true
    defect?: true
    category?: true
    department?: true
    action?: true
    keterangan?: true
    update_date?: true
    user?: true
  }

  export type Production_ngCountAggregateInputType = {
    id?: true
    meter_type?: true
    serial?: true
    tanggal?: true
    station?: true
    line?: true
    defect?: true
    category?: true
    department?: true
    action?: true
    keterangan?: true
    update_date?: true
    user?: true
    _all?: true
  }

  export type Production_ngAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which production_ng to aggregate.
     */
    where?: production_ngWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of production_ngs to fetch.
     */
    orderBy?: production_ngOrderByWithRelationInput | production_ngOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: production_ngWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` production_ngs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` production_ngs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned production_ngs
    **/
    _count?: true | Production_ngCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Production_ngAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Production_ngSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Production_ngMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Production_ngMaxAggregateInputType
  }

  export type GetProduction_ngAggregateType<T extends Production_ngAggregateArgs> = {
        [P in keyof T & keyof AggregateProduction_ng]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduction_ng[P]>
      : GetScalarType<T[P], AggregateProduction_ng[P]>
  }




  export type production_ngGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: production_ngWhereInput
    orderBy?: production_ngOrderByWithAggregationInput | production_ngOrderByWithAggregationInput[]
    by: Production_ngScalarFieldEnum[] | Production_ngScalarFieldEnum
    having?: production_ngScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Production_ngCountAggregateInputType | true
    _avg?: Production_ngAvgAggregateInputType
    _sum?: Production_ngSumAggregateInputType
    _min?: Production_ngMinAggregateInputType
    _max?: Production_ngMaxAggregateInputType
  }

  export type Production_ngGroupByOutputType = {
    id: number
    meter_type: string
    serial: string
    tanggal: Date
    station: string
    line: string
    defect: string
    category: string | null
    department: string | null
    action: string | null
    keterangan: string | null
    update_date: Date | null
    user: string | null
    _count: Production_ngCountAggregateOutputType | null
    _avg: Production_ngAvgAggregateOutputType | null
    _sum: Production_ngSumAggregateOutputType | null
    _min: Production_ngMinAggregateOutputType | null
    _max: Production_ngMaxAggregateOutputType | null
  }

  type GetProduction_ngGroupByPayload<T extends production_ngGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Production_ngGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Production_ngGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Production_ngGroupByOutputType[P]>
            : GetScalarType<T[P], Production_ngGroupByOutputType[P]>
        }
      >
    >


  export type production_ngSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    meter_type?: boolean
    serial?: boolean
    tanggal?: boolean
    station?: boolean
    line?: boolean
    defect?: boolean
    category?: boolean
    department?: boolean
    action?: boolean
    keterangan?: boolean
    update_date?: boolean
    user?: boolean
  }, ExtArgs["result"]["production_ng"]>

  export type production_ngSelectScalar = {
    id?: boolean
    meter_type?: boolean
    serial?: boolean
    tanggal?: boolean
    station?: boolean
    line?: boolean
    defect?: boolean
    category?: boolean
    department?: boolean
    action?: boolean
    keterangan?: boolean
    update_date?: boolean
    user?: boolean
  }


  export type $production_ngPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "production_ng"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      meter_type: string
      serial: string
      tanggal: Date
      station: string
      line: string
      defect: string
      category: string | null
      department: string | null
      action: string | null
      keterangan: string | null
      update_date: Date | null
      user: string | null
    }, ExtArgs["result"]["production_ng"]>
    composites: {}
  }


  type production_ngGetPayload<S extends boolean | null | undefined | production_ngDefaultArgs> = $Result.GetResult<Prisma.$production_ngPayload, S>

  type production_ngCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<production_ngFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Production_ngCountAggregateInputType | true
    }

  export interface production_ngDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['production_ng'], meta: { name: 'production_ng' } }
    /**
     * Find zero or one Production_ng that matches the filter.
     * @param {production_ngFindUniqueArgs} args - Arguments to find a Production_ng
     * @example
     * // Get one Production_ng
     * const production_ng = await prisma.production_ng.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends production_ngFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, production_ngFindUniqueArgs<ExtArgs>>
    ): Prisma__production_ngClient<$Result.GetResult<Prisma.$production_ngPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Production_ng that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {production_ngFindUniqueOrThrowArgs} args - Arguments to find a Production_ng
     * @example
     * // Get one Production_ng
     * const production_ng = await prisma.production_ng.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends production_ngFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, production_ngFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__production_ngClient<$Result.GetResult<Prisma.$production_ngPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Production_ng that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {production_ngFindFirstArgs} args - Arguments to find a Production_ng
     * @example
     * // Get one Production_ng
     * const production_ng = await prisma.production_ng.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends production_ngFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, production_ngFindFirstArgs<ExtArgs>>
    ): Prisma__production_ngClient<$Result.GetResult<Prisma.$production_ngPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Production_ng that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {production_ngFindFirstOrThrowArgs} args - Arguments to find a Production_ng
     * @example
     * // Get one Production_ng
     * const production_ng = await prisma.production_ng.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends production_ngFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, production_ngFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__production_ngClient<$Result.GetResult<Prisma.$production_ngPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Production_ngs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {production_ngFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Production_ngs
     * const production_ngs = await prisma.production_ng.findMany()
     * 
     * // Get first 10 Production_ngs
     * const production_ngs = await prisma.production_ng.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const production_ngWithIdOnly = await prisma.production_ng.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends production_ngFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, production_ngFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$production_ngPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Production_ng.
     * @param {production_ngCreateArgs} args - Arguments to create a Production_ng.
     * @example
     * // Create one Production_ng
     * const Production_ng = await prisma.production_ng.create({
     *   data: {
     *     // ... data to create a Production_ng
     *   }
     * })
     * 
    **/
    create<T extends production_ngCreateArgs<ExtArgs>>(
      args: SelectSubset<T, production_ngCreateArgs<ExtArgs>>
    ): Prisma__production_ngClient<$Result.GetResult<Prisma.$production_ngPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Production_ngs.
     *     @param {production_ngCreateManyArgs} args - Arguments to create many Production_ngs.
     *     @example
     *     // Create many Production_ngs
     *     const production_ng = await prisma.production_ng.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends production_ngCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, production_ngCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Production_ng.
     * @param {production_ngDeleteArgs} args - Arguments to delete one Production_ng.
     * @example
     * // Delete one Production_ng
     * const Production_ng = await prisma.production_ng.delete({
     *   where: {
     *     // ... filter to delete one Production_ng
     *   }
     * })
     * 
    **/
    delete<T extends production_ngDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, production_ngDeleteArgs<ExtArgs>>
    ): Prisma__production_ngClient<$Result.GetResult<Prisma.$production_ngPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Production_ng.
     * @param {production_ngUpdateArgs} args - Arguments to update one Production_ng.
     * @example
     * // Update one Production_ng
     * const production_ng = await prisma.production_ng.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends production_ngUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, production_ngUpdateArgs<ExtArgs>>
    ): Prisma__production_ngClient<$Result.GetResult<Prisma.$production_ngPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Production_ngs.
     * @param {production_ngDeleteManyArgs} args - Arguments to filter Production_ngs to delete.
     * @example
     * // Delete a few Production_ngs
     * const { count } = await prisma.production_ng.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends production_ngDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, production_ngDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Production_ngs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {production_ngUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Production_ngs
     * const production_ng = await prisma.production_ng.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends production_ngUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, production_ngUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Production_ng.
     * @param {production_ngUpsertArgs} args - Arguments to update or create a Production_ng.
     * @example
     * // Update or create a Production_ng
     * const production_ng = await prisma.production_ng.upsert({
     *   create: {
     *     // ... data to create a Production_ng
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Production_ng we want to update
     *   }
     * })
    **/
    upsert<T extends production_ngUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, production_ngUpsertArgs<ExtArgs>>
    ): Prisma__production_ngClient<$Result.GetResult<Prisma.$production_ngPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Production_ngs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {production_ngCountArgs} args - Arguments to filter Production_ngs to count.
     * @example
     * // Count the number of Production_ngs
     * const count = await prisma.production_ng.count({
     *   where: {
     *     // ... the filter for the Production_ngs we want to count
     *   }
     * })
    **/
    count<T extends production_ngCountArgs>(
      args?: Subset<T, production_ngCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Production_ngCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Production_ng.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Production_ngAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Production_ngAggregateArgs>(args: Subset<T, Production_ngAggregateArgs>): Prisma.PrismaPromise<GetProduction_ngAggregateType<T>>

    /**
     * Group by Production_ng.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {production_ngGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends production_ngGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: production_ngGroupByArgs['orderBy'] }
        : { orderBy?: production_ngGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, production_ngGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProduction_ngGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the production_ng model
   */
  readonly fields: production_ngFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for production_ng.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__production_ngClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the production_ng model
   */ 
  interface production_ngFieldRefs {
    readonly id: FieldRef<"production_ng", 'Int'>
    readonly meter_type: FieldRef<"production_ng", 'String'>
    readonly serial: FieldRef<"production_ng", 'String'>
    readonly tanggal: FieldRef<"production_ng", 'DateTime'>
    readonly station: FieldRef<"production_ng", 'String'>
    readonly line: FieldRef<"production_ng", 'String'>
    readonly defect: FieldRef<"production_ng", 'String'>
    readonly category: FieldRef<"production_ng", 'String'>
    readonly department: FieldRef<"production_ng", 'String'>
    readonly action: FieldRef<"production_ng", 'String'>
    readonly keterangan: FieldRef<"production_ng", 'String'>
    readonly update_date: FieldRef<"production_ng", 'DateTime'>
    readonly user: FieldRef<"production_ng", 'String'>
  }
    

  // Custom InputTypes

  /**
   * production_ng findUnique
   */
  export type production_ngFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the production_ng
     */
    select?: production_ngSelect<ExtArgs> | null
    /**
     * Filter, which production_ng to fetch.
     */
    where: production_ngWhereUniqueInput
  }


  /**
   * production_ng findUniqueOrThrow
   */
  export type production_ngFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the production_ng
     */
    select?: production_ngSelect<ExtArgs> | null
    /**
     * Filter, which production_ng to fetch.
     */
    where: production_ngWhereUniqueInput
  }


  /**
   * production_ng findFirst
   */
  export type production_ngFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the production_ng
     */
    select?: production_ngSelect<ExtArgs> | null
    /**
     * Filter, which production_ng to fetch.
     */
    where?: production_ngWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of production_ngs to fetch.
     */
    orderBy?: production_ngOrderByWithRelationInput | production_ngOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for production_ngs.
     */
    cursor?: production_ngWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` production_ngs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` production_ngs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of production_ngs.
     */
    distinct?: Production_ngScalarFieldEnum | Production_ngScalarFieldEnum[]
  }


  /**
   * production_ng findFirstOrThrow
   */
  export type production_ngFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the production_ng
     */
    select?: production_ngSelect<ExtArgs> | null
    /**
     * Filter, which production_ng to fetch.
     */
    where?: production_ngWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of production_ngs to fetch.
     */
    orderBy?: production_ngOrderByWithRelationInput | production_ngOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for production_ngs.
     */
    cursor?: production_ngWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` production_ngs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` production_ngs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of production_ngs.
     */
    distinct?: Production_ngScalarFieldEnum | Production_ngScalarFieldEnum[]
  }


  /**
   * production_ng findMany
   */
  export type production_ngFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the production_ng
     */
    select?: production_ngSelect<ExtArgs> | null
    /**
     * Filter, which production_ngs to fetch.
     */
    where?: production_ngWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of production_ngs to fetch.
     */
    orderBy?: production_ngOrderByWithRelationInput | production_ngOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing production_ngs.
     */
    cursor?: production_ngWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` production_ngs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` production_ngs.
     */
    skip?: number
    distinct?: Production_ngScalarFieldEnum | Production_ngScalarFieldEnum[]
  }


  /**
   * production_ng create
   */
  export type production_ngCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the production_ng
     */
    select?: production_ngSelect<ExtArgs> | null
    /**
     * The data needed to create a production_ng.
     */
    data: XOR<production_ngCreateInput, production_ngUncheckedCreateInput>
  }


  /**
   * production_ng createMany
   */
  export type production_ngCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many production_ngs.
     */
    data: production_ngCreateManyInput | production_ngCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * production_ng update
   */
  export type production_ngUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the production_ng
     */
    select?: production_ngSelect<ExtArgs> | null
    /**
     * The data needed to update a production_ng.
     */
    data: XOR<production_ngUpdateInput, production_ngUncheckedUpdateInput>
    /**
     * Choose, which production_ng to update.
     */
    where: production_ngWhereUniqueInput
  }


  /**
   * production_ng updateMany
   */
  export type production_ngUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update production_ngs.
     */
    data: XOR<production_ngUpdateManyMutationInput, production_ngUncheckedUpdateManyInput>
    /**
     * Filter which production_ngs to update
     */
    where?: production_ngWhereInput
  }


  /**
   * production_ng upsert
   */
  export type production_ngUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the production_ng
     */
    select?: production_ngSelect<ExtArgs> | null
    /**
     * The filter to search for the production_ng to update in case it exists.
     */
    where: production_ngWhereUniqueInput
    /**
     * In case the production_ng found by the `where` argument doesn't exist, create a new production_ng with this data.
     */
    create: XOR<production_ngCreateInput, production_ngUncheckedCreateInput>
    /**
     * In case the production_ng was found with the provided `where` argument, update it with this data.
     */
    update: XOR<production_ngUpdateInput, production_ngUncheckedUpdateInput>
  }


  /**
   * production_ng delete
   */
  export type production_ngDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the production_ng
     */
    select?: production_ngSelect<ExtArgs> | null
    /**
     * Filter which production_ng to delete.
     */
    where: production_ngWhereUniqueInput
  }


  /**
   * production_ng deleteMany
   */
  export type production_ngDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which production_ngs to delete
     */
    where?: production_ngWhereInput
  }


  /**
   * production_ng without action
   */
  export type production_ngDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the production_ng
     */
    select?: production_ngSelect<ExtArgs> | null
  }



  /**
   * Model productionorder
   */

  export type AggregateProductionorder = {
    _count: ProductionorderCountAggregateOutputType | null
    _avg: ProductionorderAvgAggregateOutputType | null
    _sum: ProductionorderSumAggregateOutputType | null
    _min: ProductionorderMinAggregateOutputType | null
    _max: ProductionorderMaxAggregateOutputType | null
  }

  export type ProductionorderAvgAggregateOutputType = {
    id: number | null
    qty: number | null
    status: number | null
    keterangan: number | null
  }

  export type ProductionorderSumAggregateOutputType = {
    id: number | null
    qty: number | null
    status: number | null
    keterangan: number | null
  }

  export type ProductionorderMinAggregateOutputType = {
    id: number | null
    timestamp: Date | null
    ponum: string | null
    area: string | null
    provinsi: string | null
    count_qty: string | null
    qty: number | null
    status: number | null
    keterangan: number | null
  }

  export type ProductionorderMaxAggregateOutputType = {
    id: number | null
    timestamp: Date | null
    ponum: string | null
    area: string | null
    provinsi: string | null
    count_qty: string | null
    qty: number | null
    status: number | null
    keterangan: number | null
  }

  export type ProductionorderCountAggregateOutputType = {
    id: number
    timestamp: number
    ponum: number
    area: number
    provinsi: number
    count_qty: number
    qty: number
    status: number
    keterangan: number
    _all: number
  }


  export type ProductionorderAvgAggregateInputType = {
    id?: true
    qty?: true
    status?: true
    keterangan?: true
  }

  export type ProductionorderSumAggregateInputType = {
    id?: true
    qty?: true
    status?: true
    keterangan?: true
  }

  export type ProductionorderMinAggregateInputType = {
    id?: true
    timestamp?: true
    ponum?: true
    area?: true
    provinsi?: true
    count_qty?: true
    qty?: true
    status?: true
    keterangan?: true
  }

  export type ProductionorderMaxAggregateInputType = {
    id?: true
    timestamp?: true
    ponum?: true
    area?: true
    provinsi?: true
    count_qty?: true
    qty?: true
    status?: true
    keterangan?: true
  }

  export type ProductionorderCountAggregateInputType = {
    id?: true
    timestamp?: true
    ponum?: true
    area?: true
    provinsi?: true
    count_qty?: true
    qty?: true
    status?: true
    keterangan?: true
    _all?: true
  }

  export type ProductionorderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which productionorder to aggregate.
     */
    where?: productionorderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of productionorders to fetch.
     */
    orderBy?: productionorderOrderByWithRelationInput | productionorderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: productionorderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` productionorders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` productionorders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned productionorders
    **/
    _count?: true | ProductionorderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductionorderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductionorderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductionorderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductionorderMaxAggregateInputType
  }

  export type GetProductionorderAggregateType<T extends ProductionorderAggregateArgs> = {
        [P in keyof T & keyof AggregateProductionorder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductionorder[P]>
      : GetScalarType<T[P], AggregateProductionorder[P]>
  }




  export type productionorderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: productionorderWhereInput
    orderBy?: productionorderOrderByWithAggregationInput | productionorderOrderByWithAggregationInput[]
    by: ProductionorderScalarFieldEnum[] | ProductionorderScalarFieldEnum
    having?: productionorderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductionorderCountAggregateInputType | true
    _avg?: ProductionorderAvgAggregateInputType
    _sum?: ProductionorderSumAggregateInputType
    _min?: ProductionorderMinAggregateInputType
    _max?: ProductionorderMaxAggregateInputType
  }

  export type ProductionorderGroupByOutputType = {
    id: number
    timestamp: Date
    ponum: string
    area: string
    provinsi: string
    count_qty: string
    qty: number
    status: number
    keterangan: number | null
    _count: ProductionorderCountAggregateOutputType | null
    _avg: ProductionorderAvgAggregateOutputType | null
    _sum: ProductionorderSumAggregateOutputType | null
    _min: ProductionorderMinAggregateOutputType | null
    _max: ProductionorderMaxAggregateOutputType | null
  }

  type GetProductionorderGroupByPayload<T extends productionorderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductionorderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductionorderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductionorderGroupByOutputType[P]>
            : GetScalarType<T[P], ProductionorderGroupByOutputType[P]>
        }
      >
    >


  export type productionorderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    timestamp?: boolean
    ponum?: boolean
    area?: boolean
    provinsi?: boolean
    count_qty?: boolean
    qty?: boolean
    status?: boolean
    keterangan?: boolean
  }, ExtArgs["result"]["productionorder"]>

  export type productionorderSelectScalar = {
    id?: boolean
    timestamp?: boolean
    ponum?: boolean
    area?: boolean
    provinsi?: boolean
    count_qty?: boolean
    qty?: boolean
    status?: boolean
    keterangan?: boolean
  }


  export type $productionorderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "productionorder"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      timestamp: Date
      ponum: string
      area: string
      provinsi: string
      count_qty: string
      qty: number
      status: number
      keterangan: number | null
    }, ExtArgs["result"]["productionorder"]>
    composites: {}
  }


  type productionorderGetPayload<S extends boolean | null | undefined | productionorderDefaultArgs> = $Result.GetResult<Prisma.$productionorderPayload, S>

  type productionorderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<productionorderFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProductionorderCountAggregateInputType | true
    }

  export interface productionorderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['productionorder'], meta: { name: 'productionorder' } }
    /**
     * Find zero or one Productionorder that matches the filter.
     * @param {productionorderFindUniqueArgs} args - Arguments to find a Productionorder
     * @example
     * // Get one Productionorder
     * const productionorder = await prisma.productionorder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends productionorderFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, productionorderFindUniqueArgs<ExtArgs>>
    ): Prisma__productionorderClient<$Result.GetResult<Prisma.$productionorderPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Productionorder that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {productionorderFindUniqueOrThrowArgs} args - Arguments to find a Productionorder
     * @example
     * // Get one Productionorder
     * const productionorder = await prisma.productionorder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends productionorderFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, productionorderFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__productionorderClient<$Result.GetResult<Prisma.$productionorderPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Productionorder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productionorderFindFirstArgs} args - Arguments to find a Productionorder
     * @example
     * // Get one Productionorder
     * const productionorder = await prisma.productionorder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends productionorderFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, productionorderFindFirstArgs<ExtArgs>>
    ): Prisma__productionorderClient<$Result.GetResult<Prisma.$productionorderPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Productionorder that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productionorderFindFirstOrThrowArgs} args - Arguments to find a Productionorder
     * @example
     * // Get one Productionorder
     * const productionorder = await prisma.productionorder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends productionorderFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, productionorderFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__productionorderClient<$Result.GetResult<Prisma.$productionorderPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Productionorders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productionorderFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Productionorders
     * const productionorders = await prisma.productionorder.findMany()
     * 
     * // Get first 10 Productionorders
     * const productionorders = await prisma.productionorder.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productionorderWithIdOnly = await prisma.productionorder.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends productionorderFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, productionorderFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$productionorderPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Productionorder.
     * @param {productionorderCreateArgs} args - Arguments to create a Productionorder.
     * @example
     * // Create one Productionorder
     * const Productionorder = await prisma.productionorder.create({
     *   data: {
     *     // ... data to create a Productionorder
     *   }
     * })
     * 
    **/
    create<T extends productionorderCreateArgs<ExtArgs>>(
      args: SelectSubset<T, productionorderCreateArgs<ExtArgs>>
    ): Prisma__productionorderClient<$Result.GetResult<Prisma.$productionorderPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Productionorders.
     *     @param {productionorderCreateManyArgs} args - Arguments to create many Productionorders.
     *     @example
     *     // Create many Productionorders
     *     const productionorder = await prisma.productionorder.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends productionorderCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, productionorderCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Productionorder.
     * @param {productionorderDeleteArgs} args - Arguments to delete one Productionorder.
     * @example
     * // Delete one Productionorder
     * const Productionorder = await prisma.productionorder.delete({
     *   where: {
     *     // ... filter to delete one Productionorder
     *   }
     * })
     * 
    **/
    delete<T extends productionorderDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, productionorderDeleteArgs<ExtArgs>>
    ): Prisma__productionorderClient<$Result.GetResult<Prisma.$productionorderPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Productionorder.
     * @param {productionorderUpdateArgs} args - Arguments to update one Productionorder.
     * @example
     * // Update one Productionorder
     * const productionorder = await prisma.productionorder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends productionorderUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, productionorderUpdateArgs<ExtArgs>>
    ): Prisma__productionorderClient<$Result.GetResult<Prisma.$productionorderPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Productionorders.
     * @param {productionorderDeleteManyArgs} args - Arguments to filter Productionorders to delete.
     * @example
     * // Delete a few Productionorders
     * const { count } = await prisma.productionorder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends productionorderDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, productionorderDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Productionorders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productionorderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Productionorders
     * const productionorder = await prisma.productionorder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends productionorderUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, productionorderUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Productionorder.
     * @param {productionorderUpsertArgs} args - Arguments to update or create a Productionorder.
     * @example
     * // Update or create a Productionorder
     * const productionorder = await prisma.productionorder.upsert({
     *   create: {
     *     // ... data to create a Productionorder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Productionorder we want to update
     *   }
     * })
    **/
    upsert<T extends productionorderUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, productionorderUpsertArgs<ExtArgs>>
    ): Prisma__productionorderClient<$Result.GetResult<Prisma.$productionorderPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Productionorders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productionorderCountArgs} args - Arguments to filter Productionorders to count.
     * @example
     * // Count the number of Productionorders
     * const count = await prisma.productionorder.count({
     *   where: {
     *     // ... the filter for the Productionorders we want to count
     *   }
     * })
    **/
    count<T extends productionorderCountArgs>(
      args?: Subset<T, productionorderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductionorderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Productionorder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionorderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductionorderAggregateArgs>(args: Subset<T, ProductionorderAggregateArgs>): Prisma.PrismaPromise<GetProductionorderAggregateType<T>>

    /**
     * Group by Productionorder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productionorderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends productionorderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: productionorderGroupByArgs['orderBy'] }
        : { orderBy?: productionorderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, productionorderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductionorderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the productionorder model
   */
  readonly fields: productionorderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for productionorder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__productionorderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the productionorder model
   */ 
  interface productionorderFieldRefs {
    readonly id: FieldRef<"productionorder", 'Int'>
    readonly timestamp: FieldRef<"productionorder", 'DateTime'>
    readonly ponum: FieldRef<"productionorder", 'String'>
    readonly area: FieldRef<"productionorder", 'String'>
    readonly provinsi: FieldRef<"productionorder", 'String'>
    readonly count_qty: FieldRef<"productionorder", 'String'>
    readonly qty: FieldRef<"productionorder", 'Int'>
    readonly status: FieldRef<"productionorder", 'Int'>
    readonly keterangan: FieldRef<"productionorder", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * productionorder findUnique
   */
  export type productionorderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the productionorder
     */
    select?: productionorderSelect<ExtArgs> | null
    /**
     * Filter, which productionorder to fetch.
     */
    where: productionorderWhereUniqueInput
  }


  /**
   * productionorder findUniqueOrThrow
   */
  export type productionorderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the productionorder
     */
    select?: productionorderSelect<ExtArgs> | null
    /**
     * Filter, which productionorder to fetch.
     */
    where: productionorderWhereUniqueInput
  }


  /**
   * productionorder findFirst
   */
  export type productionorderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the productionorder
     */
    select?: productionorderSelect<ExtArgs> | null
    /**
     * Filter, which productionorder to fetch.
     */
    where?: productionorderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of productionorders to fetch.
     */
    orderBy?: productionorderOrderByWithRelationInput | productionorderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for productionorders.
     */
    cursor?: productionorderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` productionorders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` productionorders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of productionorders.
     */
    distinct?: ProductionorderScalarFieldEnum | ProductionorderScalarFieldEnum[]
  }


  /**
   * productionorder findFirstOrThrow
   */
  export type productionorderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the productionorder
     */
    select?: productionorderSelect<ExtArgs> | null
    /**
     * Filter, which productionorder to fetch.
     */
    where?: productionorderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of productionorders to fetch.
     */
    orderBy?: productionorderOrderByWithRelationInput | productionorderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for productionorders.
     */
    cursor?: productionorderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` productionorders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` productionorders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of productionorders.
     */
    distinct?: ProductionorderScalarFieldEnum | ProductionorderScalarFieldEnum[]
  }


  /**
   * productionorder findMany
   */
  export type productionorderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the productionorder
     */
    select?: productionorderSelect<ExtArgs> | null
    /**
     * Filter, which productionorders to fetch.
     */
    where?: productionorderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of productionorders to fetch.
     */
    orderBy?: productionorderOrderByWithRelationInput | productionorderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing productionorders.
     */
    cursor?: productionorderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` productionorders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` productionorders.
     */
    skip?: number
    distinct?: ProductionorderScalarFieldEnum | ProductionorderScalarFieldEnum[]
  }


  /**
   * productionorder create
   */
  export type productionorderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the productionorder
     */
    select?: productionorderSelect<ExtArgs> | null
    /**
     * The data needed to create a productionorder.
     */
    data: XOR<productionorderCreateInput, productionorderUncheckedCreateInput>
  }


  /**
   * productionorder createMany
   */
  export type productionorderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many productionorders.
     */
    data: productionorderCreateManyInput | productionorderCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * productionorder update
   */
  export type productionorderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the productionorder
     */
    select?: productionorderSelect<ExtArgs> | null
    /**
     * The data needed to update a productionorder.
     */
    data: XOR<productionorderUpdateInput, productionorderUncheckedUpdateInput>
    /**
     * Choose, which productionorder to update.
     */
    where: productionorderWhereUniqueInput
  }


  /**
   * productionorder updateMany
   */
  export type productionorderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update productionorders.
     */
    data: XOR<productionorderUpdateManyMutationInput, productionorderUncheckedUpdateManyInput>
    /**
     * Filter which productionorders to update
     */
    where?: productionorderWhereInput
  }


  /**
   * productionorder upsert
   */
  export type productionorderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the productionorder
     */
    select?: productionorderSelect<ExtArgs> | null
    /**
     * The filter to search for the productionorder to update in case it exists.
     */
    where: productionorderWhereUniqueInput
    /**
     * In case the productionorder found by the `where` argument doesn't exist, create a new productionorder with this data.
     */
    create: XOR<productionorderCreateInput, productionorderUncheckedCreateInput>
    /**
     * In case the productionorder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<productionorderUpdateInput, productionorderUncheckedUpdateInput>
  }


  /**
   * productionorder delete
   */
  export type productionorderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the productionorder
     */
    select?: productionorderSelect<ExtArgs> | null
    /**
     * Filter which productionorder to delete.
     */
    where: productionorderWhereUniqueInput
  }


  /**
   * productionorder deleteMany
   */
  export type productionorderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which productionorders to delete
     */
    where?: productionorderWhereInput
  }


  /**
   * productionorder without action
   */
  export type productionorderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the productionorder
     */
    select?: productionorderSelect<ExtArgs> | null
  }



  /**
   * Model receive_110
   */

  export type AggregateReceive_110 = {
    _count: Receive_110CountAggregateOutputType | null
    _avg: Receive_110AvgAggregateOutputType | null
    _sum: Receive_110SumAggregateOutputType | null
    _min: Receive_110MinAggregateOutputType | null
    _max: Receive_110MaxAggregateOutputType | null
  }

  export type Receive_110AvgAggregateOutputType = {
    id: number | null
  }

  export type Receive_110SumAggregateOutputType = {
    id: number | null
  }

  export type Receive_110MinAggregateOutputType = {
    id: number | null
    serial: string | null
    qr_serial: string | null
    timestamp: Date | null
    result: $Enums.receive_110_result | null
  }

  export type Receive_110MaxAggregateOutputType = {
    id: number | null
    serial: string | null
    qr_serial: string | null
    timestamp: Date | null
    result: $Enums.receive_110_result | null
  }

  export type Receive_110CountAggregateOutputType = {
    id: number
    serial: number
    qr_serial: number
    timestamp: number
    result: number
    _all: number
  }


  export type Receive_110AvgAggregateInputType = {
    id?: true
  }

  export type Receive_110SumAggregateInputType = {
    id?: true
  }

  export type Receive_110MinAggregateInputType = {
    id?: true
    serial?: true
    qr_serial?: true
    timestamp?: true
    result?: true
  }

  export type Receive_110MaxAggregateInputType = {
    id?: true
    serial?: true
    qr_serial?: true
    timestamp?: true
    result?: true
  }

  export type Receive_110CountAggregateInputType = {
    id?: true
    serial?: true
    qr_serial?: true
    timestamp?: true
    result?: true
    _all?: true
  }

  export type Receive_110AggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which receive_110 to aggregate.
     */
    where?: receive_110WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of receive_110s to fetch.
     */
    orderBy?: receive_110OrderByWithRelationInput | receive_110OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: receive_110WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` receive_110s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` receive_110s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned receive_110s
    **/
    _count?: true | Receive_110CountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Receive_110AvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Receive_110SumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Receive_110MinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Receive_110MaxAggregateInputType
  }

  export type GetReceive_110AggregateType<T extends Receive_110AggregateArgs> = {
        [P in keyof T & keyof AggregateReceive_110]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReceive_110[P]>
      : GetScalarType<T[P], AggregateReceive_110[P]>
  }




  export type receive_110GroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: receive_110WhereInput
    orderBy?: receive_110OrderByWithAggregationInput | receive_110OrderByWithAggregationInput[]
    by: Receive_110ScalarFieldEnum[] | Receive_110ScalarFieldEnum
    having?: receive_110ScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Receive_110CountAggregateInputType | true
    _avg?: Receive_110AvgAggregateInputType
    _sum?: Receive_110SumAggregateInputType
    _min?: Receive_110MinAggregateInputType
    _max?: Receive_110MaxAggregateInputType
  }

  export type Receive_110GroupByOutputType = {
    id: number
    serial: string
    qr_serial: string
    timestamp: Date
    result: $Enums.receive_110_result
    _count: Receive_110CountAggregateOutputType | null
    _avg: Receive_110AvgAggregateOutputType | null
    _sum: Receive_110SumAggregateOutputType | null
    _min: Receive_110MinAggregateOutputType | null
    _max: Receive_110MaxAggregateOutputType | null
  }

  type GetReceive_110GroupByPayload<T extends receive_110GroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Receive_110GroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Receive_110GroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Receive_110GroupByOutputType[P]>
            : GetScalarType<T[P], Receive_110GroupByOutputType[P]>
        }
      >
    >


  export type receive_110Select<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serial?: boolean
    qr_serial?: boolean
    timestamp?: boolean
    result?: boolean
  }, ExtArgs["result"]["receive_110"]>

  export type receive_110SelectScalar = {
    id?: boolean
    serial?: boolean
    qr_serial?: boolean
    timestamp?: boolean
    result?: boolean
  }


  export type $receive_110Payload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "receive_110"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      serial: string
      qr_serial: string
      timestamp: Date
      result: $Enums.receive_110_result
    }, ExtArgs["result"]["receive_110"]>
    composites: {}
  }


  type receive_110GetPayload<S extends boolean | null | undefined | receive_110DefaultArgs> = $Result.GetResult<Prisma.$receive_110Payload, S>

  type receive_110CountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<receive_110FindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Receive_110CountAggregateInputType | true
    }

  export interface receive_110Delegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['receive_110'], meta: { name: 'receive_110' } }
    /**
     * Find zero or one Receive_110 that matches the filter.
     * @param {receive_110FindUniqueArgs} args - Arguments to find a Receive_110
     * @example
     * // Get one Receive_110
     * const receive_110 = await prisma.receive_110.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends receive_110FindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, receive_110FindUniqueArgs<ExtArgs>>
    ): Prisma__receive_110Client<$Result.GetResult<Prisma.$receive_110Payload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Receive_110 that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {receive_110FindUniqueOrThrowArgs} args - Arguments to find a Receive_110
     * @example
     * // Get one Receive_110
     * const receive_110 = await prisma.receive_110.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends receive_110FindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, receive_110FindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__receive_110Client<$Result.GetResult<Prisma.$receive_110Payload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Receive_110 that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {receive_110FindFirstArgs} args - Arguments to find a Receive_110
     * @example
     * // Get one Receive_110
     * const receive_110 = await prisma.receive_110.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends receive_110FindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, receive_110FindFirstArgs<ExtArgs>>
    ): Prisma__receive_110Client<$Result.GetResult<Prisma.$receive_110Payload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Receive_110 that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {receive_110FindFirstOrThrowArgs} args - Arguments to find a Receive_110
     * @example
     * // Get one Receive_110
     * const receive_110 = await prisma.receive_110.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends receive_110FindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, receive_110FindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__receive_110Client<$Result.GetResult<Prisma.$receive_110Payload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Receive_110s that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {receive_110FindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Receive_110s
     * const receive_110s = await prisma.receive_110.findMany()
     * 
     * // Get first 10 Receive_110s
     * const receive_110s = await prisma.receive_110.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const receive_110WithIdOnly = await prisma.receive_110.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends receive_110FindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, receive_110FindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$receive_110Payload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Receive_110.
     * @param {receive_110CreateArgs} args - Arguments to create a Receive_110.
     * @example
     * // Create one Receive_110
     * const Receive_110 = await prisma.receive_110.create({
     *   data: {
     *     // ... data to create a Receive_110
     *   }
     * })
     * 
    **/
    create<T extends receive_110CreateArgs<ExtArgs>>(
      args: SelectSubset<T, receive_110CreateArgs<ExtArgs>>
    ): Prisma__receive_110Client<$Result.GetResult<Prisma.$receive_110Payload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Receive_110s.
     *     @param {receive_110CreateManyArgs} args - Arguments to create many Receive_110s.
     *     @example
     *     // Create many Receive_110s
     *     const receive_110 = await prisma.receive_110.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends receive_110CreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, receive_110CreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Receive_110.
     * @param {receive_110DeleteArgs} args - Arguments to delete one Receive_110.
     * @example
     * // Delete one Receive_110
     * const Receive_110 = await prisma.receive_110.delete({
     *   where: {
     *     // ... filter to delete one Receive_110
     *   }
     * })
     * 
    **/
    delete<T extends receive_110DeleteArgs<ExtArgs>>(
      args: SelectSubset<T, receive_110DeleteArgs<ExtArgs>>
    ): Prisma__receive_110Client<$Result.GetResult<Prisma.$receive_110Payload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Receive_110.
     * @param {receive_110UpdateArgs} args - Arguments to update one Receive_110.
     * @example
     * // Update one Receive_110
     * const receive_110 = await prisma.receive_110.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends receive_110UpdateArgs<ExtArgs>>(
      args: SelectSubset<T, receive_110UpdateArgs<ExtArgs>>
    ): Prisma__receive_110Client<$Result.GetResult<Prisma.$receive_110Payload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Receive_110s.
     * @param {receive_110DeleteManyArgs} args - Arguments to filter Receive_110s to delete.
     * @example
     * // Delete a few Receive_110s
     * const { count } = await prisma.receive_110.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends receive_110DeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, receive_110DeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Receive_110s.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {receive_110UpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Receive_110s
     * const receive_110 = await prisma.receive_110.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends receive_110UpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, receive_110UpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Receive_110.
     * @param {receive_110UpsertArgs} args - Arguments to update or create a Receive_110.
     * @example
     * // Update or create a Receive_110
     * const receive_110 = await prisma.receive_110.upsert({
     *   create: {
     *     // ... data to create a Receive_110
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Receive_110 we want to update
     *   }
     * })
    **/
    upsert<T extends receive_110UpsertArgs<ExtArgs>>(
      args: SelectSubset<T, receive_110UpsertArgs<ExtArgs>>
    ): Prisma__receive_110Client<$Result.GetResult<Prisma.$receive_110Payload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Receive_110s.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {receive_110CountArgs} args - Arguments to filter Receive_110s to count.
     * @example
     * // Count the number of Receive_110s
     * const count = await prisma.receive_110.count({
     *   where: {
     *     // ... the filter for the Receive_110s we want to count
     *   }
     * })
    **/
    count<T extends receive_110CountArgs>(
      args?: Subset<T, receive_110CountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Receive_110CountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Receive_110.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Receive_110AggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Receive_110AggregateArgs>(args: Subset<T, Receive_110AggregateArgs>): Prisma.PrismaPromise<GetReceive_110AggregateType<T>>

    /**
     * Group by Receive_110.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {receive_110GroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends receive_110GroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: receive_110GroupByArgs['orderBy'] }
        : { orderBy?: receive_110GroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, receive_110GroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReceive_110GroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the receive_110 model
   */
  readonly fields: receive_110FieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for receive_110.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__receive_110Client<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the receive_110 model
   */ 
  interface receive_110FieldRefs {
    readonly id: FieldRef<"receive_110", 'Int'>
    readonly serial: FieldRef<"receive_110", 'String'>
    readonly qr_serial: FieldRef<"receive_110", 'String'>
    readonly timestamp: FieldRef<"receive_110", 'DateTime'>
    readonly result: FieldRef<"receive_110", 'receive_110_result'>
  }
    

  // Custom InputTypes

  /**
   * receive_110 findUnique
   */
  export type receive_110FindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the receive_110
     */
    select?: receive_110Select<ExtArgs> | null
    /**
     * Filter, which receive_110 to fetch.
     */
    where: receive_110WhereUniqueInput
  }


  /**
   * receive_110 findUniqueOrThrow
   */
  export type receive_110FindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the receive_110
     */
    select?: receive_110Select<ExtArgs> | null
    /**
     * Filter, which receive_110 to fetch.
     */
    where: receive_110WhereUniqueInput
  }


  /**
   * receive_110 findFirst
   */
  export type receive_110FindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the receive_110
     */
    select?: receive_110Select<ExtArgs> | null
    /**
     * Filter, which receive_110 to fetch.
     */
    where?: receive_110WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of receive_110s to fetch.
     */
    orderBy?: receive_110OrderByWithRelationInput | receive_110OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for receive_110s.
     */
    cursor?: receive_110WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` receive_110s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` receive_110s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of receive_110s.
     */
    distinct?: Receive_110ScalarFieldEnum | Receive_110ScalarFieldEnum[]
  }


  /**
   * receive_110 findFirstOrThrow
   */
  export type receive_110FindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the receive_110
     */
    select?: receive_110Select<ExtArgs> | null
    /**
     * Filter, which receive_110 to fetch.
     */
    where?: receive_110WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of receive_110s to fetch.
     */
    orderBy?: receive_110OrderByWithRelationInput | receive_110OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for receive_110s.
     */
    cursor?: receive_110WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` receive_110s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` receive_110s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of receive_110s.
     */
    distinct?: Receive_110ScalarFieldEnum | Receive_110ScalarFieldEnum[]
  }


  /**
   * receive_110 findMany
   */
  export type receive_110FindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the receive_110
     */
    select?: receive_110Select<ExtArgs> | null
    /**
     * Filter, which receive_110s to fetch.
     */
    where?: receive_110WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of receive_110s to fetch.
     */
    orderBy?: receive_110OrderByWithRelationInput | receive_110OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing receive_110s.
     */
    cursor?: receive_110WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` receive_110s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` receive_110s.
     */
    skip?: number
    distinct?: Receive_110ScalarFieldEnum | Receive_110ScalarFieldEnum[]
  }


  /**
   * receive_110 create
   */
  export type receive_110CreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the receive_110
     */
    select?: receive_110Select<ExtArgs> | null
    /**
     * The data needed to create a receive_110.
     */
    data: XOR<receive_110CreateInput, receive_110UncheckedCreateInput>
  }


  /**
   * receive_110 createMany
   */
  export type receive_110CreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many receive_110s.
     */
    data: receive_110CreateManyInput | receive_110CreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * receive_110 update
   */
  export type receive_110UpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the receive_110
     */
    select?: receive_110Select<ExtArgs> | null
    /**
     * The data needed to update a receive_110.
     */
    data: XOR<receive_110UpdateInput, receive_110UncheckedUpdateInput>
    /**
     * Choose, which receive_110 to update.
     */
    where: receive_110WhereUniqueInput
  }


  /**
   * receive_110 updateMany
   */
  export type receive_110UpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update receive_110s.
     */
    data: XOR<receive_110UpdateManyMutationInput, receive_110UncheckedUpdateManyInput>
    /**
     * Filter which receive_110s to update
     */
    where?: receive_110WhereInput
  }


  /**
   * receive_110 upsert
   */
  export type receive_110UpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the receive_110
     */
    select?: receive_110Select<ExtArgs> | null
    /**
     * The filter to search for the receive_110 to update in case it exists.
     */
    where: receive_110WhereUniqueInput
    /**
     * In case the receive_110 found by the `where` argument doesn't exist, create a new receive_110 with this data.
     */
    create: XOR<receive_110CreateInput, receive_110UncheckedCreateInput>
    /**
     * In case the receive_110 was found with the provided `where` argument, update it with this data.
     */
    update: XOR<receive_110UpdateInput, receive_110UncheckedUpdateInput>
  }


  /**
   * receive_110 delete
   */
  export type receive_110DeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the receive_110
     */
    select?: receive_110Select<ExtArgs> | null
    /**
     * Filter which receive_110 to delete.
     */
    where: receive_110WhereUniqueInput
  }


  /**
   * receive_110 deleteMany
   */
  export type receive_110DeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which receive_110s to delete
     */
    where?: receive_110WhereInput
  }


  /**
   * receive_110 without action
   */
  export type receive_110DefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the receive_110
     */
    select?: receive_110Select<ExtArgs> | null
  }



  /**
   * Model rework_amr
   */

  export type AggregateRework_amr = {
    _count: Rework_amrCountAggregateOutputType | null
    _avg: Rework_amrAvgAggregateOutputType | null
    _sum: Rework_amrSumAggregateOutputType | null
    _min: Rework_amrMinAggregateOutputType | null
    _max: Rework_amrMaxAggregateOutputType | null
  }

  export type Rework_amrAvgAggregateOutputType = {
    id: number | null
  }

  export type Rework_amrSumAggregateOutputType = {
    id: number | null
  }

  export type Rework_amrMinAggregateOutputType = {
    id: number | null
    serial: string | null
    qr_serial: string | null
    timestamp: Date | null
  }

  export type Rework_amrMaxAggregateOutputType = {
    id: number | null
    serial: string | null
    qr_serial: string | null
    timestamp: Date | null
  }

  export type Rework_amrCountAggregateOutputType = {
    id: number
    serial: number
    qr_serial: number
    timestamp: number
    _all: number
  }


  export type Rework_amrAvgAggregateInputType = {
    id?: true
  }

  export type Rework_amrSumAggregateInputType = {
    id?: true
  }

  export type Rework_amrMinAggregateInputType = {
    id?: true
    serial?: true
    qr_serial?: true
    timestamp?: true
  }

  export type Rework_amrMaxAggregateInputType = {
    id?: true
    serial?: true
    qr_serial?: true
    timestamp?: true
  }

  export type Rework_amrCountAggregateInputType = {
    id?: true
    serial?: true
    qr_serial?: true
    timestamp?: true
    _all?: true
  }

  export type Rework_amrAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which rework_amr to aggregate.
     */
    where?: rework_amrWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rework_amrs to fetch.
     */
    orderBy?: rework_amrOrderByWithRelationInput | rework_amrOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: rework_amrWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rework_amrs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rework_amrs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned rework_amrs
    **/
    _count?: true | Rework_amrCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Rework_amrAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Rework_amrSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Rework_amrMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Rework_amrMaxAggregateInputType
  }

  export type GetRework_amrAggregateType<T extends Rework_amrAggregateArgs> = {
        [P in keyof T & keyof AggregateRework_amr]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRework_amr[P]>
      : GetScalarType<T[P], AggregateRework_amr[P]>
  }




  export type rework_amrGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: rework_amrWhereInput
    orderBy?: rework_amrOrderByWithAggregationInput | rework_amrOrderByWithAggregationInput[]
    by: Rework_amrScalarFieldEnum[] | Rework_amrScalarFieldEnum
    having?: rework_amrScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Rework_amrCountAggregateInputType | true
    _avg?: Rework_amrAvgAggregateInputType
    _sum?: Rework_amrSumAggregateInputType
    _min?: Rework_amrMinAggregateInputType
    _max?: Rework_amrMaxAggregateInputType
  }

  export type Rework_amrGroupByOutputType = {
    id: number
    serial: string | null
    qr_serial: string
    timestamp: Date
    _count: Rework_amrCountAggregateOutputType | null
    _avg: Rework_amrAvgAggregateOutputType | null
    _sum: Rework_amrSumAggregateOutputType | null
    _min: Rework_amrMinAggregateOutputType | null
    _max: Rework_amrMaxAggregateOutputType | null
  }

  type GetRework_amrGroupByPayload<T extends rework_amrGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Rework_amrGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Rework_amrGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Rework_amrGroupByOutputType[P]>
            : GetScalarType<T[P], Rework_amrGroupByOutputType[P]>
        }
      >
    >


  export type rework_amrSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serial?: boolean
    qr_serial?: boolean
    timestamp?: boolean
  }, ExtArgs["result"]["rework_amr"]>

  export type rework_amrSelectScalar = {
    id?: boolean
    serial?: boolean
    qr_serial?: boolean
    timestamp?: boolean
  }


  export type $rework_amrPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "rework_amr"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      serial: string | null
      qr_serial: string
      timestamp: Date
    }, ExtArgs["result"]["rework_amr"]>
    composites: {}
  }


  type rework_amrGetPayload<S extends boolean | null | undefined | rework_amrDefaultArgs> = $Result.GetResult<Prisma.$rework_amrPayload, S>

  type rework_amrCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<rework_amrFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Rework_amrCountAggregateInputType | true
    }

  export interface rework_amrDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['rework_amr'], meta: { name: 'rework_amr' } }
    /**
     * Find zero or one Rework_amr that matches the filter.
     * @param {rework_amrFindUniqueArgs} args - Arguments to find a Rework_amr
     * @example
     * // Get one Rework_amr
     * const rework_amr = await prisma.rework_amr.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends rework_amrFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, rework_amrFindUniqueArgs<ExtArgs>>
    ): Prisma__rework_amrClient<$Result.GetResult<Prisma.$rework_amrPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Rework_amr that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {rework_amrFindUniqueOrThrowArgs} args - Arguments to find a Rework_amr
     * @example
     * // Get one Rework_amr
     * const rework_amr = await prisma.rework_amr.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends rework_amrFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, rework_amrFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__rework_amrClient<$Result.GetResult<Prisma.$rework_amrPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Rework_amr that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rework_amrFindFirstArgs} args - Arguments to find a Rework_amr
     * @example
     * // Get one Rework_amr
     * const rework_amr = await prisma.rework_amr.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends rework_amrFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, rework_amrFindFirstArgs<ExtArgs>>
    ): Prisma__rework_amrClient<$Result.GetResult<Prisma.$rework_amrPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Rework_amr that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rework_amrFindFirstOrThrowArgs} args - Arguments to find a Rework_amr
     * @example
     * // Get one Rework_amr
     * const rework_amr = await prisma.rework_amr.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends rework_amrFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, rework_amrFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__rework_amrClient<$Result.GetResult<Prisma.$rework_amrPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Rework_amrs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rework_amrFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Rework_amrs
     * const rework_amrs = await prisma.rework_amr.findMany()
     * 
     * // Get first 10 Rework_amrs
     * const rework_amrs = await prisma.rework_amr.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rework_amrWithIdOnly = await prisma.rework_amr.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends rework_amrFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, rework_amrFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rework_amrPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Rework_amr.
     * @param {rework_amrCreateArgs} args - Arguments to create a Rework_amr.
     * @example
     * // Create one Rework_amr
     * const Rework_amr = await prisma.rework_amr.create({
     *   data: {
     *     // ... data to create a Rework_amr
     *   }
     * })
     * 
    **/
    create<T extends rework_amrCreateArgs<ExtArgs>>(
      args: SelectSubset<T, rework_amrCreateArgs<ExtArgs>>
    ): Prisma__rework_amrClient<$Result.GetResult<Prisma.$rework_amrPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Rework_amrs.
     *     @param {rework_amrCreateManyArgs} args - Arguments to create many Rework_amrs.
     *     @example
     *     // Create many Rework_amrs
     *     const rework_amr = await prisma.rework_amr.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends rework_amrCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, rework_amrCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Rework_amr.
     * @param {rework_amrDeleteArgs} args - Arguments to delete one Rework_amr.
     * @example
     * // Delete one Rework_amr
     * const Rework_amr = await prisma.rework_amr.delete({
     *   where: {
     *     // ... filter to delete one Rework_amr
     *   }
     * })
     * 
    **/
    delete<T extends rework_amrDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, rework_amrDeleteArgs<ExtArgs>>
    ): Prisma__rework_amrClient<$Result.GetResult<Prisma.$rework_amrPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Rework_amr.
     * @param {rework_amrUpdateArgs} args - Arguments to update one Rework_amr.
     * @example
     * // Update one Rework_amr
     * const rework_amr = await prisma.rework_amr.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends rework_amrUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, rework_amrUpdateArgs<ExtArgs>>
    ): Prisma__rework_amrClient<$Result.GetResult<Prisma.$rework_amrPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Rework_amrs.
     * @param {rework_amrDeleteManyArgs} args - Arguments to filter Rework_amrs to delete.
     * @example
     * // Delete a few Rework_amrs
     * const { count } = await prisma.rework_amr.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends rework_amrDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, rework_amrDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rework_amrs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rework_amrUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Rework_amrs
     * const rework_amr = await prisma.rework_amr.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends rework_amrUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, rework_amrUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Rework_amr.
     * @param {rework_amrUpsertArgs} args - Arguments to update or create a Rework_amr.
     * @example
     * // Update or create a Rework_amr
     * const rework_amr = await prisma.rework_amr.upsert({
     *   create: {
     *     // ... data to create a Rework_amr
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Rework_amr we want to update
     *   }
     * })
    **/
    upsert<T extends rework_amrUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, rework_amrUpsertArgs<ExtArgs>>
    ): Prisma__rework_amrClient<$Result.GetResult<Prisma.$rework_amrPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Rework_amrs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rework_amrCountArgs} args - Arguments to filter Rework_amrs to count.
     * @example
     * // Count the number of Rework_amrs
     * const count = await prisma.rework_amr.count({
     *   where: {
     *     // ... the filter for the Rework_amrs we want to count
     *   }
     * })
    **/
    count<T extends rework_amrCountArgs>(
      args?: Subset<T, rework_amrCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Rework_amrCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Rework_amr.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Rework_amrAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Rework_amrAggregateArgs>(args: Subset<T, Rework_amrAggregateArgs>): Prisma.PrismaPromise<GetRework_amrAggregateType<T>>

    /**
     * Group by Rework_amr.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rework_amrGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends rework_amrGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: rework_amrGroupByArgs['orderBy'] }
        : { orderBy?: rework_amrGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, rework_amrGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRework_amrGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the rework_amr model
   */
  readonly fields: rework_amrFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for rework_amr.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__rework_amrClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the rework_amr model
   */ 
  interface rework_amrFieldRefs {
    readonly id: FieldRef<"rework_amr", 'Int'>
    readonly serial: FieldRef<"rework_amr", 'String'>
    readonly qr_serial: FieldRef<"rework_amr", 'String'>
    readonly timestamp: FieldRef<"rework_amr", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * rework_amr findUnique
   */
  export type rework_amrFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rework_amr
     */
    select?: rework_amrSelect<ExtArgs> | null
    /**
     * Filter, which rework_amr to fetch.
     */
    where: rework_amrWhereUniqueInput
  }


  /**
   * rework_amr findUniqueOrThrow
   */
  export type rework_amrFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rework_amr
     */
    select?: rework_amrSelect<ExtArgs> | null
    /**
     * Filter, which rework_amr to fetch.
     */
    where: rework_amrWhereUniqueInput
  }


  /**
   * rework_amr findFirst
   */
  export type rework_amrFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rework_amr
     */
    select?: rework_amrSelect<ExtArgs> | null
    /**
     * Filter, which rework_amr to fetch.
     */
    where?: rework_amrWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rework_amrs to fetch.
     */
    orderBy?: rework_amrOrderByWithRelationInput | rework_amrOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for rework_amrs.
     */
    cursor?: rework_amrWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rework_amrs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rework_amrs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of rework_amrs.
     */
    distinct?: Rework_amrScalarFieldEnum | Rework_amrScalarFieldEnum[]
  }


  /**
   * rework_amr findFirstOrThrow
   */
  export type rework_amrFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rework_amr
     */
    select?: rework_amrSelect<ExtArgs> | null
    /**
     * Filter, which rework_amr to fetch.
     */
    where?: rework_amrWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rework_amrs to fetch.
     */
    orderBy?: rework_amrOrderByWithRelationInput | rework_amrOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for rework_amrs.
     */
    cursor?: rework_amrWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rework_amrs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rework_amrs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of rework_amrs.
     */
    distinct?: Rework_amrScalarFieldEnum | Rework_amrScalarFieldEnum[]
  }


  /**
   * rework_amr findMany
   */
  export type rework_amrFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rework_amr
     */
    select?: rework_amrSelect<ExtArgs> | null
    /**
     * Filter, which rework_amrs to fetch.
     */
    where?: rework_amrWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rework_amrs to fetch.
     */
    orderBy?: rework_amrOrderByWithRelationInput | rework_amrOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing rework_amrs.
     */
    cursor?: rework_amrWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rework_amrs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rework_amrs.
     */
    skip?: number
    distinct?: Rework_amrScalarFieldEnum | Rework_amrScalarFieldEnum[]
  }


  /**
   * rework_amr create
   */
  export type rework_amrCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rework_amr
     */
    select?: rework_amrSelect<ExtArgs> | null
    /**
     * The data needed to create a rework_amr.
     */
    data: XOR<rework_amrCreateInput, rework_amrUncheckedCreateInput>
  }


  /**
   * rework_amr createMany
   */
  export type rework_amrCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many rework_amrs.
     */
    data: rework_amrCreateManyInput | rework_amrCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * rework_amr update
   */
  export type rework_amrUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rework_amr
     */
    select?: rework_amrSelect<ExtArgs> | null
    /**
     * The data needed to update a rework_amr.
     */
    data: XOR<rework_amrUpdateInput, rework_amrUncheckedUpdateInput>
    /**
     * Choose, which rework_amr to update.
     */
    where: rework_amrWhereUniqueInput
  }


  /**
   * rework_amr updateMany
   */
  export type rework_amrUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update rework_amrs.
     */
    data: XOR<rework_amrUpdateManyMutationInput, rework_amrUncheckedUpdateManyInput>
    /**
     * Filter which rework_amrs to update
     */
    where?: rework_amrWhereInput
  }


  /**
   * rework_amr upsert
   */
  export type rework_amrUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rework_amr
     */
    select?: rework_amrSelect<ExtArgs> | null
    /**
     * The filter to search for the rework_amr to update in case it exists.
     */
    where: rework_amrWhereUniqueInput
    /**
     * In case the rework_amr found by the `where` argument doesn't exist, create a new rework_amr with this data.
     */
    create: XOR<rework_amrCreateInput, rework_amrUncheckedCreateInput>
    /**
     * In case the rework_amr was found with the provided `where` argument, update it with this data.
     */
    update: XOR<rework_amrUpdateInput, rework_amrUncheckedUpdateInput>
  }


  /**
   * rework_amr delete
   */
  export type rework_amrDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rework_amr
     */
    select?: rework_amrSelect<ExtArgs> | null
    /**
     * Filter which rework_amr to delete.
     */
    where: rework_amrWhereUniqueInput
  }


  /**
   * rework_amr deleteMany
   */
  export type rework_amrDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which rework_amrs to delete
     */
    where?: rework_amrWhereInput
  }


  /**
   * rework_amr without action
   */
  export type rework_amrDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rework_amr
     */
    select?: rework_amrSelect<ExtArgs> | null
  }



  /**
   * Model rework_box
   */

  export type AggregateRework_box = {
    _count: Rework_boxCountAggregateOutputType | null
    _avg: Rework_boxAvgAggregateOutputType | null
    _sum: Rework_boxSumAggregateOutputType | null
    _min: Rework_boxMinAggregateOutputType | null
    _max: Rework_boxMaxAggregateOutputType | null
  }

  export type Rework_boxAvgAggregateOutputType = {
    id: number | null
    pallete_id: number | null
    attachment_id: number | null
    attachment2_id: number | null
  }

  export type Rework_boxSumAggregateOutputType = {
    id: number | null
    pallete_id: number | null
    attachment_id: number | null
    attachment2_id: number | null
  }

  export type Rework_boxMinAggregateOutputType = {
    id: number | null
    serial: string | null
    timestamp: Date | null
    line: string | null
    type: string | null
    pallete_id: number | null
    attachment_id: number | null
    attachment2_id: number | null
  }

  export type Rework_boxMaxAggregateOutputType = {
    id: number | null
    serial: string | null
    timestamp: Date | null
    line: string | null
    type: string | null
    pallete_id: number | null
    attachment_id: number | null
    attachment2_id: number | null
  }

  export type Rework_boxCountAggregateOutputType = {
    id: number
    serial: number
    timestamp: number
    line: number
    type: number
    pallete_id: number
    attachment_id: number
    attachment2_id: number
    _all: number
  }


  export type Rework_boxAvgAggregateInputType = {
    id?: true
    pallete_id?: true
    attachment_id?: true
    attachment2_id?: true
  }

  export type Rework_boxSumAggregateInputType = {
    id?: true
    pallete_id?: true
    attachment_id?: true
    attachment2_id?: true
  }

  export type Rework_boxMinAggregateInputType = {
    id?: true
    serial?: true
    timestamp?: true
    line?: true
    type?: true
    pallete_id?: true
    attachment_id?: true
    attachment2_id?: true
  }

  export type Rework_boxMaxAggregateInputType = {
    id?: true
    serial?: true
    timestamp?: true
    line?: true
    type?: true
    pallete_id?: true
    attachment_id?: true
    attachment2_id?: true
  }

  export type Rework_boxCountAggregateInputType = {
    id?: true
    serial?: true
    timestamp?: true
    line?: true
    type?: true
    pallete_id?: true
    attachment_id?: true
    attachment2_id?: true
    _all?: true
  }

  export type Rework_boxAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which rework_box to aggregate.
     */
    where?: rework_boxWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rework_boxes to fetch.
     */
    orderBy?: rework_boxOrderByWithRelationInput | rework_boxOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: rework_boxWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rework_boxes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rework_boxes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned rework_boxes
    **/
    _count?: true | Rework_boxCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Rework_boxAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Rework_boxSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Rework_boxMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Rework_boxMaxAggregateInputType
  }

  export type GetRework_boxAggregateType<T extends Rework_boxAggregateArgs> = {
        [P in keyof T & keyof AggregateRework_box]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRework_box[P]>
      : GetScalarType<T[P], AggregateRework_box[P]>
  }




  export type rework_boxGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: rework_boxWhereInput
    orderBy?: rework_boxOrderByWithAggregationInput | rework_boxOrderByWithAggregationInput[]
    by: Rework_boxScalarFieldEnum[] | Rework_boxScalarFieldEnum
    having?: rework_boxScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Rework_boxCountAggregateInputType | true
    _avg?: Rework_boxAvgAggregateInputType
    _sum?: Rework_boxSumAggregateInputType
    _min?: Rework_boxMinAggregateInputType
    _max?: Rework_boxMaxAggregateInputType
  }

  export type Rework_boxGroupByOutputType = {
    id: number
    serial: string
    timestamp: Date
    line: string
    type: string
    pallete_id: number | null
    attachment_id: number | null
    attachment2_id: number | null
    _count: Rework_boxCountAggregateOutputType | null
    _avg: Rework_boxAvgAggregateOutputType | null
    _sum: Rework_boxSumAggregateOutputType | null
    _min: Rework_boxMinAggregateOutputType | null
    _max: Rework_boxMaxAggregateOutputType | null
  }

  type GetRework_boxGroupByPayload<T extends rework_boxGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Rework_boxGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Rework_boxGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Rework_boxGroupByOutputType[P]>
            : GetScalarType<T[P], Rework_boxGroupByOutputType[P]>
        }
      >
    >


  export type rework_boxSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serial?: boolean
    timestamp?: boolean
    line?: boolean
    type?: boolean
    pallete_id?: boolean
    attachment_id?: boolean
    attachment2_id?: boolean
  }, ExtArgs["result"]["rework_box"]>

  export type rework_boxSelectScalar = {
    id?: boolean
    serial?: boolean
    timestamp?: boolean
    line?: boolean
    type?: boolean
    pallete_id?: boolean
    attachment_id?: boolean
    attachment2_id?: boolean
  }


  export type $rework_boxPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "rework_box"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      serial: string
      timestamp: Date
      line: string
      type: string
      pallete_id: number | null
      attachment_id: number | null
      attachment2_id: number | null
    }, ExtArgs["result"]["rework_box"]>
    composites: {}
  }


  type rework_boxGetPayload<S extends boolean | null | undefined | rework_boxDefaultArgs> = $Result.GetResult<Prisma.$rework_boxPayload, S>

  type rework_boxCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<rework_boxFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Rework_boxCountAggregateInputType | true
    }

  export interface rework_boxDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['rework_box'], meta: { name: 'rework_box' } }
    /**
     * Find zero or one Rework_box that matches the filter.
     * @param {rework_boxFindUniqueArgs} args - Arguments to find a Rework_box
     * @example
     * // Get one Rework_box
     * const rework_box = await prisma.rework_box.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends rework_boxFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, rework_boxFindUniqueArgs<ExtArgs>>
    ): Prisma__rework_boxClient<$Result.GetResult<Prisma.$rework_boxPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Rework_box that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {rework_boxFindUniqueOrThrowArgs} args - Arguments to find a Rework_box
     * @example
     * // Get one Rework_box
     * const rework_box = await prisma.rework_box.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends rework_boxFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, rework_boxFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__rework_boxClient<$Result.GetResult<Prisma.$rework_boxPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Rework_box that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rework_boxFindFirstArgs} args - Arguments to find a Rework_box
     * @example
     * // Get one Rework_box
     * const rework_box = await prisma.rework_box.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends rework_boxFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, rework_boxFindFirstArgs<ExtArgs>>
    ): Prisma__rework_boxClient<$Result.GetResult<Prisma.$rework_boxPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Rework_box that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rework_boxFindFirstOrThrowArgs} args - Arguments to find a Rework_box
     * @example
     * // Get one Rework_box
     * const rework_box = await prisma.rework_box.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends rework_boxFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, rework_boxFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__rework_boxClient<$Result.GetResult<Prisma.$rework_boxPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Rework_boxes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rework_boxFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Rework_boxes
     * const rework_boxes = await prisma.rework_box.findMany()
     * 
     * // Get first 10 Rework_boxes
     * const rework_boxes = await prisma.rework_box.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rework_boxWithIdOnly = await prisma.rework_box.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends rework_boxFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, rework_boxFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rework_boxPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Rework_box.
     * @param {rework_boxCreateArgs} args - Arguments to create a Rework_box.
     * @example
     * // Create one Rework_box
     * const Rework_box = await prisma.rework_box.create({
     *   data: {
     *     // ... data to create a Rework_box
     *   }
     * })
     * 
    **/
    create<T extends rework_boxCreateArgs<ExtArgs>>(
      args: SelectSubset<T, rework_boxCreateArgs<ExtArgs>>
    ): Prisma__rework_boxClient<$Result.GetResult<Prisma.$rework_boxPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Rework_boxes.
     *     @param {rework_boxCreateManyArgs} args - Arguments to create many Rework_boxes.
     *     @example
     *     // Create many Rework_boxes
     *     const rework_box = await prisma.rework_box.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends rework_boxCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, rework_boxCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Rework_box.
     * @param {rework_boxDeleteArgs} args - Arguments to delete one Rework_box.
     * @example
     * // Delete one Rework_box
     * const Rework_box = await prisma.rework_box.delete({
     *   where: {
     *     // ... filter to delete one Rework_box
     *   }
     * })
     * 
    **/
    delete<T extends rework_boxDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, rework_boxDeleteArgs<ExtArgs>>
    ): Prisma__rework_boxClient<$Result.GetResult<Prisma.$rework_boxPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Rework_box.
     * @param {rework_boxUpdateArgs} args - Arguments to update one Rework_box.
     * @example
     * // Update one Rework_box
     * const rework_box = await prisma.rework_box.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends rework_boxUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, rework_boxUpdateArgs<ExtArgs>>
    ): Prisma__rework_boxClient<$Result.GetResult<Prisma.$rework_boxPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Rework_boxes.
     * @param {rework_boxDeleteManyArgs} args - Arguments to filter Rework_boxes to delete.
     * @example
     * // Delete a few Rework_boxes
     * const { count } = await prisma.rework_box.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends rework_boxDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, rework_boxDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rework_boxes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rework_boxUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Rework_boxes
     * const rework_box = await prisma.rework_box.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends rework_boxUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, rework_boxUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Rework_box.
     * @param {rework_boxUpsertArgs} args - Arguments to update or create a Rework_box.
     * @example
     * // Update or create a Rework_box
     * const rework_box = await prisma.rework_box.upsert({
     *   create: {
     *     // ... data to create a Rework_box
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Rework_box we want to update
     *   }
     * })
    **/
    upsert<T extends rework_boxUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, rework_boxUpsertArgs<ExtArgs>>
    ): Prisma__rework_boxClient<$Result.GetResult<Prisma.$rework_boxPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Rework_boxes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rework_boxCountArgs} args - Arguments to filter Rework_boxes to count.
     * @example
     * // Count the number of Rework_boxes
     * const count = await prisma.rework_box.count({
     *   where: {
     *     // ... the filter for the Rework_boxes we want to count
     *   }
     * })
    **/
    count<T extends rework_boxCountArgs>(
      args?: Subset<T, rework_boxCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Rework_boxCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Rework_box.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Rework_boxAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Rework_boxAggregateArgs>(args: Subset<T, Rework_boxAggregateArgs>): Prisma.PrismaPromise<GetRework_boxAggregateType<T>>

    /**
     * Group by Rework_box.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rework_boxGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends rework_boxGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: rework_boxGroupByArgs['orderBy'] }
        : { orderBy?: rework_boxGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, rework_boxGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRework_boxGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the rework_box model
   */
  readonly fields: rework_boxFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for rework_box.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__rework_boxClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the rework_box model
   */ 
  interface rework_boxFieldRefs {
    readonly id: FieldRef<"rework_box", 'Int'>
    readonly serial: FieldRef<"rework_box", 'String'>
    readonly timestamp: FieldRef<"rework_box", 'DateTime'>
    readonly line: FieldRef<"rework_box", 'String'>
    readonly type: FieldRef<"rework_box", 'String'>
    readonly pallete_id: FieldRef<"rework_box", 'Int'>
    readonly attachment_id: FieldRef<"rework_box", 'Int'>
    readonly attachment2_id: FieldRef<"rework_box", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * rework_box findUnique
   */
  export type rework_boxFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rework_box
     */
    select?: rework_boxSelect<ExtArgs> | null
    /**
     * Filter, which rework_box to fetch.
     */
    where: rework_boxWhereUniqueInput
  }


  /**
   * rework_box findUniqueOrThrow
   */
  export type rework_boxFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rework_box
     */
    select?: rework_boxSelect<ExtArgs> | null
    /**
     * Filter, which rework_box to fetch.
     */
    where: rework_boxWhereUniqueInput
  }


  /**
   * rework_box findFirst
   */
  export type rework_boxFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rework_box
     */
    select?: rework_boxSelect<ExtArgs> | null
    /**
     * Filter, which rework_box to fetch.
     */
    where?: rework_boxWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rework_boxes to fetch.
     */
    orderBy?: rework_boxOrderByWithRelationInput | rework_boxOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for rework_boxes.
     */
    cursor?: rework_boxWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rework_boxes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rework_boxes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of rework_boxes.
     */
    distinct?: Rework_boxScalarFieldEnum | Rework_boxScalarFieldEnum[]
  }


  /**
   * rework_box findFirstOrThrow
   */
  export type rework_boxFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rework_box
     */
    select?: rework_boxSelect<ExtArgs> | null
    /**
     * Filter, which rework_box to fetch.
     */
    where?: rework_boxWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rework_boxes to fetch.
     */
    orderBy?: rework_boxOrderByWithRelationInput | rework_boxOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for rework_boxes.
     */
    cursor?: rework_boxWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rework_boxes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rework_boxes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of rework_boxes.
     */
    distinct?: Rework_boxScalarFieldEnum | Rework_boxScalarFieldEnum[]
  }


  /**
   * rework_box findMany
   */
  export type rework_boxFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rework_box
     */
    select?: rework_boxSelect<ExtArgs> | null
    /**
     * Filter, which rework_boxes to fetch.
     */
    where?: rework_boxWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rework_boxes to fetch.
     */
    orderBy?: rework_boxOrderByWithRelationInput | rework_boxOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing rework_boxes.
     */
    cursor?: rework_boxWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rework_boxes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rework_boxes.
     */
    skip?: number
    distinct?: Rework_boxScalarFieldEnum | Rework_boxScalarFieldEnum[]
  }


  /**
   * rework_box create
   */
  export type rework_boxCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rework_box
     */
    select?: rework_boxSelect<ExtArgs> | null
    /**
     * The data needed to create a rework_box.
     */
    data: XOR<rework_boxCreateInput, rework_boxUncheckedCreateInput>
  }


  /**
   * rework_box createMany
   */
  export type rework_boxCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many rework_boxes.
     */
    data: rework_boxCreateManyInput | rework_boxCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * rework_box update
   */
  export type rework_boxUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rework_box
     */
    select?: rework_boxSelect<ExtArgs> | null
    /**
     * The data needed to update a rework_box.
     */
    data: XOR<rework_boxUpdateInput, rework_boxUncheckedUpdateInput>
    /**
     * Choose, which rework_box to update.
     */
    where: rework_boxWhereUniqueInput
  }


  /**
   * rework_box updateMany
   */
  export type rework_boxUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update rework_boxes.
     */
    data: XOR<rework_boxUpdateManyMutationInput, rework_boxUncheckedUpdateManyInput>
    /**
     * Filter which rework_boxes to update
     */
    where?: rework_boxWhereInput
  }


  /**
   * rework_box upsert
   */
  export type rework_boxUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rework_box
     */
    select?: rework_boxSelect<ExtArgs> | null
    /**
     * The filter to search for the rework_box to update in case it exists.
     */
    where: rework_boxWhereUniqueInput
    /**
     * In case the rework_box found by the `where` argument doesn't exist, create a new rework_box with this data.
     */
    create: XOR<rework_boxCreateInput, rework_boxUncheckedCreateInput>
    /**
     * In case the rework_box was found with the provided `where` argument, update it with this data.
     */
    update: XOR<rework_boxUpdateInput, rework_boxUncheckedUpdateInput>
  }


  /**
   * rework_box delete
   */
  export type rework_boxDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rework_box
     */
    select?: rework_boxSelect<ExtArgs> | null
    /**
     * Filter which rework_box to delete.
     */
    where: rework_boxWhereUniqueInput
  }


  /**
   * rework_box deleteMany
   */
  export type rework_boxDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which rework_boxes to delete
     */
    where?: rework_boxWhereInput
  }


  /**
   * rework_box without action
   */
  export type rework_boxDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rework_box
     */
    select?: rework_boxSelect<ExtArgs> | null
  }



  /**
   * Model rework_hxe110
   */

  export type AggregateRework_hxe110 = {
    _count: Rework_hxe110CountAggregateOutputType | null
    _avg: Rework_hxe110AvgAggregateOutputType | null
    _sum: Rework_hxe110SumAggregateOutputType | null
    _min: Rework_hxe110MinAggregateOutputType | null
    _max: Rework_hxe110MaxAggregateOutputType | null
  }

  export type Rework_hxe110AvgAggregateOutputType = {
    id: number | null
  }

  export type Rework_hxe110SumAggregateOutputType = {
    id: number | null
  }

  export type Rework_hxe110MinAggregateOutputType = {
    id: number | null
    meter_type: string | null
    meter_serial: string | null
    tanggal: Date | null
    modem: string | null
    baterai: string | null
    defect: string | null
  }

  export type Rework_hxe110MaxAggregateOutputType = {
    id: number | null
    meter_type: string | null
    meter_serial: string | null
    tanggal: Date | null
    modem: string | null
    baterai: string | null
    defect: string | null
  }

  export type Rework_hxe110CountAggregateOutputType = {
    id: number
    meter_type: number
    meter_serial: number
    tanggal: number
    modem: number
    baterai: number
    defect: number
    _all: number
  }


  export type Rework_hxe110AvgAggregateInputType = {
    id?: true
  }

  export type Rework_hxe110SumAggregateInputType = {
    id?: true
  }

  export type Rework_hxe110MinAggregateInputType = {
    id?: true
    meter_type?: true
    meter_serial?: true
    tanggal?: true
    modem?: true
    baterai?: true
    defect?: true
  }

  export type Rework_hxe110MaxAggregateInputType = {
    id?: true
    meter_type?: true
    meter_serial?: true
    tanggal?: true
    modem?: true
    baterai?: true
    defect?: true
  }

  export type Rework_hxe110CountAggregateInputType = {
    id?: true
    meter_type?: true
    meter_serial?: true
    tanggal?: true
    modem?: true
    baterai?: true
    defect?: true
    _all?: true
  }

  export type Rework_hxe110AggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which rework_hxe110 to aggregate.
     */
    where?: rework_hxe110WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rework_hxe110s to fetch.
     */
    orderBy?: rework_hxe110OrderByWithRelationInput | rework_hxe110OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: rework_hxe110WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rework_hxe110s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rework_hxe110s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned rework_hxe110s
    **/
    _count?: true | Rework_hxe110CountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Rework_hxe110AvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Rework_hxe110SumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Rework_hxe110MinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Rework_hxe110MaxAggregateInputType
  }

  export type GetRework_hxe110AggregateType<T extends Rework_hxe110AggregateArgs> = {
        [P in keyof T & keyof AggregateRework_hxe110]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRework_hxe110[P]>
      : GetScalarType<T[P], AggregateRework_hxe110[P]>
  }




  export type rework_hxe110GroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: rework_hxe110WhereInput
    orderBy?: rework_hxe110OrderByWithAggregationInput | rework_hxe110OrderByWithAggregationInput[]
    by: Rework_hxe110ScalarFieldEnum[] | Rework_hxe110ScalarFieldEnum
    having?: rework_hxe110ScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Rework_hxe110CountAggregateInputType | true
    _avg?: Rework_hxe110AvgAggregateInputType
    _sum?: Rework_hxe110SumAggregateInputType
    _min?: Rework_hxe110MinAggregateInputType
    _max?: Rework_hxe110MaxAggregateInputType
  }

  export type Rework_hxe110GroupByOutputType = {
    id: number
    meter_type: string
    meter_serial: string
    tanggal: Date
    modem: string
    baterai: string
    defect: string
    _count: Rework_hxe110CountAggregateOutputType | null
    _avg: Rework_hxe110AvgAggregateOutputType | null
    _sum: Rework_hxe110SumAggregateOutputType | null
    _min: Rework_hxe110MinAggregateOutputType | null
    _max: Rework_hxe110MaxAggregateOutputType | null
  }

  type GetRework_hxe110GroupByPayload<T extends rework_hxe110GroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Rework_hxe110GroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Rework_hxe110GroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Rework_hxe110GroupByOutputType[P]>
            : GetScalarType<T[P], Rework_hxe110GroupByOutputType[P]>
        }
      >
    >


  export type rework_hxe110Select<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    meter_type?: boolean
    meter_serial?: boolean
    tanggal?: boolean
    modem?: boolean
    baterai?: boolean
    defect?: boolean
  }, ExtArgs["result"]["rework_hxe110"]>

  export type rework_hxe110SelectScalar = {
    id?: boolean
    meter_type?: boolean
    meter_serial?: boolean
    tanggal?: boolean
    modem?: boolean
    baterai?: boolean
    defect?: boolean
  }


  export type $rework_hxe110Payload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "rework_hxe110"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      meter_type: string
      meter_serial: string
      tanggal: Date
      modem: string
      baterai: string
      defect: string
    }, ExtArgs["result"]["rework_hxe110"]>
    composites: {}
  }


  type rework_hxe110GetPayload<S extends boolean | null | undefined | rework_hxe110DefaultArgs> = $Result.GetResult<Prisma.$rework_hxe110Payload, S>

  type rework_hxe110CountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<rework_hxe110FindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Rework_hxe110CountAggregateInputType | true
    }

  export interface rework_hxe110Delegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['rework_hxe110'], meta: { name: 'rework_hxe110' } }
    /**
     * Find zero or one Rework_hxe110 that matches the filter.
     * @param {rework_hxe110FindUniqueArgs} args - Arguments to find a Rework_hxe110
     * @example
     * // Get one Rework_hxe110
     * const rework_hxe110 = await prisma.rework_hxe110.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends rework_hxe110FindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, rework_hxe110FindUniqueArgs<ExtArgs>>
    ): Prisma__rework_hxe110Client<$Result.GetResult<Prisma.$rework_hxe110Payload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Rework_hxe110 that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {rework_hxe110FindUniqueOrThrowArgs} args - Arguments to find a Rework_hxe110
     * @example
     * // Get one Rework_hxe110
     * const rework_hxe110 = await prisma.rework_hxe110.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends rework_hxe110FindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, rework_hxe110FindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__rework_hxe110Client<$Result.GetResult<Prisma.$rework_hxe110Payload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Rework_hxe110 that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rework_hxe110FindFirstArgs} args - Arguments to find a Rework_hxe110
     * @example
     * // Get one Rework_hxe110
     * const rework_hxe110 = await prisma.rework_hxe110.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends rework_hxe110FindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, rework_hxe110FindFirstArgs<ExtArgs>>
    ): Prisma__rework_hxe110Client<$Result.GetResult<Prisma.$rework_hxe110Payload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Rework_hxe110 that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rework_hxe110FindFirstOrThrowArgs} args - Arguments to find a Rework_hxe110
     * @example
     * // Get one Rework_hxe110
     * const rework_hxe110 = await prisma.rework_hxe110.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends rework_hxe110FindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, rework_hxe110FindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__rework_hxe110Client<$Result.GetResult<Prisma.$rework_hxe110Payload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Rework_hxe110s that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rework_hxe110FindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Rework_hxe110s
     * const rework_hxe110s = await prisma.rework_hxe110.findMany()
     * 
     * // Get first 10 Rework_hxe110s
     * const rework_hxe110s = await prisma.rework_hxe110.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rework_hxe110WithIdOnly = await prisma.rework_hxe110.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends rework_hxe110FindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, rework_hxe110FindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rework_hxe110Payload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Rework_hxe110.
     * @param {rework_hxe110CreateArgs} args - Arguments to create a Rework_hxe110.
     * @example
     * // Create one Rework_hxe110
     * const Rework_hxe110 = await prisma.rework_hxe110.create({
     *   data: {
     *     // ... data to create a Rework_hxe110
     *   }
     * })
     * 
    **/
    create<T extends rework_hxe110CreateArgs<ExtArgs>>(
      args: SelectSubset<T, rework_hxe110CreateArgs<ExtArgs>>
    ): Prisma__rework_hxe110Client<$Result.GetResult<Prisma.$rework_hxe110Payload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Rework_hxe110s.
     *     @param {rework_hxe110CreateManyArgs} args - Arguments to create many Rework_hxe110s.
     *     @example
     *     // Create many Rework_hxe110s
     *     const rework_hxe110 = await prisma.rework_hxe110.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends rework_hxe110CreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, rework_hxe110CreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Rework_hxe110.
     * @param {rework_hxe110DeleteArgs} args - Arguments to delete one Rework_hxe110.
     * @example
     * // Delete one Rework_hxe110
     * const Rework_hxe110 = await prisma.rework_hxe110.delete({
     *   where: {
     *     // ... filter to delete one Rework_hxe110
     *   }
     * })
     * 
    **/
    delete<T extends rework_hxe110DeleteArgs<ExtArgs>>(
      args: SelectSubset<T, rework_hxe110DeleteArgs<ExtArgs>>
    ): Prisma__rework_hxe110Client<$Result.GetResult<Prisma.$rework_hxe110Payload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Rework_hxe110.
     * @param {rework_hxe110UpdateArgs} args - Arguments to update one Rework_hxe110.
     * @example
     * // Update one Rework_hxe110
     * const rework_hxe110 = await prisma.rework_hxe110.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends rework_hxe110UpdateArgs<ExtArgs>>(
      args: SelectSubset<T, rework_hxe110UpdateArgs<ExtArgs>>
    ): Prisma__rework_hxe110Client<$Result.GetResult<Prisma.$rework_hxe110Payload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Rework_hxe110s.
     * @param {rework_hxe110DeleteManyArgs} args - Arguments to filter Rework_hxe110s to delete.
     * @example
     * // Delete a few Rework_hxe110s
     * const { count } = await prisma.rework_hxe110.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends rework_hxe110DeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, rework_hxe110DeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rework_hxe110s.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rework_hxe110UpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Rework_hxe110s
     * const rework_hxe110 = await prisma.rework_hxe110.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends rework_hxe110UpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, rework_hxe110UpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Rework_hxe110.
     * @param {rework_hxe110UpsertArgs} args - Arguments to update or create a Rework_hxe110.
     * @example
     * // Update or create a Rework_hxe110
     * const rework_hxe110 = await prisma.rework_hxe110.upsert({
     *   create: {
     *     // ... data to create a Rework_hxe110
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Rework_hxe110 we want to update
     *   }
     * })
    **/
    upsert<T extends rework_hxe110UpsertArgs<ExtArgs>>(
      args: SelectSubset<T, rework_hxe110UpsertArgs<ExtArgs>>
    ): Prisma__rework_hxe110Client<$Result.GetResult<Prisma.$rework_hxe110Payload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Rework_hxe110s.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rework_hxe110CountArgs} args - Arguments to filter Rework_hxe110s to count.
     * @example
     * // Count the number of Rework_hxe110s
     * const count = await prisma.rework_hxe110.count({
     *   where: {
     *     // ... the filter for the Rework_hxe110s we want to count
     *   }
     * })
    **/
    count<T extends rework_hxe110CountArgs>(
      args?: Subset<T, rework_hxe110CountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Rework_hxe110CountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Rework_hxe110.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Rework_hxe110AggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Rework_hxe110AggregateArgs>(args: Subset<T, Rework_hxe110AggregateArgs>): Prisma.PrismaPromise<GetRework_hxe110AggregateType<T>>

    /**
     * Group by Rework_hxe110.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rework_hxe110GroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends rework_hxe110GroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: rework_hxe110GroupByArgs['orderBy'] }
        : { orderBy?: rework_hxe110GroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, rework_hxe110GroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRework_hxe110GroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the rework_hxe110 model
   */
  readonly fields: rework_hxe110FieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for rework_hxe110.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__rework_hxe110Client<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the rework_hxe110 model
   */ 
  interface rework_hxe110FieldRefs {
    readonly id: FieldRef<"rework_hxe110", 'Int'>
    readonly meter_type: FieldRef<"rework_hxe110", 'String'>
    readonly meter_serial: FieldRef<"rework_hxe110", 'String'>
    readonly tanggal: FieldRef<"rework_hxe110", 'DateTime'>
    readonly modem: FieldRef<"rework_hxe110", 'String'>
    readonly baterai: FieldRef<"rework_hxe110", 'String'>
    readonly defect: FieldRef<"rework_hxe110", 'String'>
  }
    

  // Custom InputTypes

  /**
   * rework_hxe110 findUnique
   */
  export type rework_hxe110FindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rework_hxe110
     */
    select?: rework_hxe110Select<ExtArgs> | null
    /**
     * Filter, which rework_hxe110 to fetch.
     */
    where: rework_hxe110WhereUniqueInput
  }


  /**
   * rework_hxe110 findUniqueOrThrow
   */
  export type rework_hxe110FindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rework_hxe110
     */
    select?: rework_hxe110Select<ExtArgs> | null
    /**
     * Filter, which rework_hxe110 to fetch.
     */
    where: rework_hxe110WhereUniqueInput
  }


  /**
   * rework_hxe110 findFirst
   */
  export type rework_hxe110FindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rework_hxe110
     */
    select?: rework_hxe110Select<ExtArgs> | null
    /**
     * Filter, which rework_hxe110 to fetch.
     */
    where?: rework_hxe110WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rework_hxe110s to fetch.
     */
    orderBy?: rework_hxe110OrderByWithRelationInput | rework_hxe110OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for rework_hxe110s.
     */
    cursor?: rework_hxe110WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rework_hxe110s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rework_hxe110s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of rework_hxe110s.
     */
    distinct?: Rework_hxe110ScalarFieldEnum | Rework_hxe110ScalarFieldEnum[]
  }


  /**
   * rework_hxe110 findFirstOrThrow
   */
  export type rework_hxe110FindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rework_hxe110
     */
    select?: rework_hxe110Select<ExtArgs> | null
    /**
     * Filter, which rework_hxe110 to fetch.
     */
    where?: rework_hxe110WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rework_hxe110s to fetch.
     */
    orderBy?: rework_hxe110OrderByWithRelationInput | rework_hxe110OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for rework_hxe110s.
     */
    cursor?: rework_hxe110WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rework_hxe110s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rework_hxe110s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of rework_hxe110s.
     */
    distinct?: Rework_hxe110ScalarFieldEnum | Rework_hxe110ScalarFieldEnum[]
  }


  /**
   * rework_hxe110 findMany
   */
  export type rework_hxe110FindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rework_hxe110
     */
    select?: rework_hxe110Select<ExtArgs> | null
    /**
     * Filter, which rework_hxe110s to fetch.
     */
    where?: rework_hxe110WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rework_hxe110s to fetch.
     */
    orderBy?: rework_hxe110OrderByWithRelationInput | rework_hxe110OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing rework_hxe110s.
     */
    cursor?: rework_hxe110WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rework_hxe110s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rework_hxe110s.
     */
    skip?: number
    distinct?: Rework_hxe110ScalarFieldEnum | Rework_hxe110ScalarFieldEnum[]
  }


  /**
   * rework_hxe110 create
   */
  export type rework_hxe110CreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rework_hxe110
     */
    select?: rework_hxe110Select<ExtArgs> | null
    /**
     * The data needed to create a rework_hxe110.
     */
    data: XOR<rework_hxe110CreateInput, rework_hxe110UncheckedCreateInput>
  }


  /**
   * rework_hxe110 createMany
   */
  export type rework_hxe110CreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many rework_hxe110s.
     */
    data: rework_hxe110CreateManyInput | rework_hxe110CreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * rework_hxe110 update
   */
  export type rework_hxe110UpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rework_hxe110
     */
    select?: rework_hxe110Select<ExtArgs> | null
    /**
     * The data needed to update a rework_hxe110.
     */
    data: XOR<rework_hxe110UpdateInput, rework_hxe110UncheckedUpdateInput>
    /**
     * Choose, which rework_hxe110 to update.
     */
    where: rework_hxe110WhereUniqueInput
  }


  /**
   * rework_hxe110 updateMany
   */
  export type rework_hxe110UpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update rework_hxe110s.
     */
    data: XOR<rework_hxe110UpdateManyMutationInput, rework_hxe110UncheckedUpdateManyInput>
    /**
     * Filter which rework_hxe110s to update
     */
    where?: rework_hxe110WhereInput
  }


  /**
   * rework_hxe110 upsert
   */
  export type rework_hxe110UpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rework_hxe110
     */
    select?: rework_hxe110Select<ExtArgs> | null
    /**
     * The filter to search for the rework_hxe110 to update in case it exists.
     */
    where: rework_hxe110WhereUniqueInput
    /**
     * In case the rework_hxe110 found by the `where` argument doesn't exist, create a new rework_hxe110 with this data.
     */
    create: XOR<rework_hxe110CreateInput, rework_hxe110UncheckedCreateInput>
    /**
     * In case the rework_hxe110 was found with the provided `where` argument, update it with this data.
     */
    update: XOR<rework_hxe110UpdateInput, rework_hxe110UncheckedUpdateInput>
  }


  /**
   * rework_hxe110 delete
   */
  export type rework_hxe110DeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rework_hxe110
     */
    select?: rework_hxe110Select<ExtArgs> | null
    /**
     * Filter which rework_hxe110 to delete.
     */
    where: rework_hxe110WhereUniqueInput
  }


  /**
   * rework_hxe110 deleteMany
   */
  export type rework_hxe110DeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which rework_hxe110s to delete
     */
    where?: rework_hxe110WhereInput
  }


  /**
   * rework_hxe110 without action
   */
  export type rework_hxe110DefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rework_hxe110
     */
    select?: rework_hxe110Select<ExtArgs> | null
  }



  /**
   * Model rework_pallete
   */

  export type AggregateRework_pallete = {
    _count: Rework_palleteCountAggregateOutputType | null
    _avg: Rework_palleteAvgAggregateOutputType | null
    _sum: Rework_palleteSumAggregateOutputType | null
    _min: Rework_palleteMinAggregateOutputType | null
    _max: Rework_palleteMaxAggregateOutputType | null
  }

  export type Rework_palleteAvgAggregateOutputType = {
    id: number | null
  }

  export type Rework_palleteSumAggregateOutputType = {
    id: number | null
  }

  export type Rework_palleteMinAggregateOutputType = {
    id: number | null
    serial: string | null
    timestamp: Date | null
    line: string | null
    type: string | null
    location: string | null
  }

  export type Rework_palleteMaxAggregateOutputType = {
    id: number | null
    serial: string | null
    timestamp: Date | null
    line: string | null
    type: string | null
    location: string | null
  }

  export type Rework_palleteCountAggregateOutputType = {
    id: number
    serial: number
    timestamp: number
    line: number
    type: number
    location: number
    _all: number
  }


  export type Rework_palleteAvgAggregateInputType = {
    id?: true
  }

  export type Rework_palleteSumAggregateInputType = {
    id?: true
  }

  export type Rework_palleteMinAggregateInputType = {
    id?: true
    serial?: true
    timestamp?: true
    line?: true
    type?: true
    location?: true
  }

  export type Rework_palleteMaxAggregateInputType = {
    id?: true
    serial?: true
    timestamp?: true
    line?: true
    type?: true
    location?: true
  }

  export type Rework_palleteCountAggregateInputType = {
    id?: true
    serial?: true
    timestamp?: true
    line?: true
    type?: true
    location?: true
    _all?: true
  }

  export type Rework_palleteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which rework_pallete to aggregate.
     */
    where?: rework_palleteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rework_palletes to fetch.
     */
    orderBy?: rework_palleteOrderByWithRelationInput | rework_palleteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: rework_palleteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rework_palletes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rework_palletes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned rework_palletes
    **/
    _count?: true | Rework_palleteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Rework_palleteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Rework_palleteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Rework_palleteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Rework_palleteMaxAggregateInputType
  }

  export type GetRework_palleteAggregateType<T extends Rework_palleteAggregateArgs> = {
        [P in keyof T & keyof AggregateRework_pallete]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRework_pallete[P]>
      : GetScalarType<T[P], AggregateRework_pallete[P]>
  }




  export type rework_palleteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: rework_palleteWhereInput
    orderBy?: rework_palleteOrderByWithAggregationInput | rework_palleteOrderByWithAggregationInput[]
    by: Rework_palleteScalarFieldEnum[] | Rework_palleteScalarFieldEnum
    having?: rework_palleteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Rework_palleteCountAggregateInputType | true
    _avg?: Rework_palleteAvgAggregateInputType
    _sum?: Rework_palleteSumAggregateInputType
    _min?: Rework_palleteMinAggregateInputType
    _max?: Rework_palleteMaxAggregateInputType
  }

  export type Rework_palleteGroupByOutputType = {
    id: number
    serial: string
    timestamp: Date
    line: string
    type: string
    location: string | null
    _count: Rework_palleteCountAggregateOutputType | null
    _avg: Rework_palleteAvgAggregateOutputType | null
    _sum: Rework_palleteSumAggregateOutputType | null
    _min: Rework_palleteMinAggregateOutputType | null
    _max: Rework_palleteMaxAggregateOutputType | null
  }

  type GetRework_palleteGroupByPayload<T extends rework_palleteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Rework_palleteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Rework_palleteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Rework_palleteGroupByOutputType[P]>
            : GetScalarType<T[P], Rework_palleteGroupByOutputType[P]>
        }
      >
    >


  export type rework_palleteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serial?: boolean
    timestamp?: boolean
    line?: boolean
    type?: boolean
    location?: boolean
  }, ExtArgs["result"]["rework_pallete"]>

  export type rework_palleteSelectScalar = {
    id?: boolean
    serial?: boolean
    timestamp?: boolean
    line?: boolean
    type?: boolean
    location?: boolean
  }


  export type $rework_palletePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "rework_pallete"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      serial: string
      timestamp: Date
      line: string
      type: string
      location: string | null
    }, ExtArgs["result"]["rework_pallete"]>
    composites: {}
  }


  type rework_palleteGetPayload<S extends boolean | null | undefined | rework_palleteDefaultArgs> = $Result.GetResult<Prisma.$rework_palletePayload, S>

  type rework_palleteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<rework_palleteFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Rework_palleteCountAggregateInputType | true
    }

  export interface rework_palleteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['rework_pallete'], meta: { name: 'rework_pallete' } }
    /**
     * Find zero or one Rework_pallete that matches the filter.
     * @param {rework_palleteFindUniqueArgs} args - Arguments to find a Rework_pallete
     * @example
     * // Get one Rework_pallete
     * const rework_pallete = await prisma.rework_pallete.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends rework_palleteFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, rework_palleteFindUniqueArgs<ExtArgs>>
    ): Prisma__rework_palleteClient<$Result.GetResult<Prisma.$rework_palletePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Rework_pallete that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {rework_palleteFindUniqueOrThrowArgs} args - Arguments to find a Rework_pallete
     * @example
     * // Get one Rework_pallete
     * const rework_pallete = await prisma.rework_pallete.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends rework_palleteFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, rework_palleteFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__rework_palleteClient<$Result.GetResult<Prisma.$rework_palletePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Rework_pallete that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rework_palleteFindFirstArgs} args - Arguments to find a Rework_pallete
     * @example
     * // Get one Rework_pallete
     * const rework_pallete = await prisma.rework_pallete.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends rework_palleteFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, rework_palleteFindFirstArgs<ExtArgs>>
    ): Prisma__rework_palleteClient<$Result.GetResult<Prisma.$rework_palletePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Rework_pallete that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rework_palleteFindFirstOrThrowArgs} args - Arguments to find a Rework_pallete
     * @example
     * // Get one Rework_pallete
     * const rework_pallete = await prisma.rework_pallete.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends rework_palleteFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, rework_palleteFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__rework_palleteClient<$Result.GetResult<Prisma.$rework_palletePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Rework_palletes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rework_palleteFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Rework_palletes
     * const rework_palletes = await prisma.rework_pallete.findMany()
     * 
     * // Get first 10 Rework_palletes
     * const rework_palletes = await prisma.rework_pallete.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rework_palleteWithIdOnly = await prisma.rework_pallete.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends rework_palleteFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, rework_palleteFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rework_palletePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Rework_pallete.
     * @param {rework_palleteCreateArgs} args - Arguments to create a Rework_pallete.
     * @example
     * // Create one Rework_pallete
     * const Rework_pallete = await prisma.rework_pallete.create({
     *   data: {
     *     // ... data to create a Rework_pallete
     *   }
     * })
     * 
    **/
    create<T extends rework_palleteCreateArgs<ExtArgs>>(
      args: SelectSubset<T, rework_palleteCreateArgs<ExtArgs>>
    ): Prisma__rework_palleteClient<$Result.GetResult<Prisma.$rework_palletePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Rework_palletes.
     *     @param {rework_palleteCreateManyArgs} args - Arguments to create many Rework_palletes.
     *     @example
     *     // Create many Rework_palletes
     *     const rework_pallete = await prisma.rework_pallete.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends rework_palleteCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, rework_palleteCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Rework_pallete.
     * @param {rework_palleteDeleteArgs} args - Arguments to delete one Rework_pallete.
     * @example
     * // Delete one Rework_pallete
     * const Rework_pallete = await prisma.rework_pallete.delete({
     *   where: {
     *     // ... filter to delete one Rework_pallete
     *   }
     * })
     * 
    **/
    delete<T extends rework_palleteDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, rework_palleteDeleteArgs<ExtArgs>>
    ): Prisma__rework_palleteClient<$Result.GetResult<Prisma.$rework_palletePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Rework_pallete.
     * @param {rework_palleteUpdateArgs} args - Arguments to update one Rework_pallete.
     * @example
     * // Update one Rework_pallete
     * const rework_pallete = await prisma.rework_pallete.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends rework_palleteUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, rework_palleteUpdateArgs<ExtArgs>>
    ): Prisma__rework_palleteClient<$Result.GetResult<Prisma.$rework_palletePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Rework_palletes.
     * @param {rework_palleteDeleteManyArgs} args - Arguments to filter Rework_palletes to delete.
     * @example
     * // Delete a few Rework_palletes
     * const { count } = await prisma.rework_pallete.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends rework_palleteDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, rework_palleteDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rework_palletes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rework_palleteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Rework_palletes
     * const rework_pallete = await prisma.rework_pallete.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends rework_palleteUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, rework_palleteUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Rework_pallete.
     * @param {rework_palleteUpsertArgs} args - Arguments to update or create a Rework_pallete.
     * @example
     * // Update or create a Rework_pallete
     * const rework_pallete = await prisma.rework_pallete.upsert({
     *   create: {
     *     // ... data to create a Rework_pallete
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Rework_pallete we want to update
     *   }
     * })
    **/
    upsert<T extends rework_palleteUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, rework_palleteUpsertArgs<ExtArgs>>
    ): Prisma__rework_palleteClient<$Result.GetResult<Prisma.$rework_palletePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Rework_palletes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rework_palleteCountArgs} args - Arguments to filter Rework_palletes to count.
     * @example
     * // Count the number of Rework_palletes
     * const count = await prisma.rework_pallete.count({
     *   where: {
     *     // ... the filter for the Rework_palletes we want to count
     *   }
     * })
    **/
    count<T extends rework_palleteCountArgs>(
      args?: Subset<T, rework_palleteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Rework_palleteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Rework_pallete.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Rework_palleteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Rework_palleteAggregateArgs>(args: Subset<T, Rework_palleteAggregateArgs>): Prisma.PrismaPromise<GetRework_palleteAggregateType<T>>

    /**
     * Group by Rework_pallete.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rework_palleteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends rework_palleteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: rework_palleteGroupByArgs['orderBy'] }
        : { orderBy?: rework_palleteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, rework_palleteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRework_palleteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the rework_pallete model
   */
  readonly fields: rework_palleteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for rework_pallete.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__rework_palleteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the rework_pallete model
   */ 
  interface rework_palleteFieldRefs {
    readonly id: FieldRef<"rework_pallete", 'Int'>
    readonly serial: FieldRef<"rework_pallete", 'String'>
    readonly timestamp: FieldRef<"rework_pallete", 'DateTime'>
    readonly line: FieldRef<"rework_pallete", 'String'>
    readonly type: FieldRef<"rework_pallete", 'String'>
    readonly location: FieldRef<"rework_pallete", 'String'>
  }
    

  // Custom InputTypes

  /**
   * rework_pallete findUnique
   */
  export type rework_palleteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rework_pallete
     */
    select?: rework_palleteSelect<ExtArgs> | null
    /**
     * Filter, which rework_pallete to fetch.
     */
    where: rework_palleteWhereUniqueInput
  }


  /**
   * rework_pallete findUniqueOrThrow
   */
  export type rework_palleteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rework_pallete
     */
    select?: rework_palleteSelect<ExtArgs> | null
    /**
     * Filter, which rework_pallete to fetch.
     */
    where: rework_palleteWhereUniqueInput
  }


  /**
   * rework_pallete findFirst
   */
  export type rework_palleteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rework_pallete
     */
    select?: rework_palleteSelect<ExtArgs> | null
    /**
     * Filter, which rework_pallete to fetch.
     */
    where?: rework_palleteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rework_palletes to fetch.
     */
    orderBy?: rework_palleteOrderByWithRelationInput | rework_palleteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for rework_palletes.
     */
    cursor?: rework_palleteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rework_palletes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rework_palletes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of rework_palletes.
     */
    distinct?: Rework_palleteScalarFieldEnum | Rework_palleteScalarFieldEnum[]
  }


  /**
   * rework_pallete findFirstOrThrow
   */
  export type rework_palleteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rework_pallete
     */
    select?: rework_palleteSelect<ExtArgs> | null
    /**
     * Filter, which rework_pallete to fetch.
     */
    where?: rework_palleteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rework_palletes to fetch.
     */
    orderBy?: rework_palleteOrderByWithRelationInput | rework_palleteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for rework_palletes.
     */
    cursor?: rework_palleteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rework_palletes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rework_palletes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of rework_palletes.
     */
    distinct?: Rework_palleteScalarFieldEnum | Rework_palleteScalarFieldEnum[]
  }


  /**
   * rework_pallete findMany
   */
  export type rework_palleteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rework_pallete
     */
    select?: rework_palleteSelect<ExtArgs> | null
    /**
     * Filter, which rework_palletes to fetch.
     */
    where?: rework_palleteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rework_palletes to fetch.
     */
    orderBy?: rework_palleteOrderByWithRelationInput | rework_palleteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing rework_palletes.
     */
    cursor?: rework_palleteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rework_palletes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rework_palletes.
     */
    skip?: number
    distinct?: Rework_palleteScalarFieldEnum | Rework_palleteScalarFieldEnum[]
  }


  /**
   * rework_pallete create
   */
  export type rework_palleteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rework_pallete
     */
    select?: rework_palleteSelect<ExtArgs> | null
    /**
     * The data needed to create a rework_pallete.
     */
    data: XOR<rework_palleteCreateInput, rework_palleteUncheckedCreateInput>
  }


  /**
   * rework_pallete createMany
   */
  export type rework_palleteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many rework_palletes.
     */
    data: rework_palleteCreateManyInput | rework_palleteCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * rework_pallete update
   */
  export type rework_palleteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rework_pallete
     */
    select?: rework_palleteSelect<ExtArgs> | null
    /**
     * The data needed to update a rework_pallete.
     */
    data: XOR<rework_palleteUpdateInput, rework_palleteUncheckedUpdateInput>
    /**
     * Choose, which rework_pallete to update.
     */
    where: rework_palleteWhereUniqueInput
  }


  /**
   * rework_pallete updateMany
   */
  export type rework_palleteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update rework_palletes.
     */
    data: XOR<rework_palleteUpdateManyMutationInput, rework_palleteUncheckedUpdateManyInput>
    /**
     * Filter which rework_palletes to update
     */
    where?: rework_palleteWhereInput
  }


  /**
   * rework_pallete upsert
   */
  export type rework_palleteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rework_pallete
     */
    select?: rework_palleteSelect<ExtArgs> | null
    /**
     * The filter to search for the rework_pallete to update in case it exists.
     */
    where: rework_palleteWhereUniqueInput
    /**
     * In case the rework_pallete found by the `where` argument doesn't exist, create a new rework_pallete with this data.
     */
    create: XOR<rework_palleteCreateInput, rework_palleteUncheckedCreateInput>
    /**
     * In case the rework_pallete was found with the provided `where` argument, update it with this data.
     */
    update: XOR<rework_palleteUpdateInput, rework_palleteUncheckedUpdateInput>
  }


  /**
   * rework_pallete delete
   */
  export type rework_palleteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rework_pallete
     */
    select?: rework_palleteSelect<ExtArgs> | null
    /**
     * Filter which rework_pallete to delete.
     */
    where: rework_palleteWhereUniqueInput
  }


  /**
   * rework_pallete deleteMany
   */
  export type rework_palleteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which rework_palletes to delete
     */
    where?: rework_palleteWhereInput
  }


  /**
   * rework_pallete without action
   */
  export type rework_palleteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rework_pallete
     */
    select?: rework_palleteSelect<ExtArgs> | null
  }



  /**
   * Model serial_check
   */

  export type AggregateSerial_check = {
    _count: Serial_checkCountAggregateOutputType | null
    _avg: Serial_checkAvgAggregateOutputType | null
    _sum: Serial_checkSumAggregateOutputType | null
    _min: Serial_checkMinAggregateOutputType | null
    _max: Serial_checkMaxAggregateOutputType | null
  }

  export type Serial_checkAvgAggregateOutputType = {
    id: number | null
    box_id: number | null
    attachment_id: number | null
    attachment2_id: number | null
  }

  export type Serial_checkSumAggregateOutputType = {
    id: number | null
    box_id: number | null
    attachment_id: number | null
    attachment2_id: number | null
  }

  export type Serial_checkMinAggregateOutputType = {
    id: number | null
    serial: string | null
    timestamp: Date | null
    line: string | null
    type: string | null
    orderno: string | null
    area: string | null
    jenis: string | null
    box_id: number | null
    attachment_id: number | null
    attachment2_id: number | null
    remain: string | null
    garansi: string | null
  }

  export type Serial_checkMaxAggregateOutputType = {
    id: number | null
    serial: string | null
    timestamp: Date | null
    line: string | null
    type: string | null
    orderno: string | null
    area: string | null
    jenis: string | null
    box_id: number | null
    attachment_id: number | null
    attachment2_id: number | null
    remain: string | null
    garansi: string | null
  }

  export type Serial_checkCountAggregateOutputType = {
    id: number
    serial: number
    timestamp: number
    line: number
    type: number
    orderno: number
    area: number
    jenis: number
    box_id: number
    attachment_id: number
    attachment2_id: number
    remain: number
    garansi: number
    _all: number
  }


  export type Serial_checkAvgAggregateInputType = {
    id?: true
    box_id?: true
    attachment_id?: true
    attachment2_id?: true
  }

  export type Serial_checkSumAggregateInputType = {
    id?: true
    box_id?: true
    attachment_id?: true
    attachment2_id?: true
  }

  export type Serial_checkMinAggregateInputType = {
    id?: true
    serial?: true
    timestamp?: true
    line?: true
    type?: true
    orderno?: true
    area?: true
    jenis?: true
    box_id?: true
    attachment_id?: true
    attachment2_id?: true
    remain?: true
    garansi?: true
  }

  export type Serial_checkMaxAggregateInputType = {
    id?: true
    serial?: true
    timestamp?: true
    line?: true
    type?: true
    orderno?: true
    area?: true
    jenis?: true
    box_id?: true
    attachment_id?: true
    attachment2_id?: true
    remain?: true
    garansi?: true
  }

  export type Serial_checkCountAggregateInputType = {
    id?: true
    serial?: true
    timestamp?: true
    line?: true
    type?: true
    orderno?: true
    area?: true
    jenis?: true
    box_id?: true
    attachment_id?: true
    attachment2_id?: true
    remain?: true
    garansi?: true
    _all?: true
  }

  export type Serial_checkAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which serial_check to aggregate.
     */
    where?: serial_checkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of serial_checks to fetch.
     */
    orderBy?: serial_checkOrderByWithRelationInput | serial_checkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: serial_checkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` serial_checks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` serial_checks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned serial_checks
    **/
    _count?: true | Serial_checkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Serial_checkAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Serial_checkSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Serial_checkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Serial_checkMaxAggregateInputType
  }

  export type GetSerial_checkAggregateType<T extends Serial_checkAggregateArgs> = {
        [P in keyof T & keyof AggregateSerial_check]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSerial_check[P]>
      : GetScalarType<T[P], AggregateSerial_check[P]>
  }




  export type serial_checkGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: serial_checkWhereInput
    orderBy?: serial_checkOrderByWithAggregationInput | serial_checkOrderByWithAggregationInput[]
    by: Serial_checkScalarFieldEnum[] | Serial_checkScalarFieldEnum
    having?: serial_checkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Serial_checkCountAggregateInputType | true
    _avg?: Serial_checkAvgAggregateInputType
    _sum?: Serial_checkSumAggregateInputType
    _min?: Serial_checkMinAggregateInputType
    _max?: Serial_checkMaxAggregateInputType
  }

  export type Serial_checkGroupByOutputType = {
    id: number
    serial: string
    timestamp: Date
    line: string
    type: string
    orderno: string
    area: string | null
    jenis: string | null
    box_id: number | null
    attachment_id: number | null
    attachment2_id: number | null
    remain: string
    garansi: string | null
    _count: Serial_checkCountAggregateOutputType | null
    _avg: Serial_checkAvgAggregateOutputType | null
    _sum: Serial_checkSumAggregateOutputType | null
    _min: Serial_checkMinAggregateOutputType | null
    _max: Serial_checkMaxAggregateOutputType | null
  }

  type GetSerial_checkGroupByPayload<T extends serial_checkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Serial_checkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Serial_checkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Serial_checkGroupByOutputType[P]>
            : GetScalarType<T[P], Serial_checkGroupByOutputType[P]>
        }
      >
    >


  export type serial_checkSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serial?: boolean
    timestamp?: boolean
    line?: boolean
    type?: boolean
    orderno?: boolean
    area?: boolean
    jenis?: boolean
    box_id?: boolean
    attachment_id?: boolean
    attachment2_id?: boolean
    remain?: boolean
    garansi?: boolean
  }, ExtArgs["result"]["serial_check"]>

  export type serial_checkSelectScalar = {
    id?: boolean
    serial?: boolean
    timestamp?: boolean
    line?: boolean
    type?: boolean
    orderno?: boolean
    area?: boolean
    jenis?: boolean
    box_id?: boolean
    attachment_id?: boolean
    attachment2_id?: boolean
    remain?: boolean
    garansi?: boolean
  }


  export type $serial_checkPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "serial_check"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      serial: string
      timestamp: Date
      line: string
      type: string
      orderno: string
      area: string | null
      jenis: string | null
      box_id: number | null
      attachment_id: number | null
      attachment2_id: number | null
      remain: string
      garansi: string | null
    }, ExtArgs["result"]["serial_check"]>
    composites: {}
  }


  type serial_checkGetPayload<S extends boolean | null | undefined | serial_checkDefaultArgs> = $Result.GetResult<Prisma.$serial_checkPayload, S>

  type serial_checkCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<serial_checkFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Serial_checkCountAggregateInputType | true
    }

  export interface serial_checkDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['serial_check'], meta: { name: 'serial_check' } }
    /**
     * Find zero or one Serial_check that matches the filter.
     * @param {serial_checkFindUniqueArgs} args - Arguments to find a Serial_check
     * @example
     * // Get one Serial_check
     * const serial_check = await prisma.serial_check.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends serial_checkFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, serial_checkFindUniqueArgs<ExtArgs>>
    ): Prisma__serial_checkClient<$Result.GetResult<Prisma.$serial_checkPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Serial_check that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {serial_checkFindUniqueOrThrowArgs} args - Arguments to find a Serial_check
     * @example
     * // Get one Serial_check
     * const serial_check = await prisma.serial_check.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends serial_checkFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, serial_checkFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__serial_checkClient<$Result.GetResult<Prisma.$serial_checkPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Serial_check that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {serial_checkFindFirstArgs} args - Arguments to find a Serial_check
     * @example
     * // Get one Serial_check
     * const serial_check = await prisma.serial_check.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends serial_checkFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, serial_checkFindFirstArgs<ExtArgs>>
    ): Prisma__serial_checkClient<$Result.GetResult<Prisma.$serial_checkPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Serial_check that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {serial_checkFindFirstOrThrowArgs} args - Arguments to find a Serial_check
     * @example
     * // Get one Serial_check
     * const serial_check = await prisma.serial_check.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends serial_checkFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, serial_checkFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__serial_checkClient<$Result.GetResult<Prisma.$serial_checkPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Serial_checks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {serial_checkFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Serial_checks
     * const serial_checks = await prisma.serial_check.findMany()
     * 
     * // Get first 10 Serial_checks
     * const serial_checks = await prisma.serial_check.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serial_checkWithIdOnly = await prisma.serial_check.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends serial_checkFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, serial_checkFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$serial_checkPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Serial_check.
     * @param {serial_checkCreateArgs} args - Arguments to create a Serial_check.
     * @example
     * // Create one Serial_check
     * const Serial_check = await prisma.serial_check.create({
     *   data: {
     *     // ... data to create a Serial_check
     *   }
     * })
     * 
    **/
    create<T extends serial_checkCreateArgs<ExtArgs>>(
      args: SelectSubset<T, serial_checkCreateArgs<ExtArgs>>
    ): Prisma__serial_checkClient<$Result.GetResult<Prisma.$serial_checkPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Serial_checks.
     *     @param {serial_checkCreateManyArgs} args - Arguments to create many Serial_checks.
     *     @example
     *     // Create many Serial_checks
     *     const serial_check = await prisma.serial_check.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends serial_checkCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, serial_checkCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Serial_check.
     * @param {serial_checkDeleteArgs} args - Arguments to delete one Serial_check.
     * @example
     * // Delete one Serial_check
     * const Serial_check = await prisma.serial_check.delete({
     *   where: {
     *     // ... filter to delete one Serial_check
     *   }
     * })
     * 
    **/
    delete<T extends serial_checkDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, serial_checkDeleteArgs<ExtArgs>>
    ): Prisma__serial_checkClient<$Result.GetResult<Prisma.$serial_checkPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Serial_check.
     * @param {serial_checkUpdateArgs} args - Arguments to update one Serial_check.
     * @example
     * // Update one Serial_check
     * const serial_check = await prisma.serial_check.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends serial_checkUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, serial_checkUpdateArgs<ExtArgs>>
    ): Prisma__serial_checkClient<$Result.GetResult<Prisma.$serial_checkPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Serial_checks.
     * @param {serial_checkDeleteManyArgs} args - Arguments to filter Serial_checks to delete.
     * @example
     * // Delete a few Serial_checks
     * const { count } = await prisma.serial_check.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends serial_checkDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, serial_checkDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Serial_checks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {serial_checkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Serial_checks
     * const serial_check = await prisma.serial_check.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends serial_checkUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, serial_checkUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Serial_check.
     * @param {serial_checkUpsertArgs} args - Arguments to update or create a Serial_check.
     * @example
     * // Update or create a Serial_check
     * const serial_check = await prisma.serial_check.upsert({
     *   create: {
     *     // ... data to create a Serial_check
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Serial_check we want to update
     *   }
     * })
    **/
    upsert<T extends serial_checkUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, serial_checkUpsertArgs<ExtArgs>>
    ): Prisma__serial_checkClient<$Result.GetResult<Prisma.$serial_checkPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Serial_checks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {serial_checkCountArgs} args - Arguments to filter Serial_checks to count.
     * @example
     * // Count the number of Serial_checks
     * const count = await prisma.serial_check.count({
     *   where: {
     *     // ... the filter for the Serial_checks we want to count
     *   }
     * })
    **/
    count<T extends serial_checkCountArgs>(
      args?: Subset<T, serial_checkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Serial_checkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Serial_check.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Serial_checkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Serial_checkAggregateArgs>(args: Subset<T, Serial_checkAggregateArgs>): Prisma.PrismaPromise<GetSerial_checkAggregateType<T>>

    /**
     * Group by Serial_check.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {serial_checkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends serial_checkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: serial_checkGroupByArgs['orderBy'] }
        : { orderBy?: serial_checkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, serial_checkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSerial_checkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the serial_check model
   */
  readonly fields: serial_checkFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for serial_check.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__serial_checkClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the serial_check model
   */ 
  interface serial_checkFieldRefs {
    readonly id: FieldRef<"serial_check", 'Int'>
    readonly serial: FieldRef<"serial_check", 'String'>
    readonly timestamp: FieldRef<"serial_check", 'DateTime'>
    readonly line: FieldRef<"serial_check", 'String'>
    readonly type: FieldRef<"serial_check", 'String'>
    readonly orderno: FieldRef<"serial_check", 'String'>
    readonly area: FieldRef<"serial_check", 'String'>
    readonly jenis: FieldRef<"serial_check", 'String'>
    readonly box_id: FieldRef<"serial_check", 'Int'>
    readonly attachment_id: FieldRef<"serial_check", 'Int'>
    readonly attachment2_id: FieldRef<"serial_check", 'Int'>
    readonly remain: FieldRef<"serial_check", 'String'>
    readonly garansi: FieldRef<"serial_check", 'String'>
  }
    

  // Custom InputTypes

  /**
   * serial_check findUnique
   */
  export type serial_checkFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serial_check
     */
    select?: serial_checkSelect<ExtArgs> | null
    /**
     * Filter, which serial_check to fetch.
     */
    where: serial_checkWhereUniqueInput
  }


  /**
   * serial_check findUniqueOrThrow
   */
  export type serial_checkFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serial_check
     */
    select?: serial_checkSelect<ExtArgs> | null
    /**
     * Filter, which serial_check to fetch.
     */
    where: serial_checkWhereUniqueInput
  }


  /**
   * serial_check findFirst
   */
  export type serial_checkFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serial_check
     */
    select?: serial_checkSelect<ExtArgs> | null
    /**
     * Filter, which serial_check to fetch.
     */
    where?: serial_checkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of serial_checks to fetch.
     */
    orderBy?: serial_checkOrderByWithRelationInput | serial_checkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for serial_checks.
     */
    cursor?: serial_checkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` serial_checks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` serial_checks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of serial_checks.
     */
    distinct?: Serial_checkScalarFieldEnum | Serial_checkScalarFieldEnum[]
  }


  /**
   * serial_check findFirstOrThrow
   */
  export type serial_checkFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serial_check
     */
    select?: serial_checkSelect<ExtArgs> | null
    /**
     * Filter, which serial_check to fetch.
     */
    where?: serial_checkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of serial_checks to fetch.
     */
    orderBy?: serial_checkOrderByWithRelationInput | serial_checkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for serial_checks.
     */
    cursor?: serial_checkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` serial_checks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` serial_checks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of serial_checks.
     */
    distinct?: Serial_checkScalarFieldEnum | Serial_checkScalarFieldEnum[]
  }


  /**
   * serial_check findMany
   */
  export type serial_checkFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serial_check
     */
    select?: serial_checkSelect<ExtArgs> | null
    /**
     * Filter, which serial_checks to fetch.
     */
    where?: serial_checkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of serial_checks to fetch.
     */
    orderBy?: serial_checkOrderByWithRelationInput | serial_checkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing serial_checks.
     */
    cursor?: serial_checkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` serial_checks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` serial_checks.
     */
    skip?: number
    distinct?: Serial_checkScalarFieldEnum | Serial_checkScalarFieldEnum[]
  }


  /**
   * serial_check create
   */
  export type serial_checkCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serial_check
     */
    select?: serial_checkSelect<ExtArgs> | null
    /**
     * The data needed to create a serial_check.
     */
    data: XOR<serial_checkCreateInput, serial_checkUncheckedCreateInput>
  }


  /**
   * serial_check createMany
   */
  export type serial_checkCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many serial_checks.
     */
    data: serial_checkCreateManyInput | serial_checkCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * serial_check update
   */
  export type serial_checkUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serial_check
     */
    select?: serial_checkSelect<ExtArgs> | null
    /**
     * The data needed to update a serial_check.
     */
    data: XOR<serial_checkUpdateInput, serial_checkUncheckedUpdateInput>
    /**
     * Choose, which serial_check to update.
     */
    where: serial_checkWhereUniqueInput
  }


  /**
   * serial_check updateMany
   */
  export type serial_checkUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update serial_checks.
     */
    data: XOR<serial_checkUpdateManyMutationInput, serial_checkUncheckedUpdateManyInput>
    /**
     * Filter which serial_checks to update
     */
    where?: serial_checkWhereInput
  }


  /**
   * serial_check upsert
   */
  export type serial_checkUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serial_check
     */
    select?: serial_checkSelect<ExtArgs> | null
    /**
     * The filter to search for the serial_check to update in case it exists.
     */
    where: serial_checkWhereUniqueInput
    /**
     * In case the serial_check found by the `where` argument doesn't exist, create a new serial_check with this data.
     */
    create: XOR<serial_checkCreateInput, serial_checkUncheckedCreateInput>
    /**
     * In case the serial_check was found with the provided `where` argument, update it with this data.
     */
    update: XOR<serial_checkUpdateInput, serial_checkUncheckedUpdateInput>
  }


  /**
   * serial_check delete
   */
  export type serial_checkDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serial_check
     */
    select?: serial_checkSelect<ExtArgs> | null
    /**
     * Filter which serial_check to delete.
     */
    where: serial_checkWhereUniqueInput
  }


  /**
   * serial_check deleteMany
   */
  export type serial_checkDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which serial_checks to delete
     */
    where?: serial_checkWhereInput
  }


  /**
   * serial_check without action
   */
  export type serial_checkDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serial_check
     */
    select?: serial_checkSelect<ExtArgs> | null
  }



  /**
   * Model tahun_garansi
   */

  export type AggregateTahun_garansi = {
    _count: Tahun_garansiCountAggregateOutputType | null
    _avg: Tahun_garansiAvgAggregateOutputType | null
    _sum: Tahun_garansiSumAggregateOutputType | null
    _min: Tahun_garansiMinAggregateOutputType | null
    _max: Tahun_garansiMaxAggregateOutputType | null
  }

  export type Tahun_garansiAvgAggregateOutputType = {
    id_garansi: number | null
  }

  export type Tahun_garansiSumAggregateOutputType = {
    id_garansi: number | null
  }

  export type Tahun_garansiMinAggregateOutputType = {
    id_garansi: number | null
    value: string | null
  }

  export type Tahun_garansiMaxAggregateOutputType = {
    id_garansi: number | null
    value: string | null
  }

  export type Tahun_garansiCountAggregateOutputType = {
    id_garansi: number
    value: number
    _all: number
  }


  export type Tahun_garansiAvgAggregateInputType = {
    id_garansi?: true
  }

  export type Tahun_garansiSumAggregateInputType = {
    id_garansi?: true
  }

  export type Tahun_garansiMinAggregateInputType = {
    id_garansi?: true
    value?: true
  }

  export type Tahun_garansiMaxAggregateInputType = {
    id_garansi?: true
    value?: true
  }

  export type Tahun_garansiCountAggregateInputType = {
    id_garansi?: true
    value?: true
    _all?: true
  }

  export type Tahun_garansiAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tahun_garansi to aggregate.
     */
    where?: tahun_garansiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tahun_garansis to fetch.
     */
    orderBy?: tahun_garansiOrderByWithRelationInput | tahun_garansiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tahun_garansiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tahun_garansis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tahun_garansis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tahun_garansis
    **/
    _count?: true | Tahun_garansiCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Tahun_garansiAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Tahun_garansiSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tahun_garansiMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tahun_garansiMaxAggregateInputType
  }

  export type GetTahun_garansiAggregateType<T extends Tahun_garansiAggregateArgs> = {
        [P in keyof T & keyof AggregateTahun_garansi]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTahun_garansi[P]>
      : GetScalarType<T[P], AggregateTahun_garansi[P]>
  }




  export type tahun_garansiGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tahun_garansiWhereInput
    orderBy?: tahun_garansiOrderByWithAggregationInput | tahun_garansiOrderByWithAggregationInput[]
    by: Tahun_garansiScalarFieldEnum[] | Tahun_garansiScalarFieldEnum
    having?: tahun_garansiScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tahun_garansiCountAggregateInputType | true
    _avg?: Tahun_garansiAvgAggregateInputType
    _sum?: Tahun_garansiSumAggregateInputType
    _min?: Tahun_garansiMinAggregateInputType
    _max?: Tahun_garansiMaxAggregateInputType
  }

  export type Tahun_garansiGroupByOutputType = {
    id_garansi: number
    value: string
    _count: Tahun_garansiCountAggregateOutputType | null
    _avg: Tahun_garansiAvgAggregateOutputType | null
    _sum: Tahun_garansiSumAggregateOutputType | null
    _min: Tahun_garansiMinAggregateOutputType | null
    _max: Tahun_garansiMaxAggregateOutputType | null
  }

  type GetTahun_garansiGroupByPayload<T extends tahun_garansiGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tahun_garansiGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tahun_garansiGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tahun_garansiGroupByOutputType[P]>
            : GetScalarType<T[P], Tahun_garansiGroupByOutputType[P]>
        }
      >
    >


  export type tahun_garansiSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_garansi?: boolean
    value?: boolean
  }, ExtArgs["result"]["tahun_garansi"]>

  export type tahun_garansiSelectScalar = {
    id_garansi?: boolean
    value?: boolean
  }


  export type $tahun_garansiPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tahun_garansi"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id_garansi: number
      value: string
    }, ExtArgs["result"]["tahun_garansi"]>
    composites: {}
  }


  type tahun_garansiGetPayload<S extends boolean | null | undefined | tahun_garansiDefaultArgs> = $Result.GetResult<Prisma.$tahun_garansiPayload, S>

  type tahun_garansiCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<tahun_garansiFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Tahun_garansiCountAggregateInputType | true
    }

  export interface tahun_garansiDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tahun_garansi'], meta: { name: 'tahun_garansi' } }
    /**
     * Find zero or one Tahun_garansi that matches the filter.
     * @param {tahun_garansiFindUniqueArgs} args - Arguments to find a Tahun_garansi
     * @example
     * // Get one Tahun_garansi
     * const tahun_garansi = await prisma.tahun_garansi.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends tahun_garansiFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, tahun_garansiFindUniqueArgs<ExtArgs>>
    ): Prisma__tahun_garansiClient<$Result.GetResult<Prisma.$tahun_garansiPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Tahun_garansi that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {tahun_garansiFindUniqueOrThrowArgs} args - Arguments to find a Tahun_garansi
     * @example
     * // Get one Tahun_garansi
     * const tahun_garansi = await prisma.tahun_garansi.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends tahun_garansiFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, tahun_garansiFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__tahun_garansiClient<$Result.GetResult<Prisma.$tahun_garansiPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Tahun_garansi that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tahun_garansiFindFirstArgs} args - Arguments to find a Tahun_garansi
     * @example
     * // Get one Tahun_garansi
     * const tahun_garansi = await prisma.tahun_garansi.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends tahun_garansiFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, tahun_garansiFindFirstArgs<ExtArgs>>
    ): Prisma__tahun_garansiClient<$Result.GetResult<Prisma.$tahun_garansiPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Tahun_garansi that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tahun_garansiFindFirstOrThrowArgs} args - Arguments to find a Tahun_garansi
     * @example
     * // Get one Tahun_garansi
     * const tahun_garansi = await prisma.tahun_garansi.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends tahun_garansiFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, tahun_garansiFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__tahun_garansiClient<$Result.GetResult<Prisma.$tahun_garansiPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Tahun_garansis that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tahun_garansiFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tahun_garansis
     * const tahun_garansis = await prisma.tahun_garansi.findMany()
     * 
     * // Get first 10 Tahun_garansis
     * const tahun_garansis = await prisma.tahun_garansi.findMany({ take: 10 })
     * 
     * // Only select the `id_garansi`
     * const tahun_garansiWithId_garansiOnly = await prisma.tahun_garansi.findMany({ select: { id_garansi: true } })
     * 
    **/
    findMany<T extends tahun_garansiFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, tahun_garansiFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tahun_garansiPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Tahun_garansi.
     * @param {tahun_garansiCreateArgs} args - Arguments to create a Tahun_garansi.
     * @example
     * // Create one Tahun_garansi
     * const Tahun_garansi = await prisma.tahun_garansi.create({
     *   data: {
     *     // ... data to create a Tahun_garansi
     *   }
     * })
     * 
    **/
    create<T extends tahun_garansiCreateArgs<ExtArgs>>(
      args: SelectSubset<T, tahun_garansiCreateArgs<ExtArgs>>
    ): Prisma__tahun_garansiClient<$Result.GetResult<Prisma.$tahun_garansiPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Tahun_garansis.
     *     @param {tahun_garansiCreateManyArgs} args - Arguments to create many Tahun_garansis.
     *     @example
     *     // Create many Tahun_garansis
     *     const tahun_garansi = await prisma.tahun_garansi.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends tahun_garansiCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, tahun_garansiCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tahun_garansi.
     * @param {tahun_garansiDeleteArgs} args - Arguments to delete one Tahun_garansi.
     * @example
     * // Delete one Tahun_garansi
     * const Tahun_garansi = await prisma.tahun_garansi.delete({
     *   where: {
     *     // ... filter to delete one Tahun_garansi
     *   }
     * })
     * 
    **/
    delete<T extends tahun_garansiDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, tahun_garansiDeleteArgs<ExtArgs>>
    ): Prisma__tahun_garansiClient<$Result.GetResult<Prisma.$tahun_garansiPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Tahun_garansi.
     * @param {tahun_garansiUpdateArgs} args - Arguments to update one Tahun_garansi.
     * @example
     * // Update one Tahun_garansi
     * const tahun_garansi = await prisma.tahun_garansi.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends tahun_garansiUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, tahun_garansiUpdateArgs<ExtArgs>>
    ): Prisma__tahun_garansiClient<$Result.GetResult<Prisma.$tahun_garansiPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Tahun_garansis.
     * @param {tahun_garansiDeleteManyArgs} args - Arguments to filter Tahun_garansis to delete.
     * @example
     * // Delete a few Tahun_garansis
     * const { count } = await prisma.tahun_garansi.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends tahun_garansiDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, tahun_garansiDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tahun_garansis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tahun_garansiUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tahun_garansis
     * const tahun_garansi = await prisma.tahun_garansi.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends tahun_garansiUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, tahun_garansiUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tahun_garansi.
     * @param {tahun_garansiUpsertArgs} args - Arguments to update or create a Tahun_garansi.
     * @example
     * // Update or create a Tahun_garansi
     * const tahun_garansi = await prisma.tahun_garansi.upsert({
     *   create: {
     *     // ... data to create a Tahun_garansi
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tahun_garansi we want to update
     *   }
     * })
    **/
    upsert<T extends tahun_garansiUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, tahun_garansiUpsertArgs<ExtArgs>>
    ): Prisma__tahun_garansiClient<$Result.GetResult<Prisma.$tahun_garansiPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Tahun_garansis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tahun_garansiCountArgs} args - Arguments to filter Tahun_garansis to count.
     * @example
     * // Count the number of Tahun_garansis
     * const count = await prisma.tahun_garansi.count({
     *   where: {
     *     // ... the filter for the Tahun_garansis we want to count
     *   }
     * })
    **/
    count<T extends tahun_garansiCountArgs>(
      args?: Subset<T, tahun_garansiCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tahun_garansiCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tahun_garansi.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tahun_garansiAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tahun_garansiAggregateArgs>(args: Subset<T, Tahun_garansiAggregateArgs>): Prisma.PrismaPromise<GetTahun_garansiAggregateType<T>>

    /**
     * Group by Tahun_garansi.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tahun_garansiGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tahun_garansiGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tahun_garansiGroupByArgs['orderBy'] }
        : { orderBy?: tahun_garansiGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tahun_garansiGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTahun_garansiGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tahun_garansi model
   */
  readonly fields: tahun_garansiFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tahun_garansi.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tahun_garansiClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the tahun_garansi model
   */ 
  interface tahun_garansiFieldRefs {
    readonly id_garansi: FieldRef<"tahun_garansi", 'Int'>
    readonly value: FieldRef<"tahun_garansi", 'String'>
  }
    

  // Custom InputTypes

  /**
   * tahun_garansi findUnique
   */
  export type tahun_garansiFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tahun_garansi
     */
    select?: tahun_garansiSelect<ExtArgs> | null
    /**
     * Filter, which tahun_garansi to fetch.
     */
    where: tahun_garansiWhereUniqueInput
  }


  /**
   * tahun_garansi findUniqueOrThrow
   */
  export type tahun_garansiFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tahun_garansi
     */
    select?: tahun_garansiSelect<ExtArgs> | null
    /**
     * Filter, which tahun_garansi to fetch.
     */
    where: tahun_garansiWhereUniqueInput
  }


  /**
   * tahun_garansi findFirst
   */
  export type tahun_garansiFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tahun_garansi
     */
    select?: tahun_garansiSelect<ExtArgs> | null
    /**
     * Filter, which tahun_garansi to fetch.
     */
    where?: tahun_garansiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tahun_garansis to fetch.
     */
    orderBy?: tahun_garansiOrderByWithRelationInput | tahun_garansiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tahun_garansis.
     */
    cursor?: tahun_garansiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tahun_garansis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tahun_garansis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tahun_garansis.
     */
    distinct?: Tahun_garansiScalarFieldEnum | Tahun_garansiScalarFieldEnum[]
  }


  /**
   * tahun_garansi findFirstOrThrow
   */
  export type tahun_garansiFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tahun_garansi
     */
    select?: tahun_garansiSelect<ExtArgs> | null
    /**
     * Filter, which tahun_garansi to fetch.
     */
    where?: tahun_garansiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tahun_garansis to fetch.
     */
    orderBy?: tahun_garansiOrderByWithRelationInput | tahun_garansiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tahun_garansis.
     */
    cursor?: tahun_garansiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tahun_garansis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tahun_garansis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tahun_garansis.
     */
    distinct?: Tahun_garansiScalarFieldEnum | Tahun_garansiScalarFieldEnum[]
  }


  /**
   * tahun_garansi findMany
   */
  export type tahun_garansiFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tahun_garansi
     */
    select?: tahun_garansiSelect<ExtArgs> | null
    /**
     * Filter, which tahun_garansis to fetch.
     */
    where?: tahun_garansiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tahun_garansis to fetch.
     */
    orderBy?: tahun_garansiOrderByWithRelationInput | tahun_garansiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tahun_garansis.
     */
    cursor?: tahun_garansiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tahun_garansis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tahun_garansis.
     */
    skip?: number
    distinct?: Tahun_garansiScalarFieldEnum | Tahun_garansiScalarFieldEnum[]
  }


  /**
   * tahun_garansi create
   */
  export type tahun_garansiCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tahun_garansi
     */
    select?: tahun_garansiSelect<ExtArgs> | null
    /**
     * The data needed to create a tahun_garansi.
     */
    data: XOR<tahun_garansiCreateInput, tahun_garansiUncheckedCreateInput>
  }


  /**
   * tahun_garansi createMany
   */
  export type tahun_garansiCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tahun_garansis.
     */
    data: tahun_garansiCreateManyInput | tahun_garansiCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * tahun_garansi update
   */
  export type tahun_garansiUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tahun_garansi
     */
    select?: tahun_garansiSelect<ExtArgs> | null
    /**
     * The data needed to update a tahun_garansi.
     */
    data: XOR<tahun_garansiUpdateInput, tahun_garansiUncheckedUpdateInput>
    /**
     * Choose, which tahun_garansi to update.
     */
    where: tahun_garansiWhereUniqueInput
  }


  /**
   * tahun_garansi updateMany
   */
  export type tahun_garansiUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tahun_garansis.
     */
    data: XOR<tahun_garansiUpdateManyMutationInput, tahun_garansiUncheckedUpdateManyInput>
    /**
     * Filter which tahun_garansis to update
     */
    where?: tahun_garansiWhereInput
  }


  /**
   * tahun_garansi upsert
   */
  export type tahun_garansiUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tahun_garansi
     */
    select?: tahun_garansiSelect<ExtArgs> | null
    /**
     * The filter to search for the tahun_garansi to update in case it exists.
     */
    where: tahun_garansiWhereUniqueInput
    /**
     * In case the tahun_garansi found by the `where` argument doesn't exist, create a new tahun_garansi with this data.
     */
    create: XOR<tahun_garansiCreateInput, tahun_garansiUncheckedCreateInput>
    /**
     * In case the tahun_garansi was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tahun_garansiUpdateInput, tahun_garansiUncheckedUpdateInput>
  }


  /**
   * tahun_garansi delete
   */
  export type tahun_garansiDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tahun_garansi
     */
    select?: tahun_garansiSelect<ExtArgs> | null
    /**
     * Filter which tahun_garansi to delete.
     */
    where: tahun_garansiWhereUniqueInput
  }


  /**
   * tahun_garansi deleteMany
   */
  export type tahun_garansiDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tahun_garansis to delete
     */
    where?: tahun_garansiWhereInput
  }


  /**
   * tahun_garansi without action
   */
  export type tahun_garansiDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tahun_garansi
     */
    select?: tahun_garansiSelect<ExtArgs> | null
  }



  /**
   * Model temp_indicator
   */

  export type AggregateTemp_indicator = {
    _count: Temp_indicatorCountAggregateOutputType | null
    _avg: Temp_indicatorAvgAggregateOutputType | null
    _sum: Temp_indicatorSumAggregateOutputType | null
    _min: Temp_indicatorMinAggregateOutputType | null
    _max: Temp_indicatorMaxAggregateOutputType | null
  }

  export type Temp_indicatorAvgAggregateOutputType = {
    id: number | null
    total: number | null
    total_ng: number | null
    total_ok: number | null
  }

  export type Temp_indicatorSumAggregateOutputType = {
    id: number | null
    total: number | null
    total_ng: number | null
    total_ok: number | null
  }

  export type Temp_indicatorMinAggregateOutputType = {
    id: number | null
    total: number | null
    total_ng: number | null
    total_ok: number | null
    timestamp: Date | null
    status: $Enums.temp_indicator_status | null
  }

  export type Temp_indicatorMaxAggregateOutputType = {
    id: number | null
    total: number | null
    total_ng: number | null
    total_ok: number | null
    timestamp: Date | null
    status: $Enums.temp_indicator_status | null
  }

  export type Temp_indicatorCountAggregateOutputType = {
    id: number
    total: number
    total_ng: number
    total_ok: number
    timestamp: number
    status: number
    _all: number
  }


  export type Temp_indicatorAvgAggregateInputType = {
    id?: true
    total?: true
    total_ng?: true
    total_ok?: true
  }

  export type Temp_indicatorSumAggregateInputType = {
    id?: true
    total?: true
    total_ng?: true
    total_ok?: true
  }

  export type Temp_indicatorMinAggregateInputType = {
    id?: true
    total?: true
    total_ng?: true
    total_ok?: true
    timestamp?: true
    status?: true
  }

  export type Temp_indicatorMaxAggregateInputType = {
    id?: true
    total?: true
    total_ng?: true
    total_ok?: true
    timestamp?: true
    status?: true
  }

  export type Temp_indicatorCountAggregateInputType = {
    id?: true
    total?: true
    total_ng?: true
    total_ok?: true
    timestamp?: true
    status?: true
    _all?: true
  }

  export type Temp_indicatorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which temp_indicator to aggregate.
     */
    where?: temp_indicatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of temp_indicators to fetch.
     */
    orderBy?: temp_indicatorOrderByWithRelationInput | temp_indicatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: temp_indicatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` temp_indicators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` temp_indicators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned temp_indicators
    **/
    _count?: true | Temp_indicatorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Temp_indicatorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Temp_indicatorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Temp_indicatorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Temp_indicatorMaxAggregateInputType
  }

  export type GetTemp_indicatorAggregateType<T extends Temp_indicatorAggregateArgs> = {
        [P in keyof T & keyof AggregateTemp_indicator]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTemp_indicator[P]>
      : GetScalarType<T[P], AggregateTemp_indicator[P]>
  }




  export type temp_indicatorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: temp_indicatorWhereInput
    orderBy?: temp_indicatorOrderByWithAggregationInput | temp_indicatorOrderByWithAggregationInput[]
    by: Temp_indicatorScalarFieldEnum[] | Temp_indicatorScalarFieldEnum
    having?: temp_indicatorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Temp_indicatorCountAggregateInputType | true
    _avg?: Temp_indicatorAvgAggregateInputType
    _sum?: Temp_indicatorSumAggregateInputType
    _min?: Temp_indicatorMinAggregateInputType
    _max?: Temp_indicatorMaxAggregateInputType
  }

  export type Temp_indicatorGroupByOutputType = {
    id: number
    total: number
    total_ng: number
    total_ok: number
    timestamp: Date
    status: $Enums.temp_indicator_status
    _count: Temp_indicatorCountAggregateOutputType | null
    _avg: Temp_indicatorAvgAggregateOutputType | null
    _sum: Temp_indicatorSumAggregateOutputType | null
    _min: Temp_indicatorMinAggregateOutputType | null
    _max: Temp_indicatorMaxAggregateOutputType | null
  }

  type GetTemp_indicatorGroupByPayload<T extends temp_indicatorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Temp_indicatorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Temp_indicatorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Temp_indicatorGroupByOutputType[P]>
            : GetScalarType<T[P], Temp_indicatorGroupByOutputType[P]>
        }
      >
    >


  export type temp_indicatorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    total?: boolean
    total_ng?: boolean
    total_ok?: boolean
    timestamp?: boolean
    status?: boolean
  }, ExtArgs["result"]["temp_indicator"]>

  export type temp_indicatorSelectScalar = {
    id?: boolean
    total?: boolean
    total_ng?: boolean
    total_ok?: boolean
    timestamp?: boolean
    status?: boolean
  }


  export type $temp_indicatorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "temp_indicator"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      total: number
      total_ng: number
      total_ok: number
      timestamp: Date
      status: $Enums.temp_indicator_status
    }, ExtArgs["result"]["temp_indicator"]>
    composites: {}
  }


  type temp_indicatorGetPayload<S extends boolean | null | undefined | temp_indicatorDefaultArgs> = $Result.GetResult<Prisma.$temp_indicatorPayload, S>

  type temp_indicatorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<temp_indicatorFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Temp_indicatorCountAggregateInputType | true
    }

  export interface temp_indicatorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['temp_indicator'], meta: { name: 'temp_indicator' } }
    /**
     * Find zero or one Temp_indicator that matches the filter.
     * @param {temp_indicatorFindUniqueArgs} args - Arguments to find a Temp_indicator
     * @example
     * // Get one Temp_indicator
     * const temp_indicator = await prisma.temp_indicator.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends temp_indicatorFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, temp_indicatorFindUniqueArgs<ExtArgs>>
    ): Prisma__temp_indicatorClient<$Result.GetResult<Prisma.$temp_indicatorPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Temp_indicator that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {temp_indicatorFindUniqueOrThrowArgs} args - Arguments to find a Temp_indicator
     * @example
     * // Get one Temp_indicator
     * const temp_indicator = await prisma.temp_indicator.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends temp_indicatorFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, temp_indicatorFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__temp_indicatorClient<$Result.GetResult<Prisma.$temp_indicatorPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Temp_indicator that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {temp_indicatorFindFirstArgs} args - Arguments to find a Temp_indicator
     * @example
     * // Get one Temp_indicator
     * const temp_indicator = await prisma.temp_indicator.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends temp_indicatorFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, temp_indicatorFindFirstArgs<ExtArgs>>
    ): Prisma__temp_indicatorClient<$Result.GetResult<Prisma.$temp_indicatorPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Temp_indicator that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {temp_indicatorFindFirstOrThrowArgs} args - Arguments to find a Temp_indicator
     * @example
     * // Get one Temp_indicator
     * const temp_indicator = await prisma.temp_indicator.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends temp_indicatorFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, temp_indicatorFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__temp_indicatorClient<$Result.GetResult<Prisma.$temp_indicatorPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Temp_indicators that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {temp_indicatorFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Temp_indicators
     * const temp_indicators = await prisma.temp_indicator.findMany()
     * 
     * // Get first 10 Temp_indicators
     * const temp_indicators = await prisma.temp_indicator.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const temp_indicatorWithIdOnly = await prisma.temp_indicator.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends temp_indicatorFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, temp_indicatorFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$temp_indicatorPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Temp_indicator.
     * @param {temp_indicatorCreateArgs} args - Arguments to create a Temp_indicator.
     * @example
     * // Create one Temp_indicator
     * const Temp_indicator = await prisma.temp_indicator.create({
     *   data: {
     *     // ... data to create a Temp_indicator
     *   }
     * })
     * 
    **/
    create<T extends temp_indicatorCreateArgs<ExtArgs>>(
      args: SelectSubset<T, temp_indicatorCreateArgs<ExtArgs>>
    ): Prisma__temp_indicatorClient<$Result.GetResult<Prisma.$temp_indicatorPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Temp_indicators.
     *     @param {temp_indicatorCreateManyArgs} args - Arguments to create many Temp_indicators.
     *     @example
     *     // Create many Temp_indicators
     *     const temp_indicator = await prisma.temp_indicator.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends temp_indicatorCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, temp_indicatorCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Temp_indicator.
     * @param {temp_indicatorDeleteArgs} args - Arguments to delete one Temp_indicator.
     * @example
     * // Delete one Temp_indicator
     * const Temp_indicator = await prisma.temp_indicator.delete({
     *   where: {
     *     // ... filter to delete one Temp_indicator
     *   }
     * })
     * 
    **/
    delete<T extends temp_indicatorDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, temp_indicatorDeleteArgs<ExtArgs>>
    ): Prisma__temp_indicatorClient<$Result.GetResult<Prisma.$temp_indicatorPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Temp_indicator.
     * @param {temp_indicatorUpdateArgs} args - Arguments to update one Temp_indicator.
     * @example
     * // Update one Temp_indicator
     * const temp_indicator = await prisma.temp_indicator.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends temp_indicatorUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, temp_indicatorUpdateArgs<ExtArgs>>
    ): Prisma__temp_indicatorClient<$Result.GetResult<Prisma.$temp_indicatorPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Temp_indicators.
     * @param {temp_indicatorDeleteManyArgs} args - Arguments to filter Temp_indicators to delete.
     * @example
     * // Delete a few Temp_indicators
     * const { count } = await prisma.temp_indicator.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends temp_indicatorDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, temp_indicatorDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Temp_indicators.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {temp_indicatorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Temp_indicators
     * const temp_indicator = await prisma.temp_indicator.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends temp_indicatorUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, temp_indicatorUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Temp_indicator.
     * @param {temp_indicatorUpsertArgs} args - Arguments to update or create a Temp_indicator.
     * @example
     * // Update or create a Temp_indicator
     * const temp_indicator = await prisma.temp_indicator.upsert({
     *   create: {
     *     // ... data to create a Temp_indicator
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Temp_indicator we want to update
     *   }
     * })
    **/
    upsert<T extends temp_indicatorUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, temp_indicatorUpsertArgs<ExtArgs>>
    ): Prisma__temp_indicatorClient<$Result.GetResult<Prisma.$temp_indicatorPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Temp_indicators.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {temp_indicatorCountArgs} args - Arguments to filter Temp_indicators to count.
     * @example
     * // Count the number of Temp_indicators
     * const count = await prisma.temp_indicator.count({
     *   where: {
     *     // ... the filter for the Temp_indicators we want to count
     *   }
     * })
    **/
    count<T extends temp_indicatorCountArgs>(
      args?: Subset<T, temp_indicatorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Temp_indicatorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Temp_indicator.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Temp_indicatorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Temp_indicatorAggregateArgs>(args: Subset<T, Temp_indicatorAggregateArgs>): Prisma.PrismaPromise<GetTemp_indicatorAggregateType<T>>

    /**
     * Group by Temp_indicator.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {temp_indicatorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends temp_indicatorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: temp_indicatorGroupByArgs['orderBy'] }
        : { orderBy?: temp_indicatorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, temp_indicatorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTemp_indicatorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the temp_indicator model
   */
  readonly fields: temp_indicatorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for temp_indicator.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__temp_indicatorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the temp_indicator model
   */ 
  interface temp_indicatorFieldRefs {
    readonly id: FieldRef<"temp_indicator", 'Int'>
    readonly total: FieldRef<"temp_indicator", 'Int'>
    readonly total_ng: FieldRef<"temp_indicator", 'Int'>
    readonly total_ok: FieldRef<"temp_indicator", 'Int'>
    readonly timestamp: FieldRef<"temp_indicator", 'DateTime'>
    readonly status: FieldRef<"temp_indicator", 'temp_indicator_status'>
  }
    

  // Custom InputTypes

  /**
   * temp_indicator findUnique
   */
  export type temp_indicatorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the temp_indicator
     */
    select?: temp_indicatorSelect<ExtArgs> | null
    /**
     * Filter, which temp_indicator to fetch.
     */
    where: temp_indicatorWhereUniqueInput
  }


  /**
   * temp_indicator findUniqueOrThrow
   */
  export type temp_indicatorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the temp_indicator
     */
    select?: temp_indicatorSelect<ExtArgs> | null
    /**
     * Filter, which temp_indicator to fetch.
     */
    where: temp_indicatorWhereUniqueInput
  }


  /**
   * temp_indicator findFirst
   */
  export type temp_indicatorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the temp_indicator
     */
    select?: temp_indicatorSelect<ExtArgs> | null
    /**
     * Filter, which temp_indicator to fetch.
     */
    where?: temp_indicatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of temp_indicators to fetch.
     */
    orderBy?: temp_indicatorOrderByWithRelationInput | temp_indicatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for temp_indicators.
     */
    cursor?: temp_indicatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` temp_indicators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` temp_indicators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of temp_indicators.
     */
    distinct?: Temp_indicatorScalarFieldEnum | Temp_indicatorScalarFieldEnum[]
  }


  /**
   * temp_indicator findFirstOrThrow
   */
  export type temp_indicatorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the temp_indicator
     */
    select?: temp_indicatorSelect<ExtArgs> | null
    /**
     * Filter, which temp_indicator to fetch.
     */
    where?: temp_indicatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of temp_indicators to fetch.
     */
    orderBy?: temp_indicatorOrderByWithRelationInput | temp_indicatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for temp_indicators.
     */
    cursor?: temp_indicatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` temp_indicators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` temp_indicators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of temp_indicators.
     */
    distinct?: Temp_indicatorScalarFieldEnum | Temp_indicatorScalarFieldEnum[]
  }


  /**
   * temp_indicator findMany
   */
  export type temp_indicatorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the temp_indicator
     */
    select?: temp_indicatorSelect<ExtArgs> | null
    /**
     * Filter, which temp_indicators to fetch.
     */
    where?: temp_indicatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of temp_indicators to fetch.
     */
    orderBy?: temp_indicatorOrderByWithRelationInput | temp_indicatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing temp_indicators.
     */
    cursor?: temp_indicatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` temp_indicators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` temp_indicators.
     */
    skip?: number
    distinct?: Temp_indicatorScalarFieldEnum | Temp_indicatorScalarFieldEnum[]
  }


  /**
   * temp_indicator create
   */
  export type temp_indicatorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the temp_indicator
     */
    select?: temp_indicatorSelect<ExtArgs> | null
    /**
     * The data needed to create a temp_indicator.
     */
    data: XOR<temp_indicatorCreateInput, temp_indicatorUncheckedCreateInput>
  }


  /**
   * temp_indicator createMany
   */
  export type temp_indicatorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many temp_indicators.
     */
    data: temp_indicatorCreateManyInput | temp_indicatorCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * temp_indicator update
   */
  export type temp_indicatorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the temp_indicator
     */
    select?: temp_indicatorSelect<ExtArgs> | null
    /**
     * The data needed to update a temp_indicator.
     */
    data: XOR<temp_indicatorUpdateInput, temp_indicatorUncheckedUpdateInput>
    /**
     * Choose, which temp_indicator to update.
     */
    where: temp_indicatorWhereUniqueInput
  }


  /**
   * temp_indicator updateMany
   */
  export type temp_indicatorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update temp_indicators.
     */
    data: XOR<temp_indicatorUpdateManyMutationInput, temp_indicatorUncheckedUpdateManyInput>
    /**
     * Filter which temp_indicators to update
     */
    where?: temp_indicatorWhereInput
  }


  /**
   * temp_indicator upsert
   */
  export type temp_indicatorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the temp_indicator
     */
    select?: temp_indicatorSelect<ExtArgs> | null
    /**
     * The filter to search for the temp_indicator to update in case it exists.
     */
    where: temp_indicatorWhereUniqueInput
    /**
     * In case the temp_indicator found by the `where` argument doesn't exist, create a new temp_indicator with this data.
     */
    create: XOR<temp_indicatorCreateInput, temp_indicatorUncheckedCreateInput>
    /**
     * In case the temp_indicator was found with the provided `where` argument, update it with this data.
     */
    update: XOR<temp_indicatorUpdateInput, temp_indicatorUncheckedUpdateInput>
  }


  /**
   * temp_indicator delete
   */
  export type temp_indicatorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the temp_indicator
     */
    select?: temp_indicatorSelect<ExtArgs> | null
    /**
     * Filter which temp_indicator to delete.
     */
    where: temp_indicatorWhereUniqueInput
  }


  /**
   * temp_indicator deleteMany
   */
  export type temp_indicatorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which temp_indicators to delete
     */
    where?: temp_indicatorWhereInput
  }


  /**
   * temp_indicator without action
   */
  export type temp_indicatorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the temp_indicator
     */
    select?: temp_indicatorSelect<ExtArgs> | null
  }



  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const Area_listScalarFieldEnum: {
    id: 'id',
    value: 'value'
  };

  export type Area_listScalarFieldEnum = (typeof Area_listScalarFieldEnum)[keyof typeof Area_listScalarFieldEnum]


  export const AttachmentScalarFieldEnum: {
    id: 'id',
    nomor: 'nomor',
    timestamp: 'timestamp',
    type: 'type',
    no_do: 'no_do',
    no_order: 'no_order',
    tgl_order: 'tgl_order',
    area: 'area',
    status: 'status',
    active: 'active',
    qty: 'qty',
    used_qty: 'used_qty'
  };

  export type AttachmentScalarFieldEnum = (typeof AttachmentScalarFieldEnum)[keyof typeof AttachmentScalarFieldEnum]


  export const Attachment2ScalarFieldEnum: {
    id: 'id',
    nomor: 'nomor',
    timestamp: 'timestamp',
    type: 'type',
    no_do: 'no_do',
    no_order: 'no_order',
    tgl_order: 'tgl_order',
    area: 'area',
    status: 'status',
    active: 'active'
  };

  export type Attachment2ScalarFieldEnum = (typeof Attachment2ScalarFieldEnum)[keyof typeof Attachment2ScalarFieldEnum]


  export const BoxScalarFieldEnum: {
    id: 'id',
    serial: 'serial',
    timestamp: 'timestamp',
    line: 'line',
    type: 'type',
    pallete_id: 'pallete_id',
    attachment_id: 'attachment_id',
    attachment2_id: 'attachment2_id',
    remain: 'remain'
  };

  export type BoxScalarFieldEnum = (typeof BoxScalarFieldEnum)[keyof typeof BoxScalarFieldEnum]


  export const ConfigScalarFieldEnum: {
    root: 'root',
    branch: 'branch',
    value: 'value',
    tanggal: 'tanggal'
  };

  export type ConfigScalarFieldEnum = (typeof ConfigScalarFieldEnum)[keyof typeof ConfigScalarFieldEnum]


  export const Defect_listScalarFieldEnum: {
    id: 'id',
    defect_name: 'defect_name'
  };

  export type Defect_listScalarFieldEnum = (typeof Defect_listScalarFieldEnum)[keyof typeof Defect_listScalarFieldEnum]


  export const Fct_notpassScalarFieldEnum: {
    id: 'id',
    serial: 'serial',
    type: 'type',
    line: 'line',
    timestamp: 'timestamp'
  };

  export type Fct_notpassScalarFieldEnum = (typeof Fct_notpassScalarFieldEnum)[keyof typeof Fct_notpassScalarFieldEnum]


  export const Fct_passScalarFieldEnum: {
    id: 'id',
    serial: 'serial',
    type: 'type',
    line: 'line',
    timestamp: 'timestamp'
  };

  export type Fct_passScalarFieldEnum = (typeof Fct_passScalarFieldEnum)[keyof typeof Fct_passScalarFieldEnum]


  export const Fct_tempScalarFieldEnum: {
    id: 'id',
    type: 'type',
    line: 'line',
    timestamp: 'timestamp',
    total_output: 'total_output',
    total_defect: 'total_defect',
    target: 'target'
  };

  export type Fct_tempScalarFieldEnum = (typeof Fct_tempScalarFieldEnum)[keyof typeof Fct_tempScalarFieldEnum]


  export const Filestore_fileScalarFieldEnum: {
    id: 'id',
    filestore_type_id: 'filestore_type_id',
    filestore_volume_id: 'filestore_volume_id',
    filename: 'filename',
    original_filename: 'original_filename',
    filesize: 'filesize',
    filenum: 'filenum',
    deleted: 'deleted'
  };

  export type Filestore_fileScalarFieldEnum = (typeof Filestore_fileScalarFieldEnum)[keyof typeof Filestore_fileScalarFieldEnum]


  export const Filestore_typeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    mime_type: 'mime_type',
    extension: 'extension'
  };

  export type Filestore_typeScalarFieldEnum = (typeof Filestore_typeScalarFieldEnum)[keyof typeof Filestore_typeScalarFieldEnum]


  export const Filestore_volumeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    dirname: 'dirname',
    total_space: 'total_space',
    used_space: 'used_space',
    stored_files_cnt: 'stored_files_cnt',
    enabled: 'enabled',
    last_filenum: 'last_filenum'
  };

  export type Filestore_volumeScalarFieldEnum = (typeof Filestore_volumeScalarFieldEnum)[keyof typeof Filestore_volumeScalarFieldEnum]


  export const Audit_logsScalarFieldEnum: {
    id: 'id',
    timestamp: 'timestamp',
    action: 'action',
    entity: 'entity',
    entity_id: 'entity_id',
    details: 'details',
    user: 'user',
    ip_address: 'ip_address'
  };

  export type Audit_logsScalarFieldEnum = (typeof Audit_logsScalarFieldEnum)[keyof typeof Audit_logsScalarFieldEnum]


  export const Logs_editScalarFieldEnum: {
    id: 'id',
    timestamp: 'timestamp',
    desc: 'desc',
    code: 'code',
    line: 'line',
    user: 'user'
  };

  export type Logs_editScalarFieldEnum = (typeof Logs_editScalarFieldEnum)[keyof typeof Logs_editScalarFieldEnum]


  export const Meter_typeScalarFieldEnum: {
    id: 'id',
    value: 'value',
    phase: 'phase',
    validation: 'validation',
    validation_length: 'validation_length',
    length: 'length',
    pln_code: 'pln_code',
    card_validation: 'card_validation',
    validation_type: 'validation_type',
    daily_reset: 'daily_reset',
    numeric_only: 'numeric_only',
    surpass_target: 'surpass_target',
    run_by_sequence: 'run_by_sequence',
    start_reset: 'start_reset',
    end_reset: 'end_reset'
  };

  export type Meter_typeScalarFieldEnum = (typeof Meter_typeScalarFieldEnum)[keyof typeof Meter_typeScalarFieldEnum]


  export const Module_listScalarFieldEnum: {
    module_id: 'module_id',
    module_serial: 'module_serial'
  };

  export type Module_listScalarFieldEnum = (typeof Module_listScalarFieldEnum)[keyof typeof Module_listScalarFieldEnum]


  export const Order_numScalarFieldEnum: {
    id: 'id',
    value: 'value',
    counter: 'counter'
  };

  export type Order_numScalarFieldEnum = (typeof Order_numScalarFieldEnum)[keyof typeof Order_numScalarFieldEnum]


  export const Out_110ScalarFieldEnum: {
    id: 'id',
    serial: 'serial',
    qr_serial: 'qr_serial',
    timestamp: 'timestamp',
    receive_id: 'receive_id'
  };

  export type Out_110ScalarFieldEnum = (typeof Out_110ScalarFieldEnum)[keyof typeof Out_110ScalarFieldEnum]


  export const Output_targetScalarFieldEnum: {
    id: 'id',
    output: 'output',
    type: 'type',
    waktu: 'waktu',
    line: 'line',
    timestamp: 'timestamp'
  };

  export type Output_targetScalarFieldEnum = (typeof Output_targetScalarFieldEnum)[keyof typeof Output_targetScalarFieldEnum]


  export const Output_tempScalarFieldEnum: {
    id: 'id',
    type: 'type',
    total_output: 'total_output',
    line: 'line',
    tahun: 'tahun',
    timestamp: 'timestamp',
    total_bigbox: 'total_bigbox',
    total_pallet: 'total_pallet',
    target: 'target',
    target_hour: 'target_hour',
    hour1: 'hour1',
    hour2: 'hour2',
    hour3: 'hour3',
    hour4: 'hour4',
    hour5: 'hour5',
    hour6: 'hour6',
    hour7: 'hour7',
    hour8: 'hour8',
    hour9: 'hour9',
    hour10: 'hour10',
    hour11: 'hour11',
    hour12: 'hour12'
  };

  export type Output_tempScalarFieldEnum = (typeof Output_tempScalarFieldEnum)[keyof typeof Output_tempScalarFieldEnum]


  export const PalleteScalarFieldEnum: {
    id: 'id',
    serial: 'serial',
    timestamp: 'timestamp',
    line: 'line',
    type: 'type',
    location: 'location'
  };

  export type PalleteScalarFieldEnum = (typeof PalleteScalarFieldEnum)[keyof typeof PalleteScalarFieldEnum]


  export const Pln_codeScalarFieldEnum: {
    id: 'id',
    value: 'value'
  };

  export type Pln_codeScalarFieldEnum = (typeof Pln_codeScalarFieldEnum)[keyof typeof Pln_codeScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    id: 'id',
    serial: 'serial',
    module_serial: 'module_serial',
    timestamp: 'timestamp',
    line: 'line',
    type: 'type',
    orderno: 'orderno',
    area: 'area',
    jenis: 'jenis',
    box_id: 'box_id',
    attachment_id: 'attachment_id',
    attachment2_id: 'attachment2_id',
    remain: 'remain',
    garansi: 'garansi'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const Production_ngScalarFieldEnum: {
    id: 'id',
    meter_type: 'meter_type',
    serial: 'serial',
    tanggal: 'tanggal',
    station: 'station',
    line: 'line',
    defect: 'defect',
    category: 'category',
    department: 'department',
    action: 'action',
    keterangan: 'keterangan',
    update_date: 'update_date',
    user: 'user'
  };

  export type Production_ngScalarFieldEnum = (typeof Production_ngScalarFieldEnum)[keyof typeof Production_ngScalarFieldEnum]


  export const ProductionorderScalarFieldEnum: {
    id: 'id',
    timestamp: 'timestamp',
    ponum: 'ponum',
    area: 'area',
    provinsi: 'provinsi',
    count_qty: 'count_qty',
    qty: 'qty',
    status: 'status',
    keterangan: 'keterangan'
  };

  export type ProductionorderScalarFieldEnum = (typeof ProductionorderScalarFieldEnum)[keyof typeof ProductionorderScalarFieldEnum]


  export const Receive_110ScalarFieldEnum: {
    id: 'id',
    serial: 'serial',
    qr_serial: 'qr_serial',
    timestamp: 'timestamp',
    result: 'result'
  };

  export type Receive_110ScalarFieldEnum = (typeof Receive_110ScalarFieldEnum)[keyof typeof Receive_110ScalarFieldEnum]


  export const Rework_amrScalarFieldEnum: {
    id: 'id',
    serial: 'serial',
    qr_serial: 'qr_serial',
    timestamp: 'timestamp'
  };

  export type Rework_amrScalarFieldEnum = (typeof Rework_amrScalarFieldEnum)[keyof typeof Rework_amrScalarFieldEnum]


  export const Rework_boxScalarFieldEnum: {
    id: 'id',
    serial: 'serial',
    timestamp: 'timestamp',
    line: 'line',
    type: 'type',
    pallete_id: 'pallete_id',
    attachment_id: 'attachment_id',
    attachment2_id: 'attachment2_id'
  };

  export type Rework_boxScalarFieldEnum = (typeof Rework_boxScalarFieldEnum)[keyof typeof Rework_boxScalarFieldEnum]


  export const Rework_hxe110ScalarFieldEnum: {
    id: 'id',
    meter_type: 'meter_type',
    meter_serial: 'meter_serial',
    tanggal: 'tanggal',
    modem: 'modem',
    baterai: 'baterai',
    defect: 'defect'
  };

  export type Rework_hxe110ScalarFieldEnum = (typeof Rework_hxe110ScalarFieldEnum)[keyof typeof Rework_hxe110ScalarFieldEnum]


  export const Rework_palleteScalarFieldEnum: {
    id: 'id',
    serial: 'serial',
    timestamp: 'timestamp',
    line: 'line',
    type: 'type',
    location: 'location'
  };

  export type Rework_palleteScalarFieldEnum = (typeof Rework_palleteScalarFieldEnum)[keyof typeof Rework_palleteScalarFieldEnum]


  export const Serial_checkScalarFieldEnum: {
    id: 'id',
    serial: 'serial',
    timestamp: 'timestamp',
    line: 'line',
    type: 'type',
    orderno: 'orderno',
    area: 'area',
    jenis: 'jenis',
    box_id: 'box_id',
    attachment_id: 'attachment_id',
    attachment2_id: 'attachment2_id',
    remain: 'remain',
    garansi: 'garansi'
  };

  export type Serial_checkScalarFieldEnum = (typeof Serial_checkScalarFieldEnum)[keyof typeof Serial_checkScalarFieldEnum]


  export const Tahun_garansiScalarFieldEnum: {
    id_garansi: 'id_garansi',
    value: 'value'
  };

  export type Tahun_garansiScalarFieldEnum = (typeof Tahun_garansiScalarFieldEnum)[keyof typeof Tahun_garansiScalarFieldEnum]


  export const Temp_indicatorScalarFieldEnum: {
    id: 'id',
    total: 'total',
    total_ng: 'total_ng',
    total_ok: 'total_ok',
    timestamp: 'timestamp',
    status: 'status'
  };

  export type Temp_indicatorScalarFieldEnum = (typeof Temp_indicatorScalarFieldEnum)[keyof typeof Temp_indicatorScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'filestore_file_deleted'
   */
  export type Enumfilestore_file_deletedFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'filestore_file_deleted'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'filestore_volume_enabled'
   */
  export type Enumfilestore_volume_enabledFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'filestore_volume_enabled'>
    


  /**
   * Reference to a field of type 'meter_type_card_validation'
   */
  export type Enummeter_type_card_validationFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'meter_type_card_validation'>
    


  /**
   * Reference to a field of type 'meter_type_validation_type'
   */
  export type Enummeter_type_validation_typeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'meter_type_validation_type'>
    


  /**
   * Reference to a field of type 'meter_type_daily_reset'
   */
  export type Enummeter_type_daily_resetFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'meter_type_daily_reset'>
    


  /**
   * Reference to a field of type 'meter_type_numeric_only'
   */
  export type Enummeter_type_numeric_onlyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'meter_type_numeric_only'>
    


  /**
   * Reference to a field of type 'meter_type_surpass_target'
   */
  export type Enummeter_type_surpass_targetFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'meter_type_surpass_target'>
    


  /**
   * Reference to a field of type 'meter_type_run_by_sequence'
   */
  export type Enummeter_type_run_by_sequenceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'meter_type_run_by_sequence'>
    


  /**
   * Reference to a field of type 'receive_110_result'
   */
  export type Enumreceive_110_resultFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'receive_110_result'>
    


  /**
   * Reference to a field of type 'temp_indicator_status'
   */
  export type Enumtemp_indicator_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'temp_indicator_status'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type area_listWhereInput = {
    AND?: area_listWhereInput | area_listWhereInput[]
    OR?: area_listWhereInput[]
    NOT?: area_listWhereInput | area_listWhereInput[]
    id?: IntFilter<"area_list"> | number
    value?: StringFilter<"area_list"> | string
  }

  export type area_listOrderByWithRelationInput = {
    id?: SortOrder
    value?: SortOrder
  }

  export type area_listWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: area_listWhereInput | area_listWhereInput[]
    OR?: area_listWhereInput[]
    NOT?: area_listWhereInput | area_listWhereInput[]
    value?: StringFilter<"area_list"> | string
  }, "id">

  export type area_listOrderByWithAggregationInput = {
    id?: SortOrder
    value?: SortOrder
    _count?: area_listCountOrderByAggregateInput
    _avg?: area_listAvgOrderByAggregateInput
    _max?: area_listMaxOrderByAggregateInput
    _min?: area_listMinOrderByAggregateInput
    _sum?: area_listSumOrderByAggregateInput
  }

  export type area_listScalarWhereWithAggregatesInput = {
    AND?: area_listScalarWhereWithAggregatesInput | area_listScalarWhereWithAggregatesInput[]
    OR?: area_listScalarWhereWithAggregatesInput[]
    NOT?: area_listScalarWhereWithAggregatesInput | area_listScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"area_list"> | number
    value?: StringWithAggregatesFilter<"area_list"> | string
  }

  export type attachmentWhereInput = {
    AND?: attachmentWhereInput | attachmentWhereInput[]
    OR?: attachmentWhereInput[]
    NOT?: attachmentWhereInput | attachmentWhereInput[]
    id?: IntFilter<"attachment"> | number
    nomor?: StringFilter<"attachment"> | string
    timestamp?: DateTimeFilter<"attachment"> | Date | string
    type?: StringFilter<"attachment"> | string
    no_do?: StringFilter<"attachment"> | string
    no_order?: StringFilter<"attachment"> | string
    tgl_order?: DateTimeFilter<"attachment"> | Date | string
    area?: StringFilter<"attachment"> | string
    status?: BoolFilter<"attachment"> | boolean
    active?: BoolFilter<"attachment"> | boolean
    qty?: IntFilter<"attachment"> | number
    used_qty?: IntFilter<"attachment"> | number
  }

  export type attachmentOrderByWithRelationInput = {
    id?: SortOrder
    nomor?: SortOrder
    timestamp?: SortOrder
    type?: SortOrder
    no_do?: SortOrder
    no_order?: SortOrder
    tgl_order?: SortOrder
    area?: SortOrder
    status?: SortOrder
    active?: SortOrder
    qty?: SortOrder
    used_qty?: SortOrder
  }

  export type attachmentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: attachmentWhereInput | attachmentWhereInput[]
    OR?: attachmentWhereInput[]
    NOT?: attachmentWhereInput | attachmentWhereInput[]
    nomor?: StringFilter<"attachment"> | string
    timestamp?: DateTimeFilter<"attachment"> | Date | string
    type?: StringFilter<"attachment"> | string
    no_do?: StringFilter<"attachment"> | string
    no_order?: StringFilter<"attachment"> | string
    tgl_order?: DateTimeFilter<"attachment"> | Date | string
    area?: StringFilter<"attachment"> | string
    status?: BoolFilter<"attachment"> | boolean
    active?: BoolFilter<"attachment"> | boolean
    qty?: IntFilter<"attachment"> | number
    used_qty?: IntFilter<"attachment"> | number
  }, "id">

  export type attachmentOrderByWithAggregationInput = {
    id?: SortOrder
    nomor?: SortOrder
    timestamp?: SortOrder
    type?: SortOrder
    no_do?: SortOrder
    no_order?: SortOrder
    tgl_order?: SortOrder
    area?: SortOrder
    status?: SortOrder
    active?: SortOrder
    qty?: SortOrder
    used_qty?: SortOrder
    _count?: attachmentCountOrderByAggregateInput
    _avg?: attachmentAvgOrderByAggregateInput
    _max?: attachmentMaxOrderByAggregateInput
    _min?: attachmentMinOrderByAggregateInput
    _sum?: attachmentSumOrderByAggregateInput
  }

  export type attachmentScalarWhereWithAggregatesInput = {
    AND?: attachmentScalarWhereWithAggregatesInput | attachmentScalarWhereWithAggregatesInput[]
    OR?: attachmentScalarWhereWithAggregatesInput[]
    NOT?: attachmentScalarWhereWithAggregatesInput | attachmentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"attachment"> | number
    nomor?: StringWithAggregatesFilter<"attachment"> | string
    timestamp?: DateTimeWithAggregatesFilter<"attachment"> | Date | string
    type?: StringWithAggregatesFilter<"attachment"> | string
    no_do?: StringWithAggregatesFilter<"attachment"> | string
    no_order?: StringWithAggregatesFilter<"attachment"> | string
    tgl_order?: DateTimeWithAggregatesFilter<"attachment"> | Date | string
    area?: StringWithAggregatesFilter<"attachment"> | string
    status?: BoolWithAggregatesFilter<"attachment"> | boolean
    active?: BoolWithAggregatesFilter<"attachment"> | boolean
    qty?: IntWithAggregatesFilter<"attachment"> | number
    used_qty?: IntWithAggregatesFilter<"attachment"> | number
  }

  export type attachment2WhereInput = {
    AND?: attachment2WhereInput | attachment2WhereInput[]
    OR?: attachment2WhereInput[]
    NOT?: attachment2WhereInput | attachment2WhereInput[]
    id?: IntFilter<"attachment2"> | number
    nomor?: StringFilter<"attachment2"> | string
    timestamp?: DateTimeFilter<"attachment2"> | Date | string
    type?: StringFilter<"attachment2"> | string
    no_do?: StringFilter<"attachment2"> | string
    no_order?: StringFilter<"attachment2"> | string
    tgl_order?: DateTimeFilter<"attachment2"> | Date | string
    area?: StringFilter<"attachment2"> | string
    status?: BoolFilter<"attachment2"> | boolean
    active?: BoolFilter<"attachment2"> | boolean
  }

  export type attachment2OrderByWithRelationInput = {
    id?: SortOrder
    nomor?: SortOrder
    timestamp?: SortOrder
    type?: SortOrder
    no_do?: SortOrder
    no_order?: SortOrder
    tgl_order?: SortOrder
    area?: SortOrder
    status?: SortOrder
    active?: SortOrder
  }

  export type attachment2WhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: attachment2WhereInput | attachment2WhereInput[]
    OR?: attachment2WhereInput[]
    NOT?: attachment2WhereInput | attachment2WhereInput[]
    nomor?: StringFilter<"attachment2"> | string
    timestamp?: DateTimeFilter<"attachment2"> | Date | string
    type?: StringFilter<"attachment2"> | string
    no_do?: StringFilter<"attachment2"> | string
    no_order?: StringFilter<"attachment2"> | string
    tgl_order?: DateTimeFilter<"attachment2"> | Date | string
    area?: StringFilter<"attachment2"> | string
    status?: BoolFilter<"attachment2"> | boolean
    active?: BoolFilter<"attachment2"> | boolean
  }, "id">

  export type attachment2OrderByWithAggregationInput = {
    id?: SortOrder
    nomor?: SortOrder
    timestamp?: SortOrder
    type?: SortOrder
    no_do?: SortOrder
    no_order?: SortOrder
    tgl_order?: SortOrder
    area?: SortOrder
    status?: SortOrder
    active?: SortOrder
    _count?: attachment2CountOrderByAggregateInput
    _avg?: attachment2AvgOrderByAggregateInput
    _max?: attachment2MaxOrderByAggregateInput
    _min?: attachment2MinOrderByAggregateInput
    _sum?: attachment2SumOrderByAggregateInput
  }

  export type attachment2ScalarWhereWithAggregatesInput = {
    AND?: attachment2ScalarWhereWithAggregatesInput | attachment2ScalarWhereWithAggregatesInput[]
    OR?: attachment2ScalarWhereWithAggregatesInput[]
    NOT?: attachment2ScalarWhereWithAggregatesInput | attachment2ScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"attachment2"> | number
    nomor?: StringWithAggregatesFilter<"attachment2"> | string
    timestamp?: DateTimeWithAggregatesFilter<"attachment2"> | Date | string
    type?: StringWithAggregatesFilter<"attachment2"> | string
    no_do?: StringWithAggregatesFilter<"attachment2"> | string
    no_order?: StringWithAggregatesFilter<"attachment2"> | string
    tgl_order?: DateTimeWithAggregatesFilter<"attachment2"> | Date | string
    area?: StringWithAggregatesFilter<"attachment2"> | string
    status?: BoolWithAggregatesFilter<"attachment2"> | boolean
    active?: BoolWithAggregatesFilter<"attachment2"> | boolean
  }

  export type boxWhereInput = {
    AND?: boxWhereInput | boxWhereInput[]
    OR?: boxWhereInput[]
    NOT?: boxWhereInput | boxWhereInput[]
    id?: IntFilter<"box"> | number
    serial?: StringFilter<"box"> | string
    timestamp?: DateTimeFilter<"box"> | Date | string
    line?: StringFilter<"box"> | string
    type?: StringFilter<"box"> | string
    pallete_id?: IntNullableFilter<"box"> | number | null
    attachment_id?: IntNullableFilter<"box"> | number | null
    attachment2_id?: IntNullableFilter<"box"> | number | null
    remain?: StringFilter<"box"> | string
  }

  export type boxOrderByWithRelationInput = {
    id?: SortOrder
    serial?: SortOrder
    timestamp?: SortOrder
    line?: SortOrder
    type?: SortOrder
    pallete_id?: SortOrderInput | SortOrder
    attachment_id?: SortOrderInput | SortOrder
    attachment2_id?: SortOrderInput | SortOrder
    remain?: SortOrder
  }

  export type boxWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    serial?: string
    AND?: boxWhereInput | boxWhereInput[]
    OR?: boxWhereInput[]
    NOT?: boxWhereInput | boxWhereInput[]
    timestamp?: DateTimeFilter<"box"> | Date | string
    line?: StringFilter<"box"> | string
    type?: StringFilter<"box"> | string
    pallete_id?: IntNullableFilter<"box"> | number | null
    attachment_id?: IntNullableFilter<"box"> | number | null
    attachment2_id?: IntNullableFilter<"box"> | number | null
    remain?: StringFilter<"box"> | string
  }, "id" | "serial">

  export type boxOrderByWithAggregationInput = {
    id?: SortOrder
    serial?: SortOrder
    timestamp?: SortOrder
    line?: SortOrder
    type?: SortOrder
    pallete_id?: SortOrderInput | SortOrder
    attachment_id?: SortOrderInput | SortOrder
    attachment2_id?: SortOrderInput | SortOrder
    remain?: SortOrder
    _count?: boxCountOrderByAggregateInput
    _avg?: boxAvgOrderByAggregateInput
    _max?: boxMaxOrderByAggregateInput
    _min?: boxMinOrderByAggregateInput
    _sum?: boxSumOrderByAggregateInput
  }

  export type boxScalarWhereWithAggregatesInput = {
    AND?: boxScalarWhereWithAggregatesInput | boxScalarWhereWithAggregatesInput[]
    OR?: boxScalarWhereWithAggregatesInput[]
    NOT?: boxScalarWhereWithAggregatesInput | boxScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"box"> | number
    serial?: StringWithAggregatesFilter<"box"> | string
    timestamp?: DateTimeWithAggregatesFilter<"box"> | Date | string
    line?: StringWithAggregatesFilter<"box"> | string
    type?: StringWithAggregatesFilter<"box"> | string
    pallete_id?: IntNullableWithAggregatesFilter<"box"> | number | null
    attachment_id?: IntNullableWithAggregatesFilter<"box"> | number | null
    attachment2_id?: IntNullableWithAggregatesFilter<"box"> | number | null
    remain?: StringWithAggregatesFilter<"box"> | string
  }

  export type configWhereInput = {
    AND?: configWhereInput | configWhereInput[]
    OR?: configWhereInput[]
    NOT?: configWhereInput | configWhereInput[]
    root?: StringFilter<"config"> | string
    branch?: StringFilter<"config"> | string
    value?: StringFilter<"config"> | string
    tanggal?: DateTimeFilter<"config"> | Date | string
  }

  export type configOrderByWithRelationInput = {
    root?: SortOrder
    branch?: SortOrder
    value?: SortOrder
    tanggal?: SortOrder
  }

  export type configWhereUniqueInput = Prisma.AtLeast<{
    root_branch?: configRootBranchCompoundUniqueInput
    AND?: configWhereInput | configWhereInput[]
    OR?: configWhereInput[]
    NOT?: configWhereInput | configWhereInput[]
    root?: StringFilter<"config"> | string
    branch?: StringFilter<"config"> | string
    value?: StringFilter<"config"> | string
    tanggal?: DateTimeFilter<"config"> | Date | string
  }, "root_branch">

  export type configOrderByWithAggregationInput = {
    root?: SortOrder
    branch?: SortOrder
    value?: SortOrder
    tanggal?: SortOrder
    _count?: configCountOrderByAggregateInput
    _max?: configMaxOrderByAggregateInput
    _min?: configMinOrderByAggregateInput
  }

  export type configScalarWhereWithAggregatesInput = {
    AND?: configScalarWhereWithAggregatesInput | configScalarWhereWithAggregatesInput[]
    OR?: configScalarWhereWithAggregatesInput[]
    NOT?: configScalarWhereWithAggregatesInput | configScalarWhereWithAggregatesInput[]
    root?: StringWithAggregatesFilter<"config"> | string
    branch?: StringWithAggregatesFilter<"config"> | string
    value?: StringWithAggregatesFilter<"config"> | string
    tanggal?: DateTimeWithAggregatesFilter<"config"> | Date | string
  }

  export type defect_listWhereInput = {
    AND?: defect_listWhereInput | defect_listWhereInput[]
    OR?: defect_listWhereInput[]
    NOT?: defect_listWhereInput | defect_listWhereInput[]
    id?: IntFilter<"defect_list"> | number
    defect_name?: StringFilter<"defect_list"> | string
  }

  export type defect_listOrderByWithRelationInput = {
    id?: SortOrder
    defect_name?: SortOrder
  }

  export type defect_listWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: defect_listWhereInput | defect_listWhereInput[]
    OR?: defect_listWhereInput[]
    NOT?: defect_listWhereInput | defect_listWhereInput[]
    defect_name?: StringFilter<"defect_list"> | string
  }, "id">

  export type defect_listOrderByWithAggregationInput = {
    id?: SortOrder
    defect_name?: SortOrder
    _count?: defect_listCountOrderByAggregateInput
    _avg?: defect_listAvgOrderByAggregateInput
    _max?: defect_listMaxOrderByAggregateInput
    _min?: defect_listMinOrderByAggregateInput
    _sum?: defect_listSumOrderByAggregateInput
  }

  export type defect_listScalarWhereWithAggregatesInput = {
    AND?: defect_listScalarWhereWithAggregatesInput | defect_listScalarWhereWithAggregatesInput[]
    OR?: defect_listScalarWhereWithAggregatesInput[]
    NOT?: defect_listScalarWhereWithAggregatesInput | defect_listScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"defect_list"> | number
    defect_name?: StringWithAggregatesFilter<"defect_list"> | string
  }

  export type fct_notpassWhereInput = {
    AND?: fct_notpassWhereInput | fct_notpassWhereInput[]
    OR?: fct_notpassWhereInput[]
    NOT?: fct_notpassWhereInput | fct_notpassWhereInput[]
    id?: IntFilter<"fct_notpass"> | number
    serial?: StringFilter<"fct_notpass"> | string
    type?: StringFilter<"fct_notpass"> | string
    line?: StringFilter<"fct_notpass"> | string
    timestamp?: DateTimeFilter<"fct_notpass"> | Date | string
  }

  export type fct_notpassOrderByWithRelationInput = {
    id?: SortOrder
    serial?: SortOrder
    type?: SortOrder
    line?: SortOrder
    timestamp?: SortOrder
  }

  export type fct_notpassWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: fct_notpassWhereInput | fct_notpassWhereInput[]
    OR?: fct_notpassWhereInput[]
    NOT?: fct_notpassWhereInput | fct_notpassWhereInput[]
    serial?: StringFilter<"fct_notpass"> | string
    type?: StringFilter<"fct_notpass"> | string
    line?: StringFilter<"fct_notpass"> | string
    timestamp?: DateTimeFilter<"fct_notpass"> | Date | string
  }, "id">

  export type fct_notpassOrderByWithAggregationInput = {
    id?: SortOrder
    serial?: SortOrder
    type?: SortOrder
    line?: SortOrder
    timestamp?: SortOrder
    _count?: fct_notpassCountOrderByAggregateInput
    _avg?: fct_notpassAvgOrderByAggregateInput
    _max?: fct_notpassMaxOrderByAggregateInput
    _min?: fct_notpassMinOrderByAggregateInput
    _sum?: fct_notpassSumOrderByAggregateInput
  }

  export type fct_notpassScalarWhereWithAggregatesInput = {
    AND?: fct_notpassScalarWhereWithAggregatesInput | fct_notpassScalarWhereWithAggregatesInput[]
    OR?: fct_notpassScalarWhereWithAggregatesInput[]
    NOT?: fct_notpassScalarWhereWithAggregatesInput | fct_notpassScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"fct_notpass"> | number
    serial?: StringWithAggregatesFilter<"fct_notpass"> | string
    type?: StringWithAggregatesFilter<"fct_notpass"> | string
    line?: StringWithAggregatesFilter<"fct_notpass"> | string
    timestamp?: DateTimeWithAggregatesFilter<"fct_notpass"> | Date | string
  }

  export type fct_passWhereInput = {
    AND?: fct_passWhereInput | fct_passWhereInput[]
    OR?: fct_passWhereInput[]
    NOT?: fct_passWhereInput | fct_passWhereInput[]
    id?: IntFilter<"fct_pass"> | number
    serial?: StringFilter<"fct_pass"> | string
    type?: StringFilter<"fct_pass"> | string
    line?: StringFilter<"fct_pass"> | string
    timestamp?: DateTimeFilter<"fct_pass"> | Date | string
  }

  export type fct_passOrderByWithRelationInput = {
    id?: SortOrder
    serial?: SortOrder
    type?: SortOrder
    line?: SortOrder
    timestamp?: SortOrder
  }

  export type fct_passWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: fct_passWhereInput | fct_passWhereInput[]
    OR?: fct_passWhereInput[]
    NOT?: fct_passWhereInput | fct_passWhereInput[]
    serial?: StringFilter<"fct_pass"> | string
    type?: StringFilter<"fct_pass"> | string
    line?: StringFilter<"fct_pass"> | string
    timestamp?: DateTimeFilter<"fct_pass"> | Date | string
  }, "id">

  export type fct_passOrderByWithAggregationInput = {
    id?: SortOrder
    serial?: SortOrder
    type?: SortOrder
    line?: SortOrder
    timestamp?: SortOrder
    _count?: fct_passCountOrderByAggregateInput
    _avg?: fct_passAvgOrderByAggregateInput
    _max?: fct_passMaxOrderByAggregateInput
    _min?: fct_passMinOrderByAggregateInput
    _sum?: fct_passSumOrderByAggregateInput
  }

  export type fct_passScalarWhereWithAggregatesInput = {
    AND?: fct_passScalarWhereWithAggregatesInput | fct_passScalarWhereWithAggregatesInput[]
    OR?: fct_passScalarWhereWithAggregatesInput[]
    NOT?: fct_passScalarWhereWithAggregatesInput | fct_passScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"fct_pass"> | number
    serial?: StringWithAggregatesFilter<"fct_pass"> | string
    type?: StringWithAggregatesFilter<"fct_pass"> | string
    line?: StringWithAggregatesFilter<"fct_pass"> | string
    timestamp?: DateTimeWithAggregatesFilter<"fct_pass"> | Date | string
  }

  export type fct_tempWhereInput = {
    AND?: fct_tempWhereInput | fct_tempWhereInput[]
    OR?: fct_tempWhereInput[]
    NOT?: fct_tempWhereInput | fct_tempWhereInput[]
    id?: IntFilter<"fct_temp"> | number
    type?: StringFilter<"fct_temp"> | string
    line?: StringFilter<"fct_temp"> | string
    timestamp?: DateTimeFilter<"fct_temp"> | Date | string
    total_output?: IntFilter<"fct_temp"> | number
    total_defect?: IntFilter<"fct_temp"> | number
    target?: IntFilter<"fct_temp"> | number
  }

  export type fct_tempOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    line?: SortOrder
    timestamp?: SortOrder
    total_output?: SortOrder
    total_defect?: SortOrder
    target?: SortOrder
  }

  export type fct_tempWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: fct_tempWhereInput | fct_tempWhereInput[]
    OR?: fct_tempWhereInput[]
    NOT?: fct_tempWhereInput | fct_tempWhereInput[]
    type?: StringFilter<"fct_temp"> | string
    line?: StringFilter<"fct_temp"> | string
    timestamp?: DateTimeFilter<"fct_temp"> | Date | string
    total_output?: IntFilter<"fct_temp"> | number
    total_defect?: IntFilter<"fct_temp"> | number
    target?: IntFilter<"fct_temp"> | number
  }, "id">

  export type fct_tempOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    line?: SortOrder
    timestamp?: SortOrder
    total_output?: SortOrder
    total_defect?: SortOrder
    target?: SortOrder
    _count?: fct_tempCountOrderByAggregateInput
    _avg?: fct_tempAvgOrderByAggregateInput
    _max?: fct_tempMaxOrderByAggregateInput
    _min?: fct_tempMinOrderByAggregateInput
    _sum?: fct_tempSumOrderByAggregateInput
  }

  export type fct_tempScalarWhereWithAggregatesInput = {
    AND?: fct_tempScalarWhereWithAggregatesInput | fct_tempScalarWhereWithAggregatesInput[]
    OR?: fct_tempScalarWhereWithAggregatesInput[]
    NOT?: fct_tempScalarWhereWithAggregatesInput | fct_tempScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"fct_temp"> | number
    type?: StringWithAggregatesFilter<"fct_temp"> | string
    line?: StringWithAggregatesFilter<"fct_temp"> | string
    timestamp?: DateTimeWithAggregatesFilter<"fct_temp"> | Date | string
    total_output?: IntWithAggregatesFilter<"fct_temp"> | number
    total_defect?: IntWithAggregatesFilter<"fct_temp"> | number
    target?: IntWithAggregatesFilter<"fct_temp"> | number
  }

  export type filestore_fileWhereInput = {
    AND?: filestore_fileWhereInput | filestore_fileWhereInput[]
    OR?: filestore_fileWhereInput[]
    NOT?: filestore_fileWhereInput | filestore_fileWhereInput[]
    id?: IntFilter<"filestore_file"> | number
    filestore_type_id?: IntFilter<"filestore_file"> | number
    filestore_volume_id?: IntFilter<"filestore_file"> | number
    filename?: StringFilter<"filestore_file"> | string
    original_filename?: StringNullableFilter<"filestore_file"> | string | null
    filesize?: IntFilter<"filestore_file"> | number
    filenum?: IntFilter<"filestore_file"> | number
    deleted?: Enumfilestore_file_deletedFilter<"filestore_file"> | $Enums.filestore_file_deleted
  }

  export type filestore_fileOrderByWithRelationInput = {
    id?: SortOrder
    filestore_type_id?: SortOrder
    filestore_volume_id?: SortOrder
    filename?: SortOrder
    original_filename?: SortOrderInput | SortOrder
    filesize?: SortOrder
    filenum?: SortOrder
    deleted?: SortOrder
  }

  export type filestore_fileWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: filestore_fileWhereInput | filestore_fileWhereInput[]
    OR?: filestore_fileWhereInput[]
    NOT?: filestore_fileWhereInput | filestore_fileWhereInput[]
    filestore_type_id?: IntFilter<"filestore_file"> | number
    filestore_volume_id?: IntFilter<"filestore_file"> | number
    filename?: StringFilter<"filestore_file"> | string
    original_filename?: StringNullableFilter<"filestore_file"> | string | null
    filesize?: IntFilter<"filestore_file"> | number
    filenum?: IntFilter<"filestore_file"> | number
    deleted?: Enumfilestore_file_deletedFilter<"filestore_file"> | $Enums.filestore_file_deleted
  }, "id">

  export type filestore_fileOrderByWithAggregationInput = {
    id?: SortOrder
    filestore_type_id?: SortOrder
    filestore_volume_id?: SortOrder
    filename?: SortOrder
    original_filename?: SortOrderInput | SortOrder
    filesize?: SortOrder
    filenum?: SortOrder
    deleted?: SortOrder
    _count?: filestore_fileCountOrderByAggregateInput
    _avg?: filestore_fileAvgOrderByAggregateInput
    _max?: filestore_fileMaxOrderByAggregateInput
    _min?: filestore_fileMinOrderByAggregateInput
    _sum?: filestore_fileSumOrderByAggregateInput
  }

  export type filestore_fileScalarWhereWithAggregatesInput = {
    AND?: filestore_fileScalarWhereWithAggregatesInput | filestore_fileScalarWhereWithAggregatesInput[]
    OR?: filestore_fileScalarWhereWithAggregatesInput[]
    NOT?: filestore_fileScalarWhereWithAggregatesInput | filestore_fileScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"filestore_file"> | number
    filestore_type_id?: IntWithAggregatesFilter<"filestore_file"> | number
    filestore_volume_id?: IntWithAggregatesFilter<"filestore_file"> | number
    filename?: StringWithAggregatesFilter<"filestore_file"> | string
    original_filename?: StringNullableWithAggregatesFilter<"filestore_file"> | string | null
    filesize?: IntWithAggregatesFilter<"filestore_file"> | number
    filenum?: IntWithAggregatesFilter<"filestore_file"> | number
    deleted?: Enumfilestore_file_deletedWithAggregatesFilter<"filestore_file"> | $Enums.filestore_file_deleted
  }

  export type filestore_typeWhereInput = {
    AND?: filestore_typeWhereInput | filestore_typeWhereInput[]
    OR?: filestore_typeWhereInput[]
    NOT?: filestore_typeWhereInput | filestore_typeWhereInput[]
    id?: IntFilter<"filestore_type"> | number
    name?: StringNullableFilter<"filestore_type"> | string | null
    mime_type?: StringFilter<"filestore_type"> | string
    extension?: StringNullableFilter<"filestore_type"> | string | null
  }

  export type filestore_typeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    mime_type?: SortOrder
    extension?: SortOrderInput | SortOrder
  }

  export type filestore_typeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: filestore_typeWhereInput | filestore_typeWhereInput[]
    OR?: filestore_typeWhereInput[]
    NOT?: filestore_typeWhereInput | filestore_typeWhereInput[]
    name?: StringNullableFilter<"filestore_type"> | string | null
    mime_type?: StringFilter<"filestore_type"> | string
    extension?: StringNullableFilter<"filestore_type"> | string | null
  }, "id">

  export type filestore_typeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    mime_type?: SortOrder
    extension?: SortOrderInput | SortOrder
    _count?: filestore_typeCountOrderByAggregateInput
    _avg?: filestore_typeAvgOrderByAggregateInput
    _max?: filestore_typeMaxOrderByAggregateInput
    _min?: filestore_typeMinOrderByAggregateInput
    _sum?: filestore_typeSumOrderByAggregateInput
  }

  export type filestore_typeScalarWhereWithAggregatesInput = {
    AND?: filestore_typeScalarWhereWithAggregatesInput | filestore_typeScalarWhereWithAggregatesInput[]
    OR?: filestore_typeScalarWhereWithAggregatesInput[]
    NOT?: filestore_typeScalarWhereWithAggregatesInput | filestore_typeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"filestore_type"> | number
    name?: StringNullableWithAggregatesFilter<"filestore_type"> | string | null
    mime_type?: StringWithAggregatesFilter<"filestore_type"> | string
    extension?: StringNullableWithAggregatesFilter<"filestore_type"> | string | null
  }

  export type filestore_volumeWhereInput = {
    AND?: filestore_volumeWhereInput | filestore_volumeWhereInput[]
    OR?: filestore_volumeWhereInput[]
    NOT?: filestore_volumeWhereInput | filestore_volumeWhereInput[]
    id?: IntFilter<"filestore_volume"> | number
    name?: StringFilter<"filestore_volume"> | string
    dirname?: StringFilter<"filestore_volume"> | string
    total_space?: BigIntFilter<"filestore_volume"> | bigint | number
    used_space?: BigIntFilter<"filestore_volume"> | bigint | number
    stored_files_cnt?: IntFilter<"filestore_volume"> | number
    enabled?: Enumfilestore_volume_enabledNullableFilter<"filestore_volume"> | $Enums.filestore_volume_enabled | null
    last_filenum?: IntNullableFilter<"filestore_volume"> | number | null
  }

  export type filestore_volumeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    dirname?: SortOrder
    total_space?: SortOrder
    used_space?: SortOrder
    stored_files_cnt?: SortOrder
    enabled?: SortOrderInput | SortOrder
    last_filenum?: SortOrderInput | SortOrder
  }

  export type filestore_volumeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: filestore_volumeWhereInput | filestore_volumeWhereInput[]
    OR?: filestore_volumeWhereInput[]
    NOT?: filestore_volumeWhereInput | filestore_volumeWhereInput[]
    dirname?: StringFilter<"filestore_volume"> | string
    total_space?: BigIntFilter<"filestore_volume"> | bigint | number
    used_space?: BigIntFilter<"filestore_volume"> | bigint | number
    stored_files_cnt?: IntFilter<"filestore_volume"> | number
    enabled?: Enumfilestore_volume_enabledNullableFilter<"filestore_volume"> | $Enums.filestore_volume_enabled | null
    last_filenum?: IntNullableFilter<"filestore_volume"> | number | null
  }, "id" | "name">

  export type filestore_volumeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    dirname?: SortOrder
    total_space?: SortOrder
    used_space?: SortOrder
    stored_files_cnt?: SortOrder
    enabled?: SortOrderInput | SortOrder
    last_filenum?: SortOrderInput | SortOrder
    _count?: filestore_volumeCountOrderByAggregateInput
    _avg?: filestore_volumeAvgOrderByAggregateInput
    _max?: filestore_volumeMaxOrderByAggregateInput
    _min?: filestore_volumeMinOrderByAggregateInput
    _sum?: filestore_volumeSumOrderByAggregateInput
  }

  export type filestore_volumeScalarWhereWithAggregatesInput = {
    AND?: filestore_volumeScalarWhereWithAggregatesInput | filestore_volumeScalarWhereWithAggregatesInput[]
    OR?: filestore_volumeScalarWhereWithAggregatesInput[]
    NOT?: filestore_volumeScalarWhereWithAggregatesInput | filestore_volumeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"filestore_volume"> | number
    name?: StringWithAggregatesFilter<"filestore_volume"> | string
    dirname?: StringWithAggregatesFilter<"filestore_volume"> | string
    total_space?: BigIntWithAggregatesFilter<"filestore_volume"> | bigint | number
    used_space?: BigIntWithAggregatesFilter<"filestore_volume"> | bigint | number
    stored_files_cnt?: IntWithAggregatesFilter<"filestore_volume"> | number
    enabled?: Enumfilestore_volume_enabledNullableWithAggregatesFilter<"filestore_volume"> | $Enums.filestore_volume_enabled | null
    last_filenum?: IntNullableWithAggregatesFilter<"filestore_volume"> | number | null
  }

  export type audit_logsWhereInput = {
    AND?: audit_logsWhereInput | audit_logsWhereInput[]
    OR?: audit_logsWhereInput[]
    NOT?: audit_logsWhereInput | audit_logsWhereInput[]
    id?: IntFilter<"audit_logs"> | number
    timestamp?: DateTimeFilter<"audit_logs"> | Date | string
    action?: StringFilter<"audit_logs"> | string
    entity?: StringFilter<"audit_logs"> | string
    entity_id?: StringFilter<"audit_logs"> | string
    details?: StringNullableFilter<"audit_logs"> | string | null
    user?: StringNullableFilter<"audit_logs"> | string | null
    ip_address?: StringNullableFilter<"audit_logs"> | string | null
  }

  export type audit_logsOrderByWithRelationInput = {
    id?: SortOrder
    timestamp?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    entity_id?: SortOrder
    details?: SortOrderInput | SortOrder
    user?: SortOrderInput | SortOrder
    ip_address?: SortOrderInput | SortOrder
  }

  export type audit_logsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: audit_logsWhereInput | audit_logsWhereInput[]
    OR?: audit_logsWhereInput[]
    NOT?: audit_logsWhereInput | audit_logsWhereInput[]
    timestamp?: DateTimeFilter<"audit_logs"> | Date | string
    action?: StringFilter<"audit_logs"> | string
    entity?: StringFilter<"audit_logs"> | string
    entity_id?: StringFilter<"audit_logs"> | string
    details?: StringNullableFilter<"audit_logs"> | string | null
    user?: StringNullableFilter<"audit_logs"> | string | null
    ip_address?: StringNullableFilter<"audit_logs"> | string | null
  }, "id">

  export type audit_logsOrderByWithAggregationInput = {
    id?: SortOrder
    timestamp?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    entity_id?: SortOrder
    details?: SortOrderInput | SortOrder
    user?: SortOrderInput | SortOrder
    ip_address?: SortOrderInput | SortOrder
    _count?: audit_logsCountOrderByAggregateInput
    _avg?: audit_logsAvgOrderByAggregateInput
    _max?: audit_logsMaxOrderByAggregateInput
    _min?: audit_logsMinOrderByAggregateInput
    _sum?: audit_logsSumOrderByAggregateInput
  }

  export type audit_logsScalarWhereWithAggregatesInput = {
    AND?: audit_logsScalarWhereWithAggregatesInput | audit_logsScalarWhereWithAggregatesInput[]
    OR?: audit_logsScalarWhereWithAggregatesInput[]
    NOT?: audit_logsScalarWhereWithAggregatesInput | audit_logsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"audit_logs"> | number
    timestamp?: DateTimeWithAggregatesFilter<"audit_logs"> | Date | string
    action?: StringWithAggregatesFilter<"audit_logs"> | string
    entity?: StringWithAggregatesFilter<"audit_logs"> | string
    entity_id?: StringWithAggregatesFilter<"audit_logs"> | string
    details?: StringNullableWithAggregatesFilter<"audit_logs"> | string | null
    user?: StringNullableWithAggregatesFilter<"audit_logs"> | string | null
    ip_address?: StringNullableWithAggregatesFilter<"audit_logs"> | string | null
  }

  export type logs_editWhereInput = {
    AND?: logs_editWhereInput | logs_editWhereInput[]
    OR?: logs_editWhereInput[]
    NOT?: logs_editWhereInput | logs_editWhereInput[]
    id?: IntFilter<"logs_edit"> | number
    timestamp?: DateTimeFilter<"logs_edit"> | Date | string
    desc?: StringFilter<"logs_edit"> | string
    code?: StringFilter<"logs_edit"> | string
    line?: StringFilter<"logs_edit"> | string
    user?: StringFilter<"logs_edit"> | string
  }

  export type logs_editOrderByWithRelationInput = {
    id?: SortOrder
    timestamp?: SortOrder
    desc?: SortOrder
    code?: SortOrder
    line?: SortOrder
    user?: SortOrder
  }

  export type logs_editWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: logs_editWhereInput | logs_editWhereInput[]
    OR?: logs_editWhereInput[]
    NOT?: logs_editWhereInput | logs_editWhereInput[]
    timestamp?: DateTimeFilter<"logs_edit"> | Date | string
    desc?: StringFilter<"logs_edit"> | string
    code?: StringFilter<"logs_edit"> | string
    line?: StringFilter<"logs_edit"> | string
    user?: StringFilter<"logs_edit"> | string
  }, "id">

  export type logs_editOrderByWithAggregationInput = {
    id?: SortOrder
    timestamp?: SortOrder
    desc?: SortOrder
    code?: SortOrder
    line?: SortOrder
    user?: SortOrder
    _count?: logs_editCountOrderByAggregateInput
    _avg?: logs_editAvgOrderByAggregateInput
    _max?: logs_editMaxOrderByAggregateInput
    _min?: logs_editMinOrderByAggregateInput
    _sum?: logs_editSumOrderByAggregateInput
  }

  export type logs_editScalarWhereWithAggregatesInput = {
    AND?: logs_editScalarWhereWithAggregatesInput | logs_editScalarWhereWithAggregatesInput[]
    OR?: logs_editScalarWhereWithAggregatesInput[]
    NOT?: logs_editScalarWhereWithAggregatesInput | logs_editScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"logs_edit"> | number
    timestamp?: DateTimeWithAggregatesFilter<"logs_edit"> | Date | string
    desc?: StringWithAggregatesFilter<"logs_edit"> | string
    code?: StringWithAggregatesFilter<"logs_edit"> | string
    line?: StringWithAggregatesFilter<"logs_edit"> | string
    user?: StringWithAggregatesFilter<"logs_edit"> | string
  }

  export type meter_typeWhereInput = {
    AND?: meter_typeWhereInput | meter_typeWhereInput[]
    OR?: meter_typeWhereInput[]
    NOT?: meter_typeWhereInput | meter_typeWhereInput[]
    id?: IntFilter<"meter_type"> | number
    value?: StringFilter<"meter_type"> | string
    phase?: StringFilter<"meter_type"> | string
    validation?: StringFilter<"meter_type"> | string
    validation_length?: IntFilter<"meter_type"> | number
    length?: IntFilter<"meter_type"> | number
    pln_code?: StringFilter<"meter_type"> | string
    card_validation?: Enummeter_type_card_validationFilter<"meter_type"> | $Enums.meter_type_card_validation
    validation_type?: Enummeter_type_validation_typeNullableFilter<"meter_type"> | $Enums.meter_type_validation_type | null
    daily_reset?: Enummeter_type_daily_resetFilter<"meter_type"> | $Enums.meter_type_daily_reset
    numeric_only?: Enummeter_type_numeric_onlyFilter<"meter_type"> | $Enums.meter_type_numeric_only
    surpass_target?: Enummeter_type_surpass_targetFilter<"meter_type"> | $Enums.meter_type_surpass_target
    run_by_sequence?: Enummeter_type_run_by_sequenceFilter<"meter_type"> | $Enums.meter_type_run_by_sequence
    start_reset?: StringFilter<"meter_type"> | string
    end_reset?: StringFilter<"meter_type"> | string
  }

  export type meter_typeOrderByWithRelationInput = {
    id?: SortOrder
    value?: SortOrder
    phase?: SortOrder
    validation?: SortOrder
    validation_length?: SortOrder
    length?: SortOrder
    pln_code?: SortOrder
    card_validation?: SortOrder
    validation_type?: SortOrderInput | SortOrder
    daily_reset?: SortOrder
    numeric_only?: SortOrder
    surpass_target?: SortOrder
    run_by_sequence?: SortOrder
    start_reset?: SortOrder
    end_reset?: SortOrder
  }

  export type meter_typeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: meter_typeWhereInput | meter_typeWhereInput[]
    OR?: meter_typeWhereInput[]
    NOT?: meter_typeWhereInput | meter_typeWhereInput[]
    value?: StringFilter<"meter_type"> | string
    phase?: StringFilter<"meter_type"> | string
    validation?: StringFilter<"meter_type"> | string
    validation_length?: IntFilter<"meter_type"> | number
    length?: IntFilter<"meter_type"> | number
    pln_code?: StringFilter<"meter_type"> | string
    card_validation?: Enummeter_type_card_validationFilter<"meter_type"> | $Enums.meter_type_card_validation
    validation_type?: Enummeter_type_validation_typeNullableFilter<"meter_type"> | $Enums.meter_type_validation_type | null
    daily_reset?: Enummeter_type_daily_resetFilter<"meter_type"> | $Enums.meter_type_daily_reset
    numeric_only?: Enummeter_type_numeric_onlyFilter<"meter_type"> | $Enums.meter_type_numeric_only
    surpass_target?: Enummeter_type_surpass_targetFilter<"meter_type"> | $Enums.meter_type_surpass_target
    run_by_sequence?: Enummeter_type_run_by_sequenceFilter<"meter_type"> | $Enums.meter_type_run_by_sequence
    start_reset?: StringFilter<"meter_type"> | string
    end_reset?: StringFilter<"meter_type"> | string
  }, "id">

  export type meter_typeOrderByWithAggregationInput = {
    id?: SortOrder
    value?: SortOrder
    phase?: SortOrder
    validation?: SortOrder
    validation_length?: SortOrder
    length?: SortOrder
    pln_code?: SortOrder
    card_validation?: SortOrder
    validation_type?: SortOrderInput | SortOrder
    daily_reset?: SortOrder
    numeric_only?: SortOrder
    surpass_target?: SortOrder
    run_by_sequence?: SortOrder
    start_reset?: SortOrder
    end_reset?: SortOrder
    _count?: meter_typeCountOrderByAggregateInput
    _avg?: meter_typeAvgOrderByAggregateInput
    _max?: meter_typeMaxOrderByAggregateInput
    _min?: meter_typeMinOrderByAggregateInput
    _sum?: meter_typeSumOrderByAggregateInput
  }

  export type meter_typeScalarWhereWithAggregatesInput = {
    AND?: meter_typeScalarWhereWithAggregatesInput | meter_typeScalarWhereWithAggregatesInput[]
    OR?: meter_typeScalarWhereWithAggregatesInput[]
    NOT?: meter_typeScalarWhereWithAggregatesInput | meter_typeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"meter_type"> | number
    value?: StringWithAggregatesFilter<"meter_type"> | string
    phase?: StringWithAggregatesFilter<"meter_type"> | string
    validation?: StringWithAggregatesFilter<"meter_type"> | string
    validation_length?: IntWithAggregatesFilter<"meter_type"> | number
    length?: IntWithAggregatesFilter<"meter_type"> | number
    pln_code?: StringWithAggregatesFilter<"meter_type"> | string
    card_validation?: Enummeter_type_card_validationWithAggregatesFilter<"meter_type"> | $Enums.meter_type_card_validation
    validation_type?: Enummeter_type_validation_typeNullableWithAggregatesFilter<"meter_type"> | $Enums.meter_type_validation_type | null
    daily_reset?: Enummeter_type_daily_resetWithAggregatesFilter<"meter_type"> | $Enums.meter_type_daily_reset
    numeric_only?: Enummeter_type_numeric_onlyWithAggregatesFilter<"meter_type"> | $Enums.meter_type_numeric_only
    surpass_target?: Enummeter_type_surpass_targetWithAggregatesFilter<"meter_type"> | $Enums.meter_type_surpass_target
    run_by_sequence?: Enummeter_type_run_by_sequenceWithAggregatesFilter<"meter_type"> | $Enums.meter_type_run_by_sequence
    start_reset?: StringWithAggregatesFilter<"meter_type"> | string
    end_reset?: StringWithAggregatesFilter<"meter_type"> | string
  }

  export type module_listWhereInput = {
    AND?: module_listWhereInput | module_listWhereInput[]
    OR?: module_listWhereInput[]
    NOT?: module_listWhereInput | module_listWhereInput[]
    module_id?: IntFilter<"module_list"> | number
    module_serial?: StringFilter<"module_list"> | string
  }

  export type module_listOrderByWithRelationInput = {
    module_id?: SortOrder
    module_serial?: SortOrder
  }

  export type module_listWhereUniqueInput = Prisma.AtLeast<{
    module_id?: number
    module_serial?: string
    AND?: module_listWhereInput | module_listWhereInput[]
    OR?: module_listWhereInput[]
    NOT?: module_listWhereInput | module_listWhereInput[]
  }, "module_id" | "module_serial">

  export type module_listOrderByWithAggregationInput = {
    module_id?: SortOrder
    module_serial?: SortOrder
    _count?: module_listCountOrderByAggregateInput
    _avg?: module_listAvgOrderByAggregateInput
    _max?: module_listMaxOrderByAggregateInput
    _min?: module_listMinOrderByAggregateInput
    _sum?: module_listSumOrderByAggregateInput
  }

  export type module_listScalarWhereWithAggregatesInput = {
    AND?: module_listScalarWhereWithAggregatesInput | module_listScalarWhereWithAggregatesInput[]
    OR?: module_listScalarWhereWithAggregatesInput[]
    NOT?: module_listScalarWhereWithAggregatesInput | module_listScalarWhereWithAggregatesInput[]
    module_id?: IntWithAggregatesFilter<"module_list"> | number
    module_serial?: StringWithAggregatesFilter<"module_list"> | string
  }

  export type order_numWhereInput = {
    AND?: order_numWhereInput | order_numWhereInput[]
    OR?: order_numWhereInput[]
    NOT?: order_numWhereInput | order_numWhereInput[]
    id?: IntFilter<"order_num"> | number
    value?: StringFilter<"order_num"> | string
    counter?: IntFilter<"order_num"> | number
  }

  export type order_numOrderByWithRelationInput = {
    id?: SortOrder
    value?: SortOrder
    counter?: SortOrder
  }

  export type order_numWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: order_numWhereInput | order_numWhereInput[]
    OR?: order_numWhereInput[]
    NOT?: order_numWhereInput | order_numWhereInput[]
    value?: StringFilter<"order_num"> | string
    counter?: IntFilter<"order_num"> | number
  }, "id">

  export type order_numOrderByWithAggregationInput = {
    id?: SortOrder
    value?: SortOrder
    counter?: SortOrder
    _count?: order_numCountOrderByAggregateInput
    _avg?: order_numAvgOrderByAggregateInput
    _max?: order_numMaxOrderByAggregateInput
    _min?: order_numMinOrderByAggregateInput
    _sum?: order_numSumOrderByAggregateInput
  }

  export type order_numScalarWhereWithAggregatesInput = {
    AND?: order_numScalarWhereWithAggregatesInput | order_numScalarWhereWithAggregatesInput[]
    OR?: order_numScalarWhereWithAggregatesInput[]
    NOT?: order_numScalarWhereWithAggregatesInput | order_numScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"order_num"> | number
    value?: StringWithAggregatesFilter<"order_num"> | string
    counter?: IntWithAggregatesFilter<"order_num"> | number
  }

  export type out_110WhereInput = {
    AND?: out_110WhereInput | out_110WhereInput[]
    OR?: out_110WhereInput[]
    NOT?: out_110WhereInput | out_110WhereInput[]
    id?: IntFilter<"out_110"> | number
    serial?: StringFilter<"out_110"> | string
    qr_serial?: StringFilter<"out_110"> | string
    timestamp?: DateTimeFilter<"out_110"> | Date | string
    receive_id?: IntFilter<"out_110"> | number
  }

  export type out_110OrderByWithRelationInput = {
    id?: SortOrder
    serial?: SortOrder
    qr_serial?: SortOrder
    timestamp?: SortOrder
    receive_id?: SortOrder
  }

  export type out_110WhereUniqueInput = Prisma.AtLeast<{
    id?: number
    serial_qr_serial_receive_id?: out_110SerialQr_serialReceive_idCompoundUniqueInput
    AND?: out_110WhereInput | out_110WhereInput[]
    OR?: out_110WhereInput[]
    NOT?: out_110WhereInput | out_110WhereInput[]
    serial?: StringFilter<"out_110"> | string
    qr_serial?: StringFilter<"out_110"> | string
    timestamp?: DateTimeFilter<"out_110"> | Date | string
    receive_id?: IntFilter<"out_110"> | number
  }, "id" | "serial_qr_serial_receive_id">

  export type out_110OrderByWithAggregationInput = {
    id?: SortOrder
    serial?: SortOrder
    qr_serial?: SortOrder
    timestamp?: SortOrder
    receive_id?: SortOrder
    _count?: out_110CountOrderByAggregateInput
    _avg?: out_110AvgOrderByAggregateInput
    _max?: out_110MaxOrderByAggregateInput
    _min?: out_110MinOrderByAggregateInput
    _sum?: out_110SumOrderByAggregateInput
  }

  export type out_110ScalarWhereWithAggregatesInput = {
    AND?: out_110ScalarWhereWithAggregatesInput | out_110ScalarWhereWithAggregatesInput[]
    OR?: out_110ScalarWhereWithAggregatesInput[]
    NOT?: out_110ScalarWhereWithAggregatesInput | out_110ScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"out_110"> | number
    serial?: StringWithAggregatesFilter<"out_110"> | string
    qr_serial?: StringWithAggregatesFilter<"out_110"> | string
    timestamp?: DateTimeWithAggregatesFilter<"out_110"> | Date | string
    receive_id?: IntWithAggregatesFilter<"out_110"> | number
  }

  export type output_targetWhereInput = {
    AND?: output_targetWhereInput | output_targetWhereInput[]
    OR?: output_targetWhereInput[]
    NOT?: output_targetWhereInput | output_targetWhereInput[]
    id?: IntFilter<"output_target"> | number
    output?: StringFilter<"output_target"> | string
    type?: StringFilter<"output_target"> | string
    waktu?: StringFilter<"output_target"> | string
    line?: StringFilter<"output_target"> | string
    timestamp?: DateTimeFilter<"output_target"> | Date | string
  }

  export type output_targetOrderByWithRelationInput = {
    id?: SortOrder
    output?: SortOrder
    type?: SortOrder
    waktu?: SortOrder
    line?: SortOrder
    timestamp?: SortOrder
  }

  export type output_targetWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: output_targetWhereInput | output_targetWhereInput[]
    OR?: output_targetWhereInput[]
    NOT?: output_targetWhereInput | output_targetWhereInput[]
    output?: StringFilter<"output_target"> | string
    type?: StringFilter<"output_target"> | string
    waktu?: StringFilter<"output_target"> | string
    line?: StringFilter<"output_target"> | string
    timestamp?: DateTimeFilter<"output_target"> | Date | string
  }, "id">

  export type output_targetOrderByWithAggregationInput = {
    id?: SortOrder
    output?: SortOrder
    type?: SortOrder
    waktu?: SortOrder
    line?: SortOrder
    timestamp?: SortOrder
    _count?: output_targetCountOrderByAggregateInput
    _avg?: output_targetAvgOrderByAggregateInput
    _max?: output_targetMaxOrderByAggregateInput
    _min?: output_targetMinOrderByAggregateInput
    _sum?: output_targetSumOrderByAggregateInput
  }

  export type output_targetScalarWhereWithAggregatesInput = {
    AND?: output_targetScalarWhereWithAggregatesInput | output_targetScalarWhereWithAggregatesInput[]
    OR?: output_targetScalarWhereWithAggregatesInput[]
    NOT?: output_targetScalarWhereWithAggregatesInput | output_targetScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"output_target"> | number
    output?: StringWithAggregatesFilter<"output_target"> | string
    type?: StringWithAggregatesFilter<"output_target"> | string
    waktu?: StringWithAggregatesFilter<"output_target"> | string
    line?: StringWithAggregatesFilter<"output_target"> | string
    timestamp?: DateTimeWithAggregatesFilter<"output_target"> | Date | string
  }

  export type output_tempWhereInput = {
    AND?: output_tempWhereInput | output_tempWhereInput[]
    OR?: output_tempWhereInput[]
    NOT?: output_tempWhereInput | output_tempWhereInput[]
    id?: IntFilter<"output_temp"> | number
    type?: StringNullableFilter<"output_temp"> | string | null
    total_output?: IntFilter<"output_temp"> | number
    line?: StringFilter<"output_temp"> | string
    tahun?: StringNullableFilter<"output_temp"> | string | null
    timestamp?: DateTimeFilter<"output_temp"> | Date | string
    total_bigbox?: IntFilter<"output_temp"> | number
    total_pallet?: IntFilter<"output_temp"> | number
    target?: IntFilter<"output_temp"> | number
    target_hour?: IntFilter<"output_temp"> | number
    hour1?: IntFilter<"output_temp"> | number
    hour2?: IntFilter<"output_temp"> | number
    hour3?: IntFilter<"output_temp"> | number
    hour4?: IntFilter<"output_temp"> | number
    hour5?: IntFilter<"output_temp"> | number
    hour6?: IntFilter<"output_temp"> | number
    hour7?: IntFilter<"output_temp"> | number
    hour8?: IntFilter<"output_temp"> | number
    hour9?: IntFilter<"output_temp"> | number
    hour10?: IntFilter<"output_temp"> | number
    hour11?: IntFilter<"output_temp"> | number
    hour12?: IntFilter<"output_temp"> | number
  }

  export type output_tempOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrderInput | SortOrder
    total_output?: SortOrder
    line?: SortOrder
    tahun?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    total_bigbox?: SortOrder
    total_pallet?: SortOrder
    target?: SortOrder
    target_hour?: SortOrder
    hour1?: SortOrder
    hour2?: SortOrder
    hour3?: SortOrder
    hour4?: SortOrder
    hour5?: SortOrder
    hour6?: SortOrder
    hour7?: SortOrder
    hour8?: SortOrder
    hour9?: SortOrder
    hour10?: SortOrder
    hour11?: SortOrder
    hour12?: SortOrder
  }

  export type output_tempWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: output_tempWhereInput | output_tempWhereInput[]
    OR?: output_tempWhereInput[]
    NOT?: output_tempWhereInput | output_tempWhereInput[]
    type?: StringNullableFilter<"output_temp"> | string | null
    total_output?: IntFilter<"output_temp"> | number
    line?: StringFilter<"output_temp"> | string
    tahun?: StringNullableFilter<"output_temp"> | string | null
    timestamp?: DateTimeFilter<"output_temp"> | Date | string
    total_bigbox?: IntFilter<"output_temp"> | number
    total_pallet?: IntFilter<"output_temp"> | number
    target?: IntFilter<"output_temp"> | number
    target_hour?: IntFilter<"output_temp"> | number
    hour1?: IntFilter<"output_temp"> | number
    hour2?: IntFilter<"output_temp"> | number
    hour3?: IntFilter<"output_temp"> | number
    hour4?: IntFilter<"output_temp"> | number
    hour5?: IntFilter<"output_temp"> | number
    hour6?: IntFilter<"output_temp"> | number
    hour7?: IntFilter<"output_temp"> | number
    hour8?: IntFilter<"output_temp"> | number
    hour9?: IntFilter<"output_temp"> | number
    hour10?: IntFilter<"output_temp"> | number
    hour11?: IntFilter<"output_temp"> | number
    hour12?: IntFilter<"output_temp"> | number
  }, "id">

  export type output_tempOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrderInput | SortOrder
    total_output?: SortOrder
    line?: SortOrder
    tahun?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    total_bigbox?: SortOrder
    total_pallet?: SortOrder
    target?: SortOrder
    target_hour?: SortOrder
    hour1?: SortOrder
    hour2?: SortOrder
    hour3?: SortOrder
    hour4?: SortOrder
    hour5?: SortOrder
    hour6?: SortOrder
    hour7?: SortOrder
    hour8?: SortOrder
    hour9?: SortOrder
    hour10?: SortOrder
    hour11?: SortOrder
    hour12?: SortOrder
    _count?: output_tempCountOrderByAggregateInput
    _avg?: output_tempAvgOrderByAggregateInput
    _max?: output_tempMaxOrderByAggregateInput
    _min?: output_tempMinOrderByAggregateInput
    _sum?: output_tempSumOrderByAggregateInput
  }

  export type output_tempScalarWhereWithAggregatesInput = {
    AND?: output_tempScalarWhereWithAggregatesInput | output_tempScalarWhereWithAggregatesInput[]
    OR?: output_tempScalarWhereWithAggregatesInput[]
    NOT?: output_tempScalarWhereWithAggregatesInput | output_tempScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"output_temp"> | number
    type?: StringNullableWithAggregatesFilter<"output_temp"> | string | null
    total_output?: IntWithAggregatesFilter<"output_temp"> | number
    line?: StringWithAggregatesFilter<"output_temp"> | string
    tahun?: StringNullableWithAggregatesFilter<"output_temp"> | string | null
    timestamp?: DateTimeWithAggregatesFilter<"output_temp"> | Date | string
    total_bigbox?: IntWithAggregatesFilter<"output_temp"> | number
    total_pallet?: IntWithAggregatesFilter<"output_temp"> | number
    target?: IntWithAggregatesFilter<"output_temp"> | number
    target_hour?: IntWithAggregatesFilter<"output_temp"> | number
    hour1?: IntWithAggregatesFilter<"output_temp"> | number
    hour2?: IntWithAggregatesFilter<"output_temp"> | number
    hour3?: IntWithAggregatesFilter<"output_temp"> | number
    hour4?: IntWithAggregatesFilter<"output_temp"> | number
    hour5?: IntWithAggregatesFilter<"output_temp"> | number
    hour6?: IntWithAggregatesFilter<"output_temp"> | number
    hour7?: IntWithAggregatesFilter<"output_temp"> | number
    hour8?: IntWithAggregatesFilter<"output_temp"> | number
    hour9?: IntWithAggregatesFilter<"output_temp"> | number
    hour10?: IntWithAggregatesFilter<"output_temp"> | number
    hour11?: IntWithAggregatesFilter<"output_temp"> | number
    hour12?: IntWithAggregatesFilter<"output_temp"> | number
  }

  export type palleteWhereInput = {
    AND?: palleteWhereInput | palleteWhereInput[]
    OR?: palleteWhereInput[]
    NOT?: palleteWhereInput | palleteWhereInput[]
    id?: IntFilter<"pallete"> | number
    serial?: StringFilter<"pallete"> | string
    timestamp?: DateTimeFilter<"pallete"> | Date | string
    line?: StringFilter<"pallete"> | string
    type?: StringFilter<"pallete"> | string
    location?: StringFilter<"pallete"> | string
  }

  export type palleteOrderByWithRelationInput = {
    id?: SortOrder
    serial?: SortOrder
    timestamp?: SortOrder
    line?: SortOrder
    type?: SortOrder
    location?: SortOrder
  }

  export type palleteWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    serial?: string
    AND?: palleteWhereInput | palleteWhereInput[]
    OR?: palleteWhereInput[]
    NOT?: palleteWhereInput | palleteWhereInput[]
    timestamp?: DateTimeFilter<"pallete"> | Date | string
    line?: StringFilter<"pallete"> | string
    type?: StringFilter<"pallete"> | string
    location?: StringFilter<"pallete"> | string
  }, "id" | "serial">

  export type palleteOrderByWithAggregationInput = {
    id?: SortOrder
    serial?: SortOrder
    timestamp?: SortOrder
    line?: SortOrder
    type?: SortOrder
    location?: SortOrder
    _count?: palleteCountOrderByAggregateInput
    _avg?: palleteAvgOrderByAggregateInput
    _max?: palleteMaxOrderByAggregateInput
    _min?: palleteMinOrderByAggregateInput
    _sum?: palleteSumOrderByAggregateInput
  }

  export type palleteScalarWhereWithAggregatesInput = {
    AND?: palleteScalarWhereWithAggregatesInput | palleteScalarWhereWithAggregatesInput[]
    OR?: palleteScalarWhereWithAggregatesInput[]
    NOT?: palleteScalarWhereWithAggregatesInput | palleteScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"pallete"> | number
    serial?: StringWithAggregatesFilter<"pallete"> | string
    timestamp?: DateTimeWithAggregatesFilter<"pallete"> | Date | string
    line?: StringWithAggregatesFilter<"pallete"> | string
    type?: StringWithAggregatesFilter<"pallete"> | string
    location?: StringWithAggregatesFilter<"pallete"> | string
  }

  export type pln_codeWhereInput = {
    AND?: pln_codeWhereInput | pln_codeWhereInput[]
    OR?: pln_codeWhereInput[]
    NOT?: pln_codeWhereInput | pln_codeWhereInput[]
    id?: IntFilter<"pln_code"> | number
    value?: StringFilter<"pln_code"> | string
  }

  export type pln_codeOrderByWithRelationInput = {
    id?: SortOrder
    value?: SortOrder
  }

  export type pln_codeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: pln_codeWhereInput | pln_codeWhereInput[]
    OR?: pln_codeWhereInput[]
    NOT?: pln_codeWhereInput | pln_codeWhereInput[]
    value?: StringFilter<"pln_code"> | string
  }, "id">

  export type pln_codeOrderByWithAggregationInput = {
    id?: SortOrder
    value?: SortOrder
    _count?: pln_codeCountOrderByAggregateInput
    _avg?: pln_codeAvgOrderByAggregateInput
    _max?: pln_codeMaxOrderByAggregateInput
    _min?: pln_codeMinOrderByAggregateInput
    _sum?: pln_codeSumOrderByAggregateInput
  }

  export type pln_codeScalarWhereWithAggregatesInput = {
    AND?: pln_codeScalarWhereWithAggregatesInput | pln_codeScalarWhereWithAggregatesInput[]
    OR?: pln_codeScalarWhereWithAggregatesInput[]
    NOT?: pln_codeScalarWhereWithAggregatesInput | pln_codeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"pln_code"> | number
    value?: StringWithAggregatesFilter<"pln_code"> | string
  }

  export type productWhereInput = {
    AND?: productWhereInput | productWhereInput[]
    OR?: productWhereInput[]
    NOT?: productWhereInput | productWhereInput[]
    id?: IntFilter<"product"> | number
    serial?: StringFilter<"product"> | string
    module_serial?: StringNullableFilter<"product"> | string | null
    timestamp?: DateTimeFilter<"product"> | Date | string
    line?: StringFilter<"product"> | string
    type?: StringFilter<"product"> | string
    orderno?: StringFilter<"product"> | string
    area?: StringNullableFilter<"product"> | string | null
    jenis?: StringNullableFilter<"product"> | string | null
    box_id?: IntNullableFilter<"product"> | number | null
    attachment_id?: IntNullableFilter<"product"> | number | null
    attachment2_id?: IntNullableFilter<"product"> | number | null
    remain?: StringFilter<"product"> | string
    garansi?: StringNullableFilter<"product"> | string | null
  }

  export type productOrderByWithRelationInput = {
    id?: SortOrder
    serial?: SortOrder
    module_serial?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    line?: SortOrder
    type?: SortOrder
    orderno?: SortOrder
    area?: SortOrderInput | SortOrder
    jenis?: SortOrderInput | SortOrder
    box_id?: SortOrderInput | SortOrder
    attachment_id?: SortOrderInput | SortOrder
    attachment2_id?: SortOrderInput | SortOrder
    remain?: SortOrder
    garansi?: SortOrderInput | SortOrder
  }

  export type productWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    serial?: string
    module_serial?: string
    AND?: productWhereInput | productWhereInput[]
    OR?: productWhereInput[]
    NOT?: productWhereInput | productWhereInput[]
    timestamp?: DateTimeFilter<"product"> | Date | string
    line?: StringFilter<"product"> | string
    type?: StringFilter<"product"> | string
    orderno?: StringFilter<"product"> | string
    area?: StringNullableFilter<"product"> | string | null
    jenis?: StringNullableFilter<"product"> | string | null
    box_id?: IntNullableFilter<"product"> | number | null
    attachment_id?: IntNullableFilter<"product"> | number | null
    attachment2_id?: IntNullableFilter<"product"> | number | null
    remain?: StringFilter<"product"> | string
    garansi?: StringNullableFilter<"product"> | string | null
  }, "id" | "serial" | "module_serial">

  export type productOrderByWithAggregationInput = {
    id?: SortOrder
    serial?: SortOrder
    module_serial?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    line?: SortOrder
    type?: SortOrder
    orderno?: SortOrder
    area?: SortOrderInput | SortOrder
    jenis?: SortOrderInput | SortOrder
    box_id?: SortOrderInput | SortOrder
    attachment_id?: SortOrderInput | SortOrder
    attachment2_id?: SortOrderInput | SortOrder
    remain?: SortOrder
    garansi?: SortOrderInput | SortOrder
    _count?: productCountOrderByAggregateInput
    _avg?: productAvgOrderByAggregateInput
    _max?: productMaxOrderByAggregateInput
    _min?: productMinOrderByAggregateInput
    _sum?: productSumOrderByAggregateInput
  }

  export type productScalarWhereWithAggregatesInput = {
    AND?: productScalarWhereWithAggregatesInput | productScalarWhereWithAggregatesInput[]
    OR?: productScalarWhereWithAggregatesInput[]
    NOT?: productScalarWhereWithAggregatesInput | productScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"product"> | number
    serial?: StringWithAggregatesFilter<"product"> | string
    module_serial?: StringNullableWithAggregatesFilter<"product"> | string | null
    timestamp?: DateTimeWithAggregatesFilter<"product"> | Date | string
    line?: StringWithAggregatesFilter<"product"> | string
    type?: StringWithAggregatesFilter<"product"> | string
    orderno?: StringWithAggregatesFilter<"product"> | string
    area?: StringNullableWithAggregatesFilter<"product"> | string | null
    jenis?: StringNullableWithAggregatesFilter<"product"> | string | null
    box_id?: IntNullableWithAggregatesFilter<"product"> | number | null
    attachment_id?: IntNullableWithAggregatesFilter<"product"> | number | null
    attachment2_id?: IntNullableWithAggregatesFilter<"product"> | number | null
    remain?: StringWithAggregatesFilter<"product"> | string
    garansi?: StringNullableWithAggregatesFilter<"product"> | string | null
  }

  export type production_ngWhereInput = {
    AND?: production_ngWhereInput | production_ngWhereInput[]
    OR?: production_ngWhereInput[]
    NOT?: production_ngWhereInput | production_ngWhereInput[]
    id?: IntFilter<"production_ng"> | number
    meter_type?: StringFilter<"production_ng"> | string
    serial?: StringFilter<"production_ng"> | string
    tanggal?: DateTimeFilter<"production_ng"> | Date | string
    station?: StringFilter<"production_ng"> | string
    line?: StringFilter<"production_ng"> | string
    defect?: StringFilter<"production_ng"> | string
    category?: StringNullableFilter<"production_ng"> | string | null
    department?: StringNullableFilter<"production_ng"> | string | null
    action?: StringNullableFilter<"production_ng"> | string | null
    keterangan?: StringNullableFilter<"production_ng"> | string | null
    update_date?: DateTimeNullableFilter<"production_ng"> | Date | string | null
    user?: StringNullableFilter<"production_ng"> | string | null
  }

  export type production_ngOrderByWithRelationInput = {
    id?: SortOrder
    meter_type?: SortOrder
    serial?: SortOrder
    tanggal?: SortOrder
    station?: SortOrder
    line?: SortOrder
    defect?: SortOrder
    category?: SortOrderInput | SortOrder
    department?: SortOrderInput | SortOrder
    action?: SortOrderInput | SortOrder
    keterangan?: SortOrderInput | SortOrder
    update_date?: SortOrderInput | SortOrder
    user?: SortOrderInput | SortOrder
  }

  export type production_ngWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: production_ngWhereInput | production_ngWhereInput[]
    OR?: production_ngWhereInput[]
    NOT?: production_ngWhereInput | production_ngWhereInput[]
    meter_type?: StringFilter<"production_ng"> | string
    serial?: StringFilter<"production_ng"> | string
    tanggal?: DateTimeFilter<"production_ng"> | Date | string
    station?: StringFilter<"production_ng"> | string
    line?: StringFilter<"production_ng"> | string
    defect?: StringFilter<"production_ng"> | string
    category?: StringNullableFilter<"production_ng"> | string | null
    department?: StringNullableFilter<"production_ng"> | string | null
    action?: StringNullableFilter<"production_ng"> | string | null
    keterangan?: StringNullableFilter<"production_ng"> | string | null
    update_date?: DateTimeNullableFilter<"production_ng"> | Date | string | null
    user?: StringNullableFilter<"production_ng"> | string | null
  }, "id">

  export type production_ngOrderByWithAggregationInput = {
    id?: SortOrder
    meter_type?: SortOrder
    serial?: SortOrder
    tanggal?: SortOrder
    station?: SortOrder
    line?: SortOrder
    defect?: SortOrder
    category?: SortOrderInput | SortOrder
    department?: SortOrderInput | SortOrder
    action?: SortOrderInput | SortOrder
    keterangan?: SortOrderInput | SortOrder
    update_date?: SortOrderInput | SortOrder
    user?: SortOrderInput | SortOrder
    _count?: production_ngCountOrderByAggregateInput
    _avg?: production_ngAvgOrderByAggregateInput
    _max?: production_ngMaxOrderByAggregateInput
    _min?: production_ngMinOrderByAggregateInput
    _sum?: production_ngSumOrderByAggregateInput
  }

  export type production_ngScalarWhereWithAggregatesInput = {
    AND?: production_ngScalarWhereWithAggregatesInput | production_ngScalarWhereWithAggregatesInput[]
    OR?: production_ngScalarWhereWithAggregatesInput[]
    NOT?: production_ngScalarWhereWithAggregatesInput | production_ngScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"production_ng"> | number
    meter_type?: StringWithAggregatesFilter<"production_ng"> | string
    serial?: StringWithAggregatesFilter<"production_ng"> | string
    tanggal?: DateTimeWithAggregatesFilter<"production_ng"> | Date | string
    station?: StringWithAggregatesFilter<"production_ng"> | string
    line?: StringWithAggregatesFilter<"production_ng"> | string
    defect?: StringWithAggregatesFilter<"production_ng"> | string
    category?: StringNullableWithAggregatesFilter<"production_ng"> | string | null
    department?: StringNullableWithAggregatesFilter<"production_ng"> | string | null
    action?: StringNullableWithAggregatesFilter<"production_ng"> | string | null
    keterangan?: StringNullableWithAggregatesFilter<"production_ng"> | string | null
    update_date?: DateTimeNullableWithAggregatesFilter<"production_ng"> | Date | string | null
    user?: StringNullableWithAggregatesFilter<"production_ng"> | string | null
  }

  export type productionorderWhereInput = {
    AND?: productionorderWhereInput | productionorderWhereInput[]
    OR?: productionorderWhereInput[]
    NOT?: productionorderWhereInput | productionorderWhereInput[]
    id?: IntFilter<"productionorder"> | number
    timestamp?: DateTimeFilter<"productionorder"> | Date | string
    ponum?: StringFilter<"productionorder"> | string
    area?: StringFilter<"productionorder"> | string
    provinsi?: StringFilter<"productionorder"> | string
    count_qty?: StringFilter<"productionorder"> | string
    qty?: IntFilter<"productionorder"> | number
    status?: IntFilter<"productionorder"> | number
    keterangan?: IntNullableFilter<"productionorder"> | number | null
  }

  export type productionorderOrderByWithRelationInput = {
    id?: SortOrder
    timestamp?: SortOrder
    ponum?: SortOrder
    area?: SortOrder
    provinsi?: SortOrder
    count_qty?: SortOrder
    qty?: SortOrder
    status?: SortOrder
    keterangan?: SortOrderInput | SortOrder
  }

  export type productionorderWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: productionorderWhereInput | productionorderWhereInput[]
    OR?: productionorderWhereInput[]
    NOT?: productionorderWhereInput | productionorderWhereInput[]
    timestamp?: DateTimeFilter<"productionorder"> | Date | string
    ponum?: StringFilter<"productionorder"> | string
    area?: StringFilter<"productionorder"> | string
    provinsi?: StringFilter<"productionorder"> | string
    count_qty?: StringFilter<"productionorder"> | string
    qty?: IntFilter<"productionorder"> | number
    status?: IntFilter<"productionorder"> | number
    keterangan?: IntNullableFilter<"productionorder"> | number | null
  }, "id">

  export type productionorderOrderByWithAggregationInput = {
    id?: SortOrder
    timestamp?: SortOrder
    ponum?: SortOrder
    area?: SortOrder
    provinsi?: SortOrder
    count_qty?: SortOrder
    qty?: SortOrder
    status?: SortOrder
    keterangan?: SortOrderInput | SortOrder
    _count?: productionorderCountOrderByAggregateInput
    _avg?: productionorderAvgOrderByAggregateInput
    _max?: productionorderMaxOrderByAggregateInput
    _min?: productionorderMinOrderByAggregateInput
    _sum?: productionorderSumOrderByAggregateInput
  }

  export type productionorderScalarWhereWithAggregatesInput = {
    AND?: productionorderScalarWhereWithAggregatesInput | productionorderScalarWhereWithAggregatesInput[]
    OR?: productionorderScalarWhereWithAggregatesInput[]
    NOT?: productionorderScalarWhereWithAggregatesInput | productionorderScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"productionorder"> | number
    timestamp?: DateTimeWithAggregatesFilter<"productionorder"> | Date | string
    ponum?: StringWithAggregatesFilter<"productionorder"> | string
    area?: StringWithAggregatesFilter<"productionorder"> | string
    provinsi?: StringWithAggregatesFilter<"productionorder"> | string
    count_qty?: StringWithAggregatesFilter<"productionorder"> | string
    qty?: IntWithAggregatesFilter<"productionorder"> | number
    status?: IntWithAggregatesFilter<"productionorder"> | number
    keterangan?: IntNullableWithAggregatesFilter<"productionorder"> | number | null
  }

  export type receive_110WhereInput = {
    AND?: receive_110WhereInput | receive_110WhereInput[]
    OR?: receive_110WhereInput[]
    NOT?: receive_110WhereInput | receive_110WhereInput[]
    id?: IntFilter<"receive_110"> | number
    serial?: StringFilter<"receive_110"> | string
    qr_serial?: StringFilter<"receive_110"> | string
    timestamp?: DateTimeFilter<"receive_110"> | Date | string
    result?: Enumreceive_110_resultFilter<"receive_110"> | $Enums.receive_110_result
  }

  export type receive_110OrderByWithRelationInput = {
    id?: SortOrder
    serial?: SortOrder
    qr_serial?: SortOrder
    timestamp?: SortOrder
    result?: SortOrder
  }

  export type receive_110WhereUniqueInput = Prisma.AtLeast<{
    id?: number
    serial?: string
    AND?: receive_110WhereInput | receive_110WhereInput[]
    OR?: receive_110WhereInput[]
    NOT?: receive_110WhereInput | receive_110WhereInput[]
    qr_serial?: StringFilter<"receive_110"> | string
    timestamp?: DateTimeFilter<"receive_110"> | Date | string
    result?: Enumreceive_110_resultFilter<"receive_110"> | $Enums.receive_110_result
  }, "id" | "serial">

  export type receive_110OrderByWithAggregationInput = {
    id?: SortOrder
    serial?: SortOrder
    qr_serial?: SortOrder
    timestamp?: SortOrder
    result?: SortOrder
    _count?: receive_110CountOrderByAggregateInput
    _avg?: receive_110AvgOrderByAggregateInput
    _max?: receive_110MaxOrderByAggregateInput
    _min?: receive_110MinOrderByAggregateInput
    _sum?: receive_110SumOrderByAggregateInput
  }

  export type receive_110ScalarWhereWithAggregatesInput = {
    AND?: receive_110ScalarWhereWithAggregatesInput | receive_110ScalarWhereWithAggregatesInput[]
    OR?: receive_110ScalarWhereWithAggregatesInput[]
    NOT?: receive_110ScalarWhereWithAggregatesInput | receive_110ScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"receive_110"> | number
    serial?: StringWithAggregatesFilter<"receive_110"> | string
    qr_serial?: StringWithAggregatesFilter<"receive_110"> | string
    timestamp?: DateTimeWithAggregatesFilter<"receive_110"> | Date | string
    result?: Enumreceive_110_resultWithAggregatesFilter<"receive_110"> | $Enums.receive_110_result
  }

  export type rework_amrWhereInput = {
    AND?: rework_amrWhereInput | rework_amrWhereInput[]
    OR?: rework_amrWhereInput[]
    NOT?: rework_amrWhereInput | rework_amrWhereInput[]
    id?: IntFilter<"rework_amr"> | number
    serial?: StringNullableFilter<"rework_amr"> | string | null
    qr_serial?: StringFilter<"rework_amr"> | string
    timestamp?: DateTimeFilter<"rework_amr"> | Date | string
  }

  export type rework_amrOrderByWithRelationInput = {
    id?: SortOrder
    serial?: SortOrderInput | SortOrder
    qr_serial?: SortOrder
    timestamp?: SortOrder
  }

  export type rework_amrWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: rework_amrWhereInput | rework_amrWhereInput[]
    OR?: rework_amrWhereInput[]
    NOT?: rework_amrWhereInput | rework_amrWhereInput[]
    serial?: StringNullableFilter<"rework_amr"> | string | null
    qr_serial?: StringFilter<"rework_amr"> | string
    timestamp?: DateTimeFilter<"rework_amr"> | Date | string
  }, "id">

  export type rework_amrOrderByWithAggregationInput = {
    id?: SortOrder
    serial?: SortOrderInput | SortOrder
    qr_serial?: SortOrder
    timestamp?: SortOrder
    _count?: rework_amrCountOrderByAggregateInput
    _avg?: rework_amrAvgOrderByAggregateInput
    _max?: rework_amrMaxOrderByAggregateInput
    _min?: rework_amrMinOrderByAggregateInput
    _sum?: rework_amrSumOrderByAggregateInput
  }

  export type rework_amrScalarWhereWithAggregatesInput = {
    AND?: rework_amrScalarWhereWithAggregatesInput | rework_amrScalarWhereWithAggregatesInput[]
    OR?: rework_amrScalarWhereWithAggregatesInput[]
    NOT?: rework_amrScalarWhereWithAggregatesInput | rework_amrScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"rework_amr"> | number
    serial?: StringNullableWithAggregatesFilter<"rework_amr"> | string | null
    qr_serial?: StringWithAggregatesFilter<"rework_amr"> | string
    timestamp?: DateTimeWithAggregatesFilter<"rework_amr"> | Date | string
  }

  export type rework_boxWhereInput = {
    AND?: rework_boxWhereInput | rework_boxWhereInput[]
    OR?: rework_boxWhereInput[]
    NOT?: rework_boxWhereInput | rework_boxWhereInput[]
    id?: IntFilter<"rework_box"> | number
    serial?: StringFilter<"rework_box"> | string
    timestamp?: DateTimeFilter<"rework_box"> | Date | string
    line?: StringFilter<"rework_box"> | string
    type?: StringFilter<"rework_box"> | string
    pallete_id?: IntNullableFilter<"rework_box"> | number | null
    attachment_id?: IntNullableFilter<"rework_box"> | number | null
    attachment2_id?: IntNullableFilter<"rework_box"> | number | null
  }

  export type rework_boxOrderByWithRelationInput = {
    id?: SortOrder
    serial?: SortOrder
    timestamp?: SortOrder
    line?: SortOrder
    type?: SortOrder
    pallete_id?: SortOrderInput | SortOrder
    attachment_id?: SortOrderInput | SortOrder
    attachment2_id?: SortOrderInput | SortOrder
  }

  export type rework_boxWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: rework_boxWhereInput | rework_boxWhereInput[]
    OR?: rework_boxWhereInput[]
    NOT?: rework_boxWhereInput | rework_boxWhereInput[]
    serial?: StringFilter<"rework_box"> | string
    timestamp?: DateTimeFilter<"rework_box"> | Date | string
    line?: StringFilter<"rework_box"> | string
    type?: StringFilter<"rework_box"> | string
    pallete_id?: IntNullableFilter<"rework_box"> | number | null
    attachment_id?: IntNullableFilter<"rework_box"> | number | null
    attachment2_id?: IntNullableFilter<"rework_box"> | number | null
  }, "id">

  export type rework_boxOrderByWithAggregationInput = {
    id?: SortOrder
    serial?: SortOrder
    timestamp?: SortOrder
    line?: SortOrder
    type?: SortOrder
    pallete_id?: SortOrderInput | SortOrder
    attachment_id?: SortOrderInput | SortOrder
    attachment2_id?: SortOrderInput | SortOrder
    _count?: rework_boxCountOrderByAggregateInput
    _avg?: rework_boxAvgOrderByAggregateInput
    _max?: rework_boxMaxOrderByAggregateInput
    _min?: rework_boxMinOrderByAggregateInput
    _sum?: rework_boxSumOrderByAggregateInput
  }

  export type rework_boxScalarWhereWithAggregatesInput = {
    AND?: rework_boxScalarWhereWithAggregatesInput | rework_boxScalarWhereWithAggregatesInput[]
    OR?: rework_boxScalarWhereWithAggregatesInput[]
    NOT?: rework_boxScalarWhereWithAggregatesInput | rework_boxScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"rework_box"> | number
    serial?: StringWithAggregatesFilter<"rework_box"> | string
    timestamp?: DateTimeWithAggregatesFilter<"rework_box"> | Date | string
    line?: StringWithAggregatesFilter<"rework_box"> | string
    type?: StringWithAggregatesFilter<"rework_box"> | string
    pallete_id?: IntNullableWithAggregatesFilter<"rework_box"> | number | null
    attachment_id?: IntNullableWithAggregatesFilter<"rework_box"> | number | null
    attachment2_id?: IntNullableWithAggregatesFilter<"rework_box"> | number | null
  }

  export type rework_hxe110WhereInput = {
    AND?: rework_hxe110WhereInput | rework_hxe110WhereInput[]
    OR?: rework_hxe110WhereInput[]
    NOT?: rework_hxe110WhereInput | rework_hxe110WhereInput[]
    id?: IntFilter<"rework_hxe110"> | number
    meter_type?: StringFilter<"rework_hxe110"> | string
    meter_serial?: StringFilter<"rework_hxe110"> | string
    tanggal?: DateTimeFilter<"rework_hxe110"> | Date | string
    modem?: StringFilter<"rework_hxe110"> | string
    baterai?: StringFilter<"rework_hxe110"> | string
    defect?: StringFilter<"rework_hxe110"> | string
  }

  export type rework_hxe110OrderByWithRelationInput = {
    id?: SortOrder
    meter_type?: SortOrder
    meter_serial?: SortOrder
    tanggal?: SortOrder
    modem?: SortOrder
    baterai?: SortOrder
    defect?: SortOrder
  }

  export type rework_hxe110WhereUniqueInput = Prisma.AtLeast<{
    id?: number
    meter_serial?: string
    AND?: rework_hxe110WhereInput | rework_hxe110WhereInput[]
    OR?: rework_hxe110WhereInput[]
    NOT?: rework_hxe110WhereInput | rework_hxe110WhereInput[]
    meter_type?: StringFilter<"rework_hxe110"> | string
    tanggal?: DateTimeFilter<"rework_hxe110"> | Date | string
    modem?: StringFilter<"rework_hxe110"> | string
    baterai?: StringFilter<"rework_hxe110"> | string
    defect?: StringFilter<"rework_hxe110"> | string
  }, "id" | "meter_serial">

  export type rework_hxe110OrderByWithAggregationInput = {
    id?: SortOrder
    meter_type?: SortOrder
    meter_serial?: SortOrder
    tanggal?: SortOrder
    modem?: SortOrder
    baterai?: SortOrder
    defect?: SortOrder
    _count?: rework_hxe110CountOrderByAggregateInput
    _avg?: rework_hxe110AvgOrderByAggregateInput
    _max?: rework_hxe110MaxOrderByAggregateInput
    _min?: rework_hxe110MinOrderByAggregateInput
    _sum?: rework_hxe110SumOrderByAggregateInput
  }

  export type rework_hxe110ScalarWhereWithAggregatesInput = {
    AND?: rework_hxe110ScalarWhereWithAggregatesInput | rework_hxe110ScalarWhereWithAggregatesInput[]
    OR?: rework_hxe110ScalarWhereWithAggregatesInput[]
    NOT?: rework_hxe110ScalarWhereWithAggregatesInput | rework_hxe110ScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"rework_hxe110"> | number
    meter_type?: StringWithAggregatesFilter<"rework_hxe110"> | string
    meter_serial?: StringWithAggregatesFilter<"rework_hxe110"> | string
    tanggal?: DateTimeWithAggregatesFilter<"rework_hxe110"> | Date | string
    modem?: StringWithAggregatesFilter<"rework_hxe110"> | string
    baterai?: StringWithAggregatesFilter<"rework_hxe110"> | string
    defect?: StringWithAggregatesFilter<"rework_hxe110"> | string
  }

  export type rework_palleteWhereInput = {
    AND?: rework_palleteWhereInput | rework_palleteWhereInput[]
    OR?: rework_palleteWhereInput[]
    NOT?: rework_palleteWhereInput | rework_palleteWhereInput[]
    id?: IntFilter<"rework_pallete"> | number
    serial?: StringFilter<"rework_pallete"> | string
    timestamp?: DateTimeFilter<"rework_pallete"> | Date | string
    line?: StringFilter<"rework_pallete"> | string
    type?: StringFilter<"rework_pallete"> | string
    location?: StringNullableFilter<"rework_pallete"> | string | null
  }

  export type rework_palleteOrderByWithRelationInput = {
    id?: SortOrder
    serial?: SortOrder
    timestamp?: SortOrder
    line?: SortOrder
    type?: SortOrder
    location?: SortOrderInput | SortOrder
  }

  export type rework_palleteWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: rework_palleteWhereInput | rework_palleteWhereInput[]
    OR?: rework_palleteWhereInput[]
    NOT?: rework_palleteWhereInput | rework_palleteWhereInput[]
    serial?: StringFilter<"rework_pallete"> | string
    timestamp?: DateTimeFilter<"rework_pallete"> | Date | string
    line?: StringFilter<"rework_pallete"> | string
    type?: StringFilter<"rework_pallete"> | string
    location?: StringNullableFilter<"rework_pallete"> | string | null
  }, "id">

  export type rework_palleteOrderByWithAggregationInput = {
    id?: SortOrder
    serial?: SortOrder
    timestamp?: SortOrder
    line?: SortOrder
    type?: SortOrder
    location?: SortOrderInput | SortOrder
    _count?: rework_palleteCountOrderByAggregateInput
    _avg?: rework_palleteAvgOrderByAggregateInput
    _max?: rework_palleteMaxOrderByAggregateInput
    _min?: rework_palleteMinOrderByAggregateInput
    _sum?: rework_palleteSumOrderByAggregateInput
  }

  export type rework_palleteScalarWhereWithAggregatesInput = {
    AND?: rework_palleteScalarWhereWithAggregatesInput | rework_palleteScalarWhereWithAggregatesInput[]
    OR?: rework_palleteScalarWhereWithAggregatesInput[]
    NOT?: rework_palleteScalarWhereWithAggregatesInput | rework_palleteScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"rework_pallete"> | number
    serial?: StringWithAggregatesFilter<"rework_pallete"> | string
    timestamp?: DateTimeWithAggregatesFilter<"rework_pallete"> | Date | string
    line?: StringWithAggregatesFilter<"rework_pallete"> | string
    type?: StringWithAggregatesFilter<"rework_pallete"> | string
    location?: StringNullableWithAggregatesFilter<"rework_pallete"> | string | null
  }

  export type serial_checkWhereInput = {
    AND?: serial_checkWhereInput | serial_checkWhereInput[]
    OR?: serial_checkWhereInput[]
    NOT?: serial_checkWhereInput | serial_checkWhereInput[]
    id?: IntFilter<"serial_check"> | number
    serial?: StringFilter<"serial_check"> | string
    timestamp?: DateTimeFilter<"serial_check"> | Date | string
    line?: StringFilter<"serial_check"> | string
    type?: StringFilter<"serial_check"> | string
    orderno?: StringFilter<"serial_check"> | string
    area?: StringNullableFilter<"serial_check"> | string | null
    jenis?: StringNullableFilter<"serial_check"> | string | null
    box_id?: IntNullableFilter<"serial_check"> | number | null
    attachment_id?: IntNullableFilter<"serial_check"> | number | null
    attachment2_id?: IntNullableFilter<"serial_check"> | number | null
    remain?: StringFilter<"serial_check"> | string
    garansi?: StringNullableFilter<"serial_check"> | string | null
  }

  export type serial_checkOrderByWithRelationInput = {
    id?: SortOrder
    serial?: SortOrder
    timestamp?: SortOrder
    line?: SortOrder
    type?: SortOrder
    orderno?: SortOrder
    area?: SortOrderInput | SortOrder
    jenis?: SortOrderInput | SortOrder
    box_id?: SortOrderInput | SortOrder
    attachment_id?: SortOrderInput | SortOrder
    attachment2_id?: SortOrderInput | SortOrder
    remain?: SortOrder
    garansi?: SortOrderInput | SortOrder
  }

  export type serial_checkWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    serial?: string
    AND?: serial_checkWhereInput | serial_checkWhereInput[]
    OR?: serial_checkWhereInput[]
    NOT?: serial_checkWhereInput | serial_checkWhereInput[]
    timestamp?: DateTimeFilter<"serial_check"> | Date | string
    line?: StringFilter<"serial_check"> | string
    type?: StringFilter<"serial_check"> | string
    orderno?: StringFilter<"serial_check"> | string
    area?: StringNullableFilter<"serial_check"> | string | null
    jenis?: StringNullableFilter<"serial_check"> | string | null
    box_id?: IntNullableFilter<"serial_check"> | number | null
    attachment_id?: IntNullableFilter<"serial_check"> | number | null
    attachment2_id?: IntNullableFilter<"serial_check"> | number | null
    remain?: StringFilter<"serial_check"> | string
    garansi?: StringNullableFilter<"serial_check"> | string | null
  }, "id" | "serial">

  export type serial_checkOrderByWithAggregationInput = {
    id?: SortOrder
    serial?: SortOrder
    timestamp?: SortOrder
    line?: SortOrder
    type?: SortOrder
    orderno?: SortOrder
    area?: SortOrderInput | SortOrder
    jenis?: SortOrderInput | SortOrder
    box_id?: SortOrderInput | SortOrder
    attachment_id?: SortOrderInput | SortOrder
    attachment2_id?: SortOrderInput | SortOrder
    remain?: SortOrder
    garansi?: SortOrderInput | SortOrder
    _count?: serial_checkCountOrderByAggregateInput
    _avg?: serial_checkAvgOrderByAggregateInput
    _max?: serial_checkMaxOrderByAggregateInput
    _min?: serial_checkMinOrderByAggregateInput
    _sum?: serial_checkSumOrderByAggregateInput
  }

  export type serial_checkScalarWhereWithAggregatesInput = {
    AND?: serial_checkScalarWhereWithAggregatesInput | serial_checkScalarWhereWithAggregatesInput[]
    OR?: serial_checkScalarWhereWithAggregatesInput[]
    NOT?: serial_checkScalarWhereWithAggregatesInput | serial_checkScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"serial_check"> | number
    serial?: StringWithAggregatesFilter<"serial_check"> | string
    timestamp?: DateTimeWithAggregatesFilter<"serial_check"> | Date | string
    line?: StringWithAggregatesFilter<"serial_check"> | string
    type?: StringWithAggregatesFilter<"serial_check"> | string
    orderno?: StringWithAggregatesFilter<"serial_check"> | string
    area?: StringNullableWithAggregatesFilter<"serial_check"> | string | null
    jenis?: StringNullableWithAggregatesFilter<"serial_check"> | string | null
    box_id?: IntNullableWithAggregatesFilter<"serial_check"> | number | null
    attachment_id?: IntNullableWithAggregatesFilter<"serial_check"> | number | null
    attachment2_id?: IntNullableWithAggregatesFilter<"serial_check"> | number | null
    remain?: StringWithAggregatesFilter<"serial_check"> | string
    garansi?: StringNullableWithAggregatesFilter<"serial_check"> | string | null
  }

  export type tahun_garansiWhereInput = {
    AND?: tahun_garansiWhereInput | tahun_garansiWhereInput[]
    OR?: tahun_garansiWhereInput[]
    NOT?: tahun_garansiWhereInput | tahun_garansiWhereInput[]
    id_garansi?: IntFilter<"tahun_garansi"> | number
    value?: StringFilter<"tahun_garansi"> | string
  }

  export type tahun_garansiOrderByWithRelationInput = {
    id_garansi?: SortOrder
    value?: SortOrder
  }

  export type tahun_garansiWhereUniqueInput = Prisma.AtLeast<{
    id_garansi?: number
    AND?: tahun_garansiWhereInput | tahun_garansiWhereInput[]
    OR?: tahun_garansiWhereInput[]
    NOT?: tahun_garansiWhereInput | tahun_garansiWhereInput[]
    value?: StringFilter<"tahun_garansi"> | string
  }, "id_garansi">

  export type tahun_garansiOrderByWithAggregationInput = {
    id_garansi?: SortOrder
    value?: SortOrder
    _count?: tahun_garansiCountOrderByAggregateInput
    _avg?: tahun_garansiAvgOrderByAggregateInput
    _max?: tahun_garansiMaxOrderByAggregateInput
    _min?: tahun_garansiMinOrderByAggregateInput
    _sum?: tahun_garansiSumOrderByAggregateInput
  }

  export type tahun_garansiScalarWhereWithAggregatesInput = {
    AND?: tahun_garansiScalarWhereWithAggregatesInput | tahun_garansiScalarWhereWithAggregatesInput[]
    OR?: tahun_garansiScalarWhereWithAggregatesInput[]
    NOT?: tahun_garansiScalarWhereWithAggregatesInput | tahun_garansiScalarWhereWithAggregatesInput[]
    id_garansi?: IntWithAggregatesFilter<"tahun_garansi"> | number
    value?: StringWithAggregatesFilter<"tahun_garansi"> | string
  }

  export type temp_indicatorWhereInput = {
    AND?: temp_indicatorWhereInput | temp_indicatorWhereInput[]
    OR?: temp_indicatorWhereInput[]
    NOT?: temp_indicatorWhereInput | temp_indicatorWhereInput[]
    id?: IntFilter<"temp_indicator"> | number
    total?: IntFilter<"temp_indicator"> | number
    total_ng?: IntFilter<"temp_indicator"> | number
    total_ok?: IntFilter<"temp_indicator"> | number
    timestamp?: DateTimeFilter<"temp_indicator"> | Date | string
    status?: Enumtemp_indicator_statusFilter<"temp_indicator"> | $Enums.temp_indicator_status
  }

  export type temp_indicatorOrderByWithRelationInput = {
    id?: SortOrder
    total?: SortOrder
    total_ng?: SortOrder
    total_ok?: SortOrder
    timestamp?: SortOrder
    status?: SortOrder
  }

  export type temp_indicatorWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: temp_indicatorWhereInput | temp_indicatorWhereInput[]
    OR?: temp_indicatorWhereInput[]
    NOT?: temp_indicatorWhereInput | temp_indicatorWhereInput[]
    total?: IntFilter<"temp_indicator"> | number
    total_ng?: IntFilter<"temp_indicator"> | number
    total_ok?: IntFilter<"temp_indicator"> | number
    timestamp?: DateTimeFilter<"temp_indicator"> | Date | string
    status?: Enumtemp_indicator_statusFilter<"temp_indicator"> | $Enums.temp_indicator_status
  }, "id">

  export type temp_indicatorOrderByWithAggregationInput = {
    id?: SortOrder
    total?: SortOrder
    total_ng?: SortOrder
    total_ok?: SortOrder
    timestamp?: SortOrder
    status?: SortOrder
    _count?: temp_indicatorCountOrderByAggregateInput
    _avg?: temp_indicatorAvgOrderByAggregateInput
    _max?: temp_indicatorMaxOrderByAggregateInput
    _min?: temp_indicatorMinOrderByAggregateInput
    _sum?: temp_indicatorSumOrderByAggregateInput
  }

  export type temp_indicatorScalarWhereWithAggregatesInput = {
    AND?: temp_indicatorScalarWhereWithAggregatesInput | temp_indicatorScalarWhereWithAggregatesInput[]
    OR?: temp_indicatorScalarWhereWithAggregatesInput[]
    NOT?: temp_indicatorScalarWhereWithAggregatesInput | temp_indicatorScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"temp_indicator"> | number
    total?: IntWithAggregatesFilter<"temp_indicator"> | number
    total_ng?: IntWithAggregatesFilter<"temp_indicator"> | number
    total_ok?: IntWithAggregatesFilter<"temp_indicator"> | number
    timestamp?: DateTimeWithAggregatesFilter<"temp_indicator"> | Date | string
    status?: Enumtemp_indicator_statusWithAggregatesFilter<"temp_indicator"> | $Enums.temp_indicator_status
  }

  export type area_listCreateInput = {
    value: string
  }

  export type area_listUncheckedCreateInput = {
    id?: number
    value: string
  }

  export type area_listUpdateInput = {
    value?: StringFieldUpdateOperationsInput | string
  }

  export type area_listUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    value?: StringFieldUpdateOperationsInput | string
  }

  export type area_listCreateManyInput = {
    id?: number
    value: string
  }

  export type area_listUpdateManyMutationInput = {
    value?: StringFieldUpdateOperationsInput | string
  }

  export type area_listUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    value?: StringFieldUpdateOperationsInput | string
  }

  export type attachmentCreateInput = {
    nomor: string
    timestamp: Date | string
    type: string
    no_do: string
    no_order: string
    tgl_order: Date | string
    area: string
    status?: boolean
    active?: boolean
    qty?: number
    used_qty?: number
  }

  export type attachmentUncheckedCreateInput = {
    id?: number
    nomor: string
    timestamp: Date | string
    type: string
    no_do: string
    no_order: string
    tgl_order: Date | string
    area: string
    status?: boolean
    active?: boolean
    qty?: number
    used_qty?: number
  }

  export type attachmentUpdateInput = {
    nomor?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    no_do?: StringFieldUpdateOperationsInput | string
    no_order?: StringFieldUpdateOperationsInput | string
    tgl_order?: DateTimeFieldUpdateOperationsInput | Date | string
    area?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    qty?: IntFieldUpdateOperationsInput | number
    used_qty?: IntFieldUpdateOperationsInput | number
  }

  export type attachmentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nomor?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    no_do?: StringFieldUpdateOperationsInput | string
    no_order?: StringFieldUpdateOperationsInput | string
    tgl_order?: DateTimeFieldUpdateOperationsInput | Date | string
    area?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    qty?: IntFieldUpdateOperationsInput | number
    used_qty?: IntFieldUpdateOperationsInput | number
  }

  export type attachmentCreateManyInput = {
    id?: number
    nomor: string
    timestamp: Date | string
    type: string
    no_do: string
    no_order: string
    tgl_order: Date | string
    area: string
    status?: boolean
    active?: boolean
    qty?: number
    used_qty?: number
  }

  export type attachmentUpdateManyMutationInput = {
    nomor?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    no_do?: StringFieldUpdateOperationsInput | string
    no_order?: StringFieldUpdateOperationsInput | string
    tgl_order?: DateTimeFieldUpdateOperationsInput | Date | string
    area?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    qty?: IntFieldUpdateOperationsInput | number
    used_qty?: IntFieldUpdateOperationsInput | number
  }

  export type attachmentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nomor?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    no_do?: StringFieldUpdateOperationsInput | string
    no_order?: StringFieldUpdateOperationsInput | string
    tgl_order?: DateTimeFieldUpdateOperationsInput | Date | string
    area?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    qty?: IntFieldUpdateOperationsInput | number
    used_qty?: IntFieldUpdateOperationsInput | number
  }

  export type attachment2CreateInput = {
    nomor: string
    timestamp: Date | string
    type: string
    no_do: string
    no_order: string
    tgl_order: Date | string
    area: string
    status?: boolean
    active?: boolean
  }

  export type attachment2UncheckedCreateInput = {
    id?: number
    nomor: string
    timestamp: Date | string
    type: string
    no_do: string
    no_order: string
    tgl_order: Date | string
    area: string
    status?: boolean
    active?: boolean
  }

  export type attachment2UpdateInput = {
    nomor?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    no_do?: StringFieldUpdateOperationsInput | string
    no_order?: StringFieldUpdateOperationsInput | string
    tgl_order?: DateTimeFieldUpdateOperationsInput | Date | string
    area?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type attachment2UncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nomor?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    no_do?: StringFieldUpdateOperationsInput | string
    no_order?: StringFieldUpdateOperationsInput | string
    tgl_order?: DateTimeFieldUpdateOperationsInput | Date | string
    area?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type attachment2CreateManyInput = {
    id?: number
    nomor: string
    timestamp: Date | string
    type: string
    no_do: string
    no_order: string
    tgl_order: Date | string
    area: string
    status?: boolean
    active?: boolean
  }

  export type attachment2UpdateManyMutationInput = {
    nomor?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    no_do?: StringFieldUpdateOperationsInput | string
    no_order?: StringFieldUpdateOperationsInput | string
    tgl_order?: DateTimeFieldUpdateOperationsInput | Date | string
    area?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type attachment2UncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nomor?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    no_do?: StringFieldUpdateOperationsInput | string
    no_order?: StringFieldUpdateOperationsInput | string
    tgl_order?: DateTimeFieldUpdateOperationsInput | Date | string
    area?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type boxCreateInput = {
    serial: string
    timestamp?: Date | string
    line: string
    type: string
    pallete_id?: number | null
    attachment_id?: number | null
    attachment2_id?: number | null
    remain?: string
  }

  export type boxUncheckedCreateInput = {
    id?: number
    serial: string
    timestamp?: Date | string
    line: string
    type: string
    pallete_id?: number | null
    attachment_id?: number | null
    attachment2_id?: number | null
    remain?: string
  }

  export type boxUpdateInput = {
    serial?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    line?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    pallete_id?: NullableIntFieldUpdateOperationsInput | number | null
    attachment_id?: NullableIntFieldUpdateOperationsInput | number | null
    attachment2_id?: NullableIntFieldUpdateOperationsInput | number | null
    remain?: StringFieldUpdateOperationsInput | string
  }

  export type boxUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    serial?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    line?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    pallete_id?: NullableIntFieldUpdateOperationsInput | number | null
    attachment_id?: NullableIntFieldUpdateOperationsInput | number | null
    attachment2_id?: NullableIntFieldUpdateOperationsInput | number | null
    remain?: StringFieldUpdateOperationsInput | string
  }

  export type boxCreateManyInput = {
    id?: number
    serial: string
    timestamp?: Date | string
    line: string
    type: string
    pallete_id?: number | null
    attachment_id?: number | null
    attachment2_id?: number | null
    remain?: string
  }

  export type boxUpdateManyMutationInput = {
    serial?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    line?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    pallete_id?: NullableIntFieldUpdateOperationsInput | number | null
    attachment_id?: NullableIntFieldUpdateOperationsInput | number | null
    attachment2_id?: NullableIntFieldUpdateOperationsInput | number | null
    remain?: StringFieldUpdateOperationsInput | string
  }

  export type boxUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    serial?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    line?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    pallete_id?: NullableIntFieldUpdateOperationsInput | number | null
    attachment_id?: NullableIntFieldUpdateOperationsInput | number | null
    attachment2_id?: NullableIntFieldUpdateOperationsInput | number | null
    remain?: StringFieldUpdateOperationsInput | string
  }

  export type configCreateInput = {
    root: string
    branch: string
    value: string
    tanggal: Date | string
  }

  export type configUncheckedCreateInput = {
    root: string
    branch: string
    value: string
    tanggal: Date | string
  }

  export type configUpdateInput = {
    root?: StringFieldUpdateOperationsInput | string
    branch?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type configUncheckedUpdateInput = {
    root?: StringFieldUpdateOperationsInput | string
    branch?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type configCreateManyInput = {
    root: string
    branch: string
    value: string
    tanggal: Date | string
  }

  export type configUpdateManyMutationInput = {
    root?: StringFieldUpdateOperationsInput | string
    branch?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type configUncheckedUpdateManyInput = {
    root?: StringFieldUpdateOperationsInput | string
    branch?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type defect_listCreateInput = {
    defect_name: string
  }

  export type defect_listUncheckedCreateInput = {
    id?: number
    defect_name: string
  }

  export type defect_listUpdateInput = {
    defect_name?: StringFieldUpdateOperationsInput | string
  }

  export type defect_listUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    defect_name?: StringFieldUpdateOperationsInput | string
  }

  export type defect_listCreateManyInput = {
    id?: number
    defect_name: string
  }

  export type defect_listUpdateManyMutationInput = {
    defect_name?: StringFieldUpdateOperationsInput | string
  }

  export type defect_listUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    defect_name?: StringFieldUpdateOperationsInput | string
  }

  export type fct_notpassCreateInput = {
    serial: string
    type: string
    line: string
    timestamp?: Date | string
  }

  export type fct_notpassUncheckedCreateInput = {
    id?: number
    serial: string
    type: string
    line: string
    timestamp?: Date | string
  }

  export type fct_notpassUpdateInput = {
    serial?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    line?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type fct_notpassUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    serial?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    line?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type fct_notpassCreateManyInput = {
    id?: number
    serial: string
    type: string
    line: string
    timestamp?: Date | string
  }

  export type fct_notpassUpdateManyMutationInput = {
    serial?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    line?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type fct_notpassUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    serial?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    line?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type fct_passCreateInput = {
    serial: string
    type: string
    line: string
    timestamp?: Date | string
  }

  export type fct_passUncheckedCreateInput = {
    id?: number
    serial: string
    type: string
    line: string
    timestamp?: Date | string
  }

  export type fct_passUpdateInput = {
    serial?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    line?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type fct_passUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    serial?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    line?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type fct_passCreateManyInput = {
    id?: number
    serial: string
    type: string
    line: string
    timestamp?: Date | string
  }

  export type fct_passUpdateManyMutationInput = {
    serial?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    line?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type fct_passUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    serial?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    line?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type fct_tempCreateInput = {
    type: string
    line: string
    timestamp?: Date | string
    total_output: number
    total_defect: number
    target: number
  }

  export type fct_tempUncheckedCreateInput = {
    id?: number
    type: string
    line: string
    timestamp?: Date | string
    total_output: number
    total_defect: number
    target: number
  }

  export type fct_tempUpdateInput = {
    type?: StringFieldUpdateOperationsInput | string
    line?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    total_output?: IntFieldUpdateOperationsInput | number
    total_defect?: IntFieldUpdateOperationsInput | number
    target?: IntFieldUpdateOperationsInput | number
  }

  export type fct_tempUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    line?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    total_output?: IntFieldUpdateOperationsInput | number
    total_defect?: IntFieldUpdateOperationsInput | number
    target?: IntFieldUpdateOperationsInput | number
  }

  export type fct_tempCreateManyInput = {
    id?: number
    type: string
    line: string
    timestamp?: Date | string
    total_output: number
    total_defect: number
    target: number
  }

  export type fct_tempUpdateManyMutationInput = {
    type?: StringFieldUpdateOperationsInput | string
    line?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    total_output?: IntFieldUpdateOperationsInput | number
    total_defect?: IntFieldUpdateOperationsInput | number
    target?: IntFieldUpdateOperationsInput | number
  }

  export type fct_tempUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    line?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    total_output?: IntFieldUpdateOperationsInput | number
    total_defect?: IntFieldUpdateOperationsInput | number
    target?: IntFieldUpdateOperationsInput | number
  }

  export type filestore_fileCreateInput = {
    filestore_type_id?: number
    filestore_volume_id?: number
    filename?: string
    original_filename?: string | null
    filesize?: number
    filenum?: number
    deleted?: $Enums.filestore_file_deleted
  }

  export type filestore_fileUncheckedCreateInput = {
    id?: number
    filestore_type_id?: number
    filestore_volume_id?: number
    filename?: string
    original_filename?: string | null
    filesize?: number
    filenum?: number
    deleted?: $Enums.filestore_file_deleted
  }

  export type filestore_fileUpdateInput = {
    filestore_type_id?: IntFieldUpdateOperationsInput | number
    filestore_volume_id?: IntFieldUpdateOperationsInput | number
    filename?: StringFieldUpdateOperationsInput | string
    original_filename?: NullableStringFieldUpdateOperationsInput | string | null
    filesize?: IntFieldUpdateOperationsInput | number
    filenum?: IntFieldUpdateOperationsInput | number
    deleted?: Enumfilestore_file_deletedFieldUpdateOperationsInput | $Enums.filestore_file_deleted
  }

  export type filestore_fileUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    filestore_type_id?: IntFieldUpdateOperationsInput | number
    filestore_volume_id?: IntFieldUpdateOperationsInput | number
    filename?: StringFieldUpdateOperationsInput | string
    original_filename?: NullableStringFieldUpdateOperationsInput | string | null
    filesize?: IntFieldUpdateOperationsInput | number
    filenum?: IntFieldUpdateOperationsInput | number
    deleted?: Enumfilestore_file_deletedFieldUpdateOperationsInput | $Enums.filestore_file_deleted
  }

  export type filestore_fileCreateManyInput = {
    id?: number
    filestore_type_id?: number
    filestore_volume_id?: number
    filename?: string
    original_filename?: string | null
    filesize?: number
    filenum?: number
    deleted?: $Enums.filestore_file_deleted
  }

  export type filestore_fileUpdateManyMutationInput = {
    filestore_type_id?: IntFieldUpdateOperationsInput | number
    filestore_volume_id?: IntFieldUpdateOperationsInput | number
    filename?: StringFieldUpdateOperationsInput | string
    original_filename?: NullableStringFieldUpdateOperationsInput | string | null
    filesize?: IntFieldUpdateOperationsInput | number
    filenum?: IntFieldUpdateOperationsInput | number
    deleted?: Enumfilestore_file_deletedFieldUpdateOperationsInput | $Enums.filestore_file_deleted
  }

  export type filestore_fileUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    filestore_type_id?: IntFieldUpdateOperationsInput | number
    filestore_volume_id?: IntFieldUpdateOperationsInput | number
    filename?: StringFieldUpdateOperationsInput | string
    original_filename?: NullableStringFieldUpdateOperationsInput | string | null
    filesize?: IntFieldUpdateOperationsInput | number
    filenum?: IntFieldUpdateOperationsInput | number
    deleted?: Enumfilestore_file_deletedFieldUpdateOperationsInput | $Enums.filestore_file_deleted
  }

  export type filestore_typeCreateInput = {
    name?: string | null
    mime_type?: string
    extension?: string | null
  }

  export type filestore_typeUncheckedCreateInput = {
    id?: number
    name?: string | null
    mime_type?: string
    extension?: string | null
  }

  export type filestore_typeUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    mime_type?: StringFieldUpdateOperationsInput | string
    extension?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type filestore_typeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    mime_type?: StringFieldUpdateOperationsInput | string
    extension?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type filestore_typeCreateManyInput = {
    id?: number
    name?: string | null
    mime_type?: string
    extension?: string | null
  }

  export type filestore_typeUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    mime_type?: StringFieldUpdateOperationsInput | string
    extension?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type filestore_typeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    mime_type?: StringFieldUpdateOperationsInput | string
    extension?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type filestore_volumeCreateInput = {
    name?: string
    dirname?: string
    total_space?: bigint | number
    used_space?: bigint | number
    stored_files_cnt?: number
    enabled?: $Enums.filestore_volume_enabled | null
    last_filenum?: number | null
  }

  export type filestore_volumeUncheckedCreateInput = {
    id?: number
    name?: string
    dirname?: string
    total_space?: bigint | number
    used_space?: bigint | number
    stored_files_cnt?: number
    enabled?: $Enums.filestore_volume_enabled | null
    last_filenum?: number | null
  }

  export type filestore_volumeUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    dirname?: StringFieldUpdateOperationsInput | string
    total_space?: BigIntFieldUpdateOperationsInput | bigint | number
    used_space?: BigIntFieldUpdateOperationsInput | bigint | number
    stored_files_cnt?: IntFieldUpdateOperationsInput | number
    enabled?: NullableEnumfilestore_volume_enabledFieldUpdateOperationsInput | $Enums.filestore_volume_enabled | null
    last_filenum?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type filestore_volumeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    dirname?: StringFieldUpdateOperationsInput | string
    total_space?: BigIntFieldUpdateOperationsInput | bigint | number
    used_space?: BigIntFieldUpdateOperationsInput | bigint | number
    stored_files_cnt?: IntFieldUpdateOperationsInput | number
    enabled?: NullableEnumfilestore_volume_enabledFieldUpdateOperationsInput | $Enums.filestore_volume_enabled | null
    last_filenum?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type filestore_volumeCreateManyInput = {
    id?: number
    name?: string
    dirname?: string
    total_space?: bigint | number
    used_space?: bigint | number
    stored_files_cnt?: number
    enabled?: $Enums.filestore_volume_enabled | null
    last_filenum?: number | null
  }

  export type filestore_volumeUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    dirname?: StringFieldUpdateOperationsInput | string
    total_space?: BigIntFieldUpdateOperationsInput | bigint | number
    used_space?: BigIntFieldUpdateOperationsInput | bigint | number
    stored_files_cnt?: IntFieldUpdateOperationsInput | number
    enabled?: NullableEnumfilestore_volume_enabledFieldUpdateOperationsInput | $Enums.filestore_volume_enabled | null
    last_filenum?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type filestore_volumeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    dirname?: StringFieldUpdateOperationsInput | string
    total_space?: BigIntFieldUpdateOperationsInput | bigint | number
    used_space?: BigIntFieldUpdateOperationsInput | bigint | number
    stored_files_cnt?: IntFieldUpdateOperationsInput | number
    enabled?: NullableEnumfilestore_volume_enabledFieldUpdateOperationsInput | $Enums.filestore_volume_enabled | null
    last_filenum?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type audit_logsCreateInput = {
    timestamp?: Date | string
    action: string
    entity: string
    entity_id: string
    details?: string | null
    user?: string | null
    ip_address?: string | null
  }

  export type audit_logsUncheckedCreateInput = {
    id?: number
    timestamp?: Date | string
    action: string
    entity: string
    entity_id: string
    details?: string | null
    user?: string | null
    ip_address?: string | null
  }

  export type audit_logsUpdateInput = {
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entity_id?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    user?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type audit_logsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entity_id?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    user?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type audit_logsCreateManyInput = {
    id?: number
    timestamp?: Date | string
    action: string
    entity: string
    entity_id: string
    details?: string | null
    user?: string | null
    ip_address?: string | null
  }

  export type audit_logsUpdateManyMutationInput = {
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entity_id?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    user?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type audit_logsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entity_id?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    user?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type logs_editCreateInput = {
    timestamp?: Date | string
    desc: string
    code: string
    line: string
    user: string
  }

  export type logs_editUncheckedCreateInput = {
    id?: number
    timestamp?: Date | string
    desc: string
    code: string
    line: string
    user: string
  }

  export type logs_editUpdateInput = {
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    desc?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    line?: StringFieldUpdateOperationsInput | string
    user?: StringFieldUpdateOperationsInput | string
  }

  export type logs_editUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    desc?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    line?: StringFieldUpdateOperationsInput | string
    user?: StringFieldUpdateOperationsInput | string
  }

  export type logs_editCreateManyInput = {
    id?: number
    timestamp?: Date | string
    desc: string
    code: string
    line: string
    user: string
  }

  export type logs_editUpdateManyMutationInput = {
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    desc?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    line?: StringFieldUpdateOperationsInput | string
    user?: StringFieldUpdateOperationsInput | string
  }

  export type logs_editUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    desc?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    line?: StringFieldUpdateOperationsInput | string
    user?: StringFieldUpdateOperationsInput | string
  }

  export type meter_typeCreateInput = {
    value: string
    phase: string
    validation: string
    validation_length?: number
    length: number
    pln_code: string
    card_validation: $Enums.meter_type_card_validation
    validation_type?: $Enums.meter_type_validation_type | null
    daily_reset: $Enums.meter_type_daily_reset
    numeric_only: $Enums.meter_type_numeric_only
    surpass_target: $Enums.meter_type_surpass_target
    run_by_sequence?: $Enums.meter_type_run_by_sequence
    start_reset?: string
    end_reset?: string
  }

  export type meter_typeUncheckedCreateInput = {
    id?: number
    value: string
    phase: string
    validation: string
    validation_length?: number
    length: number
    pln_code: string
    card_validation: $Enums.meter_type_card_validation
    validation_type?: $Enums.meter_type_validation_type | null
    daily_reset: $Enums.meter_type_daily_reset
    numeric_only: $Enums.meter_type_numeric_only
    surpass_target: $Enums.meter_type_surpass_target
    run_by_sequence?: $Enums.meter_type_run_by_sequence
    start_reset?: string
    end_reset?: string
  }

  export type meter_typeUpdateInput = {
    value?: StringFieldUpdateOperationsInput | string
    phase?: StringFieldUpdateOperationsInput | string
    validation?: StringFieldUpdateOperationsInput | string
    validation_length?: IntFieldUpdateOperationsInput | number
    length?: IntFieldUpdateOperationsInput | number
    pln_code?: StringFieldUpdateOperationsInput | string
    card_validation?: Enummeter_type_card_validationFieldUpdateOperationsInput | $Enums.meter_type_card_validation
    validation_type?: NullableEnummeter_type_validation_typeFieldUpdateOperationsInput | $Enums.meter_type_validation_type | null
    daily_reset?: Enummeter_type_daily_resetFieldUpdateOperationsInput | $Enums.meter_type_daily_reset
    numeric_only?: Enummeter_type_numeric_onlyFieldUpdateOperationsInput | $Enums.meter_type_numeric_only
    surpass_target?: Enummeter_type_surpass_targetFieldUpdateOperationsInput | $Enums.meter_type_surpass_target
    run_by_sequence?: Enummeter_type_run_by_sequenceFieldUpdateOperationsInput | $Enums.meter_type_run_by_sequence
    start_reset?: StringFieldUpdateOperationsInput | string
    end_reset?: StringFieldUpdateOperationsInput | string
  }

  export type meter_typeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    value?: StringFieldUpdateOperationsInput | string
    phase?: StringFieldUpdateOperationsInput | string
    validation?: StringFieldUpdateOperationsInput | string
    validation_length?: IntFieldUpdateOperationsInput | number
    length?: IntFieldUpdateOperationsInput | number
    pln_code?: StringFieldUpdateOperationsInput | string
    card_validation?: Enummeter_type_card_validationFieldUpdateOperationsInput | $Enums.meter_type_card_validation
    validation_type?: NullableEnummeter_type_validation_typeFieldUpdateOperationsInput | $Enums.meter_type_validation_type | null
    daily_reset?: Enummeter_type_daily_resetFieldUpdateOperationsInput | $Enums.meter_type_daily_reset
    numeric_only?: Enummeter_type_numeric_onlyFieldUpdateOperationsInput | $Enums.meter_type_numeric_only
    surpass_target?: Enummeter_type_surpass_targetFieldUpdateOperationsInput | $Enums.meter_type_surpass_target
    run_by_sequence?: Enummeter_type_run_by_sequenceFieldUpdateOperationsInput | $Enums.meter_type_run_by_sequence
    start_reset?: StringFieldUpdateOperationsInput | string
    end_reset?: StringFieldUpdateOperationsInput | string
  }

  export type meter_typeCreateManyInput = {
    id?: number
    value: string
    phase: string
    validation: string
    validation_length?: number
    length: number
    pln_code: string
    card_validation: $Enums.meter_type_card_validation
    validation_type?: $Enums.meter_type_validation_type | null
    daily_reset: $Enums.meter_type_daily_reset
    numeric_only: $Enums.meter_type_numeric_only
    surpass_target: $Enums.meter_type_surpass_target
    run_by_sequence?: $Enums.meter_type_run_by_sequence
    start_reset?: string
    end_reset?: string
  }

  export type meter_typeUpdateManyMutationInput = {
    value?: StringFieldUpdateOperationsInput | string
    phase?: StringFieldUpdateOperationsInput | string
    validation?: StringFieldUpdateOperationsInput | string
    validation_length?: IntFieldUpdateOperationsInput | number
    length?: IntFieldUpdateOperationsInput | number
    pln_code?: StringFieldUpdateOperationsInput | string
    card_validation?: Enummeter_type_card_validationFieldUpdateOperationsInput | $Enums.meter_type_card_validation
    validation_type?: NullableEnummeter_type_validation_typeFieldUpdateOperationsInput | $Enums.meter_type_validation_type | null
    daily_reset?: Enummeter_type_daily_resetFieldUpdateOperationsInput | $Enums.meter_type_daily_reset
    numeric_only?: Enummeter_type_numeric_onlyFieldUpdateOperationsInput | $Enums.meter_type_numeric_only
    surpass_target?: Enummeter_type_surpass_targetFieldUpdateOperationsInput | $Enums.meter_type_surpass_target
    run_by_sequence?: Enummeter_type_run_by_sequenceFieldUpdateOperationsInput | $Enums.meter_type_run_by_sequence
    start_reset?: StringFieldUpdateOperationsInput | string
    end_reset?: StringFieldUpdateOperationsInput | string
  }

  export type meter_typeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    value?: StringFieldUpdateOperationsInput | string
    phase?: StringFieldUpdateOperationsInput | string
    validation?: StringFieldUpdateOperationsInput | string
    validation_length?: IntFieldUpdateOperationsInput | number
    length?: IntFieldUpdateOperationsInput | number
    pln_code?: StringFieldUpdateOperationsInput | string
    card_validation?: Enummeter_type_card_validationFieldUpdateOperationsInput | $Enums.meter_type_card_validation
    validation_type?: NullableEnummeter_type_validation_typeFieldUpdateOperationsInput | $Enums.meter_type_validation_type | null
    daily_reset?: Enummeter_type_daily_resetFieldUpdateOperationsInput | $Enums.meter_type_daily_reset
    numeric_only?: Enummeter_type_numeric_onlyFieldUpdateOperationsInput | $Enums.meter_type_numeric_only
    surpass_target?: Enummeter_type_surpass_targetFieldUpdateOperationsInput | $Enums.meter_type_surpass_target
    run_by_sequence?: Enummeter_type_run_by_sequenceFieldUpdateOperationsInput | $Enums.meter_type_run_by_sequence
    start_reset?: StringFieldUpdateOperationsInput | string
    end_reset?: StringFieldUpdateOperationsInput | string
  }

  export type module_listCreateInput = {
    module_id: number
    module_serial: string
  }

  export type module_listUncheckedCreateInput = {
    module_id: number
    module_serial: string
  }

  export type module_listUpdateInput = {
    module_id?: IntFieldUpdateOperationsInput | number
    module_serial?: StringFieldUpdateOperationsInput | string
  }

  export type module_listUncheckedUpdateInput = {
    module_id?: IntFieldUpdateOperationsInput | number
    module_serial?: StringFieldUpdateOperationsInput | string
  }

  export type module_listCreateManyInput = {
    module_id: number
    module_serial: string
  }

  export type module_listUpdateManyMutationInput = {
    module_id?: IntFieldUpdateOperationsInput | number
    module_serial?: StringFieldUpdateOperationsInput | string
  }

  export type module_listUncheckedUpdateManyInput = {
    module_id?: IntFieldUpdateOperationsInput | number
    module_serial?: StringFieldUpdateOperationsInput | string
  }

  export type order_numCreateInput = {
    value: string
    counter?: number
  }

  export type order_numUncheckedCreateInput = {
    id?: number
    value: string
    counter?: number
  }

  export type order_numUpdateInput = {
    value?: StringFieldUpdateOperationsInput | string
    counter?: IntFieldUpdateOperationsInput | number
  }

  export type order_numUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    value?: StringFieldUpdateOperationsInput | string
    counter?: IntFieldUpdateOperationsInput | number
  }

  export type order_numCreateManyInput = {
    id?: number
    value: string
    counter?: number
  }

  export type order_numUpdateManyMutationInput = {
    value?: StringFieldUpdateOperationsInput | string
    counter?: IntFieldUpdateOperationsInput | number
  }

  export type order_numUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    value?: StringFieldUpdateOperationsInput | string
    counter?: IntFieldUpdateOperationsInput | number
  }

  export type out_110CreateInput = {
    serial: string
    qr_serial: string
    timestamp?: Date | string
    receive_id: number
  }

  export type out_110UncheckedCreateInput = {
    id?: number
    serial: string
    qr_serial: string
    timestamp?: Date | string
    receive_id: number
  }

  export type out_110UpdateInput = {
    serial?: StringFieldUpdateOperationsInput | string
    qr_serial?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    receive_id?: IntFieldUpdateOperationsInput | number
  }

  export type out_110UncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    serial?: StringFieldUpdateOperationsInput | string
    qr_serial?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    receive_id?: IntFieldUpdateOperationsInput | number
  }

  export type out_110CreateManyInput = {
    id?: number
    serial: string
    qr_serial: string
    timestamp?: Date | string
    receive_id: number
  }

  export type out_110UpdateManyMutationInput = {
    serial?: StringFieldUpdateOperationsInput | string
    qr_serial?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    receive_id?: IntFieldUpdateOperationsInput | number
  }

  export type out_110UncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    serial?: StringFieldUpdateOperationsInput | string
    qr_serial?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    receive_id?: IntFieldUpdateOperationsInput | number
  }

  export type output_targetCreateInput = {
    output: string
    type: string
    waktu: string
    line: string
    timestamp?: Date | string
  }

  export type output_targetUncheckedCreateInput = {
    id?: number
    output: string
    type: string
    waktu: string
    line: string
    timestamp?: Date | string
  }

  export type output_targetUpdateInput = {
    output?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    waktu?: StringFieldUpdateOperationsInput | string
    line?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type output_targetUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    output?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    waktu?: StringFieldUpdateOperationsInput | string
    line?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type output_targetCreateManyInput = {
    id?: number
    output: string
    type: string
    waktu: string
    line: string
    timestamp?: Date | string
  }

  export type output_targetUpdateManyMutationInput = {
    output?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    waktu?: StringFieldUpdateOperationsInput | string
    line?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type output_targetUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    output?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    waktu?: StringFieldUpdateOperationsInput | string
    line?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type output_tempCreateInput = {
    type?: string | null
    total_output: number
    line: string
    tahun?: string | null
    timestamp?: Date | string
    total_bigbox?: number
    total_pallet?: number
    target?: number
    target_hour: number
    hour1: number
    hour2: number
    hour3: number
    hour4: number
    hour5: number
    hour6: number
    hour7: number
    hour8: number
    hour9: number
    hour10: number
    hour11: number
    hour12: number
  }

  export type output_tempUncheckedCreateInput = {
    id?: number
    type?: string | null
    total_output: number
    line: string
    tahun?: string | null
    timestamp?: Date | string
    total_bigbox?: number
    total_pallet?: number
    target?: number
    target_hour: number
    hour1: number
    hour2: number
    hour3: number
    hour4: number
    hour5: number
    hour6: number
    hour7: number
    hour8: number
    hour9: number
    hour10: number
    hour11: number
    hour12: number
  }

  export type output_tempUpdateInput = {
    type?: NullableStringFieldUpdateOperationsInput | string | null
    total_output?: IntFieldUpdateOperationsInput | number
    line?: StringFieldUpdateOperationsInput | string
    tahun?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    total_bigbox?: IntFieldUpdateOperationsInput | number
    total_pallet?: IntFieldUpdateOperationsInput | number
    target?: IntFieldUpdateOperationsInput | number
    target_hour?: IntFieldUpdateOperationsInput | number
    hour1?: IntFieldUpdateOperationsInput | number
    hour2?: IntFieldUpdateOperationsInput | number
    hour3?: IntFieldUpdateOperationsInput | number
    hour4?: IntFieldUpdateOperationsInput | number
    hour5?: IntFieldUpdateOperationsInput | number
    hour6?: IntFieldUpdateOperationsInput | number
    hour7?: IntFieldUpdateOperationsInput | number
    hour8?: IntFieldUpdateOperationsInput | number
    hour9?: IntFieldUpdateOperationsInput | number
    hour10?: IntFieldUpdateOperationsInput | number
    hour11?: IntFieldUpdateOperationsInput | number
    hour12?: IntFieldUpdateOperationsInput | number
  }

  export type output_tempUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
    total_output?: IntFieldUpdateOperationsInput | number
    line?: StringFieldUpdateOperationsInput | string
    tahun?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    total_bigbox?: IntFieldUpdateOperationsInput | number
    total_pallet?: IntFieldUpdateOperationsInput | number
    target?: IntFieldUpdateOperationsInput | number
    target_hour?: IntFieldUpdateOperationsInput | number
    hour1?: IntFieldUpdateOperationsInput | number
    hour2?: IntFieldUpdateOperationsInput | number
    hour3?: IntFieldUpdateOperationsInput | number
    hour4?: IntFieldUpdateOperationsInput | number
    hour5?: IntFieldUpdateOperationsInput | number
    hour6?: IntFieldUpdateOperationsInput | number
    hour7?: IntFieldUpdateOperationsInput | number
    hour8?: IntFieldUpdateOperationsInput | number
    hour9?: IntFieldUpdateOperationsInput | number
    hour10?: IntFieldUpdateOperationsInput | number
    hour11?: IntFieldUpdateOperationsInput | number
    hour12?: IntFieldUpdateOperationsInput | number
  }

  export type output_tempCreateManyInput = {
    id?: number
    type?: string | null
    total_output: number
    line: string
    tahun?: string | null
    timestamp?: Date | string
    total_bigbox?: number
    total_pallet?: number
    target?: number
    target_hour: number
    hour1: number
    hour2: number
    hour3: number
    hour4: number
    hour5: number
    hour6: number
    hour7: number
    hour8: number
    hour9: number
    hour10: number
    hour11: number
    hour12: number
  }

  export type output_tempUpdateManyMutationInput = {
    type?: NullableStringFieldUpdateOperationsInput | string | null
    total_output?: IntFieldUpdateOperationsInput | number
    line?: StringFieldUpdateOperationsInput | string
    tahun?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    total_bigbox?: IntFieldUpdateOperationsInput | number
    total_pallet?: IntFieldUpdateOperationsInput | number
    target?: IntFieldUpdateOperationsInput | number
    target_hour?: IntFieldUpdateOperationsInput | number
    hour1?: IntFieldUpdateOperationsInput | number
    hour2?: IntFieldUpdateOperationsInput | number
    hour3?: IntFieldUpdateOperationsInput | number
    hour4?: IntFieldUpdateOperationsInput | number
    hour5?: IntFieldUpdateOperationsInput | number
    hour6?: IntFieldUpdateOperationsInput | number
    hour7?: IntFieldUpdateOperationsInput | number
    hour8?: IntFieldUpdateOperationsInput | number
    hour9?: IntFieldUpdateOperationsInput | number
    hour10?: IntFieldUpdateOperationsInput | number
    hour11?: IntFieldUpdateOperationsInput | number
    hour12?: IntFieldUpdateOperationsInput | number
  }

  export type output_tempUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
    total_output?: IntFieldUpdateOperationsInput | number
    line?: StringFieldUpdateOperationsInput | string
    tahun?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    total_bigbox?: IntFieldUpdateOperationsInput | number
    total_pallet?: IntFieldUpdateOperationsInput | number
    target?: IntFieldUpdateOperationsInput | number
    target_hour?: IntFieldUpdateOperationsInput | number
    hour1?: IntFieldUpdateOperationsInput | number
    hour2?: IntFieldUpdateOperationsInput | number
    hour3?: IntFieldUpdateOperationsInput | number
    hour4?: IntFieldUpdateOperationsInput | number
    hour5?: IntFieldUpdateOperationsInput | number
    hour6?: IntFieldUpdateOperationsInput | number
    hour7?: IntFieldUpdateOperationsInput | number
    hour8?: IntFieldUpdateOperationsInput | number
    hour9?: IntFieldUpdateOperationsInput | number
    hour10?: IntFieldUpdateOperationsInput | number
    hour11?: IntFieldUpdateOperationsInput | number
    hour12?: IntFieldUpdateOperationsInput | number
  }

  export type palleteCreateInput = {
    serial: string
    timestamp?: Date | string
    line: string
    type: string
    location: string
  }

  export type palleteUncheckedCreateInput = {
    id?: number
    serial: string
    timestamp?: Date | string
    line: string
    type: string
    location: string
  }

  export type palleteUpdateInput = {
    serial?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    line?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
  }

  export type palleteUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    serial?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    line?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
  }

  export type palleteCreateManyInput = {
    id?: number
    serial: string
    timestamp?: Date | string
    line: string
    type: string
    location: string
  }

  export type palleteUpdateManyMutationInput = {
    serial?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    line?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
  }

  export type palleteUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    serial?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    line?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
  }

  export type pln_codeCreateInput = {
    value: string
  }

  export type pln_codeUncheckedCreateInput = {
    id?: number
    value: string
  }

  export type pln_codeUpdateInput = {
    value?: StringFieldUpdateOperationsInput | string
  }

  export type pln_codeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    value?: StringFieldUpdateOperationsInput | string
  }

  export type pln_codeCreateManyInput = {
    id?: number
    value: string
  }

  export type pln_codeUpdateManyMutationInput = {
    value?: StringFieldUpdateOperationsInput | string
  }

  export type pln_codeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    value?: StringFieldUpdateOperationsInput | string
  }

  export type productCreateInput = {
    serial: string
    module_serial?: string | null
    timestamp?: Date | string
    line: string
    type: string
    orderno: string
    area?: string | null
    jenis?: string | null
    box_id?: number | null
    attachment_id?: number | null
    attachment2_id?: number | null
    remain?: string
    garansi?: string | null
  }

  export type productUncheckedCreateInput = {
    id?: number
    serial: string
    module_serial?: string | null
    timestamp?: Date | string
    line: string
    type: string
    orderno: string
    area?: string | null
    jenis?: string | null
    box_id?: number | null
    attachment_id?: number | null
    attachment2_id?: number | null
    remain?: string
    garansi?: string | null
  }

  export type productUpdateInput = {
    serial?: StringFieldUpdateOperationsInput | string
    module_serial?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    line?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    orderno?: StringFieldUpdateOperationsInput | string
    area?: NullableStringFieldUpdateOperationsInput | string | null
    jenis?: NullableStringFieldUpdateOperationsInput | string | null
    box_id?: NullableIntFieldUpdateOperationsInput | number | null
    attachment_id?: NullableIntFieldUpdateOperationsInput | number | null
    attachment2_id?: NullableIntFieldUpdateOperationsInput | number | null
    remain?: StringFieldUpdateOperationsInput | string
    garansi?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type productUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    serial?: StringFieldUpdateOperationsInput | string
    module_serial?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    line?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    orderno?: StringFieldUpdateOperationsInput | string
    area?: NullableStringFieldUpdateOperationsInput | string | null
    jenis?: NullableStringFieldUpdateOperationsInput | string | null
    box_id?: NullableIntFieldUpdateOperationsInput | number | null
    attachment_id?: NullableIntFieldUpdateOperationsInput | number | null
    attachment2_id?: NullableIntFieldUpdateOperationsInput | number | null
    remain?: StringFieldUpdateOperationsInput | string
    garansi?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type productCreateManyInput = {
    id?: number
    serial: string
    module_serial?: string | null
    timestamp?: Date | string
    line: string
    type: string
    orderno: string
    area?: string | null
    jenis?: string | null
    box_id?: number | null
    attachment_id?: number | null
    attachment2_id?: number | null
    remain?: string
    garansi?: string | null
  }

  export type productUpdateManyMutationInput = {
    serial?: StringFieldUpdateOperationsInput | string
    module_serial?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    line?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    orderno?: StringFieldUpdateOperationsInput | string
    area?: NullableStringFieldUpdateOperationsInput | string | null
    jenis?: NullableStringFieldUpdateOperationsInput | string | null
    box_id?: NullableIntFieldUpdateOperationsInput | number | null
    attachment_id?: NullableIntFieldUpdateOperationsInput | number | null
    attachment2_id?: NullableIntFieldUpdateOperationsInput | number | null
    remain?: StringFieldUpdateOperationsInput | string
    garansi?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type productUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    serial?: StringFieldUpdateOperationsInput | string
    module_serial?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    line?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    orderno?: StringFieldUpdateOperationsInput | string
    area?: NullableStringFieldUpdateOperationsInput | string | null
    jenis?: NullableStringFieldUpdateOperationsInput | string | null
    box_id?: NullableIntFieldUpdateOperationsInput | number | null
    attachment_id?: NullableIntFieldUpdateOperationsInput | number | null
    attachment2_id?: NullableIntFieldUpdateOperationsInput | number | null
    remain?: StringFieldUpdateOperationsInput | string
    garansi?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type production_ngCreateInput = {
    meter_type: string
    serial: string
    tanggal?: Date | string
    station: string
    line: string
    defect: string
    category?: string | null
    department?: string | null
    action?: string | null
    keterangan?: string | null
    update_date?: Date | string | null
    user?: string | null
  }

  export type production_ngUncheckedCreateInput = {
    id?: number
    meter_type: string
    serial: string
    tanggal?: Date | string
    station: string
    line: string
    defect: string
    category?: string | null
    department?: string | null
    action?: string | null
    keterangan?: string | null
    update_date?: Date | string | null
    user?: string | null
  }

  export type production_ngUpdateInput = {
    meter_type?: StringFieldUpdateOperationsInput | string
    serial?: StringFieldUpdateOperationsInput | string
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
    station?: StringFieldUpdateOperationsInput | string
    line?: StringFieldUpdateOperationsInput | string
    defect?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    action?: NullableStringFieldUpdateOperationsInput | string | null
    keterangan?: NullableStringFieldUpdateOperationsInput | string | null
    update_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type production_ngUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    meter_type?: StringFieldUpdateOperationsInput | string
    serial?: StringFieldUpdateOperationsInput | string
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
    station?: StringFieldUpdateOperationsInput | string
    line?: StringFieldUpdateOperationsInput | string
    defect?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    action?: NullableStringFieldUpdateOperationsInput | string | null
    keterangan?: NullableStringFieldUpdateOperationsInput | string | null
    update_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type production_ngCreateManyInput = {
    id?: number
    meter_type: string
    serial: string
    tanggal?: Date | string
    station: string
    line: string
    defect: string
    category?: string | null
    department?: string | null
    action?: string | null
    keterangan?: string | null
    update_date?: Date | string | null
    user?: string | null
  }

  export type production_ngUpdateManyMutationInput = {
    meter_type?: StringFieldUpdateOperationsInput | string
    serial?: StringFieldUpdateOperationsInput | string
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
    station?: StringFieldUpdateOperationsInput | string
    line?: StringFieldUpdateOperationsInput | string
    defect?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    action?: NullableStringFieldUpdateOperationsInput | string | null
    keterangan?: NullableStringFieldUpdateOperationsInput | string | null
    update_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type production_ngUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    meter_type?: StringFieldUpdateOperationsInput | string
    serial?: StringFieldUpdateOperationsInput | string
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
    station?: StringFieldUpdateOperationsInput | string
    line?: StringFieldUpdateOperationsInput | string
    defect?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    action?: NullableStringFieldUpdateOperationsInput | string | null
    keterangan?: NullableStringFieldUpdateOperationsInput | string | null
    update_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type productionorderCreateInput = {
    timestamp?: Date | string
    ponum: string
    area: string
    provinsi: string
    count_qty: string
    qty: number
    status: number
    keterangan?: number | null
  }

  export type productionorderUncheckedCreateInput = {
    id?: number
    timestamp?: Date | string
    ponum: string
    area: string
    provinsi: string
    count_qty: string
    qty: number
    status: number
    keterangan?: number | null
  }

  export type productionorderUpdateInput = {
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    ponum?: StringFieldUpdateOperationsInput | string
    area?: StringFieldUpdateOperationsInput | string
    provinsi?: StringFieldUpdateOperationsInput | string
    count_qty?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    keterangan?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type productionorderUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    ponum?: StringFieldUpdateOperationsInput | string
    area?: StringFieldUpdateOperationsInput | string
    provinsi?: StringFieldUpdateOperationsInput | string
    count_qty?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    keterangan?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type productionorderCreateManyInput = {
    id?: number
    timestamp?: Date | string
    ponum: string
    area: string
    provinsi: string
    count_qty: string
    qty: number
    status: number
    keterangan?: number | null
  }

  export type productionorderUpdateManyMutationInput = {
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    ponum?: StringFieldUpdateOperationsInput | string
    area?: StringFieldUpdateOperationsInput | string
    provinsi?: StringFieldUpdateOperationsInput | string
    count_qty?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    keterangan?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type productionorderUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    ponum?: StringFieldUpdateOperationsInput | string
    area?: StringFieldUpdateOperationsInput | string
    provinsi?: StringFieldUpdateOperationsInput | string
    count_qty?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    keterangan?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type receive_110CreateInput = {
    serial: string
    qr_serial: string
    timestamp?: Date | string
    result: $Enums.receive_110_result
  }

  export type receive_110UncheckedCreateInput = {
    id?: number
    serial: string
    qr_serial: string
    timestamp?: Date | string
    result: $Enums.receive_110_result
  }

  export type receive_110UpdateInput = {
    serial?: StringFieldUpdateOperationsInput | string
    qr_serial?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    result?: Enumreceive_110_resultFieldUpdateOperationsInput | $Enums.receive_110_result
  }

  export type receive_110UncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    serial?: StringFieldUpdateOperationsInput | string
    qr_serial?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    result?: Enumreceive_110_resultFieldUpdateOperationsInput | $Enums.receive_110_result
  }

  export type receive_110CreateManyInput = {
    id?: number
    serial: string
    qr_serial: string
    timestamp?: Date | string
    result: $Enums.receive_110_result
  }

  export type receive_110UpdateManyMutationInput = {
    serial?: StringFieldUpdateOperationsInput | string
    qr_serial?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    result?: Enumreceive_110_resultFieldUpdateOperationsInput | $Enums.receive_110_result
  }

  export type receive_110UncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    serial?: StringFieldUpdateOperationsInput | string
    qr_serial?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    result?: Enumreceive_110_resultFieldUpdateOperationsInput | $Enums.receive_110_result
  }

  export type rework_amrCreateInput = {
    serial?: string | null
    qr_serial: string
    timestamp?: Date | string
  }

  export type rework_amrUncheckedCreateInput = {
    id?: number
    serial?: string | null
    qr_serial: string
    timestamp?: Date | string
  }

  export type rework_amrUpdateInput = {
    serial?: NullableStringFieldUpdateOperationsInput | string | null
    qr_serial?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type rework_amrUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    serial?: NullableStringFieldUpdateOperationsInput | string | null
    qr_serial?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type rework_amrCreateManyInput = {
    id?: number
    serial?: string | null
    qr_serial: string
    timestamp?: Date | string
  }

  export type rework_amrUpdateManyMutationInput = {
    serial?: NullableStringFieldUpdateOperationsInput | string | null
    qr_serial?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type rework_amrUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    serial?: NullableStringFieldUpdateOperationsInput | string | null
    qr_serial?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type rework_boxCreateInput = {
    serial: string
    timestamp?: Date | string
    line: string
    type: string
    pallete_id?: number | null
    attachment_id?: number | null
    attachment2_id?: number | null
  }

  export type rework_boxUncheckedCreateInput = {
    id?: number
    serial: string
    timestamp?: Date | string
    line: string
    type: string
    pallete_id?: number | null
    attachment_id?: number | null
    attachment2_id?: number | null
  }

  export type rework_boxUpdateInput = {
    serial?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    line?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    pallete_id?: NullableIntFieldUpdateOperationsInput | number | null
    attachment_id?: NullableIntFieldUpdateOperationsInput | number | null
    attachment2_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type rework_boxUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    serial?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    line?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    pallete_id?: NullableIntFieldUpdateOperationsInput | number | null
    attachment_id?: NullableIntFieldUpdateOperationsInput | number | null
    attachment2_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type rework_boxCreateManyInput = {
    id?: number
    serial: string
    timestamp?: Date | string
    line: string
    type: string
    pallete_id?: number | null
    attachment_id?: number | null
    attachment2_id?: number | null
  }

  export type rework_boxUpdateManyMutationInput = {
    serial?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    line?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    pallete_id?: NullableIntFieldUpdateOperationsInput | number | null
    attachment_id?: NullableIntFieldUpdateOperationsInput | number | null
    attachment2_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type rework_boxUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    serial?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    line?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    pallete_id?: NullableIntFieldUpdateOperationsInput | number | null
    attachment_id?: NullableIntFieldUpdateOperationsInput | number | null
    attachment2_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type rework_hxe110CreateInput = {
    meter_type: string
    meter_serial: string
    tanggal?: Date | string
    modem: string
    baterai: string
    defect: string
  }

  export type rework_hxe110UncheckedCreateInput = {
    id?: number
    meter_type: string
    meter_serial: string
    tanggal?: Date | string
    modem: string
    baterai: string
    defect: string
  }

  export type rework_hxe110UpdateInput = {
    meter_type?: StringFieldUpdateOperationsInput | string
    meter_serial?: StringFieldUpdateOperationsInput | string
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
    modem?: StringFieldUpdateOperationsInput | string
    baterai?: StringFieldUpdateOperationsInput | string
    defect?: StringFieldUpdateOperationsInput | string
  }

  export type rework_hxe110UncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    meter_type?: StringFieldUpdateOperationsInput | string
    meter_serial?: StringFieldUpdateOperationsInput | string
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
    modem?: StringFieldUpdateOperationsInput | string
    baterai?: StringFieldUpdateOperationsInput | string
    defect?: StringFieldUpdateOperationsInput | string
  }

  export type rework_hxe110CreateManyInput = {
    id?: number
    meter_type: string
    meter_serial: string
    tanggal?: Date | string
    modem: string
    baterai: string
    defect: string
  }

  export type rework_hxe110UpdateManyMutationInput = {
    meter_type?: StringFieldUpdateOperationsInput | string
    meter_serial?: StringFieldUpdateOperationsInput | string
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
    modem?: StringFieldUpdateOperationsInput | string
    baterai?: StringFieldUpdateOperationsInput | string
    defect?: StringFieldUpdateOperationsInput | string
  }

  export type rework_hxe110UncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    meter_type?: StringFieldUpdateOperationsInput | string
    meter_serial?: StringFieldUpdateOperationsInput | string
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
    modem?: StringFieldUpdateOperationsInput | string
    baterai?: StringFieldUpdateOperationsInput | string
    defect?: StringFieldUpdateOperationsInput | string
  }

  export type rework_palleteCreateInput = {
    serial: string
    timestamp?: Date | string
    line: string
    type: string
    location?: string | null
  }

  export type rework_palleteUncheckedCreateInput = {
    id?: number
    serial: string
    timestamp?: Date | string
    line: string
    type: string
    location?: string | null
  }

  export type rework_palleteUpdateInput = {
    serial?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    line?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type rework_palleteUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    serial?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    line?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type rework_palleteCreateManyInput = {
    id?: number
    serial: string
    timestamp?: Date | string
    line: string
    type: string
    location?: string | null
  }

  export type rework_palleteUpdateManyMutationInput = {
    serial?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    line?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type rework_palleteUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    serial?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    line?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type serial_checkCreateInput = {
    serial: string
    timestamp?: Date | string
    line: string
    type: string
    orderno: string
    area?: string | null
    jenis?: string | null
    box_id?: number | null
    attachment_id?: number | null
    attachment2_id?: number | null
    remain?: string
    garansi?: string | null
  }

  export type serial_checkUncheckedCreateInput = {
    id?: number
    serial: string
    timestamp?: Date | string
    line: string
    type: string
    orderno: string
    area?: string | null
    jenis?: string | null
    box_id?: number | null
    attachment_id?: number | null
    attachment2_id?: number | null
    remain?: string
    garansi?: string | null
  }

  export type serial_checkUpdateInput = {
    serial?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    line?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    orderno?: StringFieldUpdateOperationsInput | string
    area?: NullableStringFieldUpdateOperationsInput | string | null
    jenis?: NullableStringFieldUpdateOperationsInput | string | null
    box_id?: NullableIntFieldUpdateOperationsInput | number | null
    attachment_id?: NullableIntFieldUpdateOperationsInput | number | null
    attachment2_id?: NullableIntFieldUpdateOperationsInput | number | null
    remain?: StringFieldUpdateOperationsInput | string
    garansi?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type serial_checkUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    serial?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    line?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    orderno?: StringFieldUpdateOperationsInput | string
    area?: NullableStringFieldUpdateOperationsInput | string | null
    jenis?: NullableStringFieldUpdateOperationsInput | string | null
    box_id?: NullableIntFieldUpdateOperationsInput | number | null
    attachment_id?: NullableIntFieldUpdateOperationsInput | number | null
    attachment2_id?: NullableIntFieldUpdateOperationsInput | number | null
    remain?: StringFieldUpdateOperationsInput | string
    garansi?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type serial_checkCreateManyInput = {
    id?: number
    serial: string
    timestamp?: Date | string
    line: string
    type: string
    orderno: string
    area?: string | null
    jenis?: string | null
    box_id?: number | null
    attachment_id?: number | null
    attachment2_id?: number | null
    remain?: string
    garansi?: string | null
  }

  export type serial_checkUpdateManyMutationInput = {
    serial?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    line?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    orderno?: StringFieldUpdateOperationsInput | string
    area?: NullableStringFieldUpdateOperationsInput | string | null
    jenis?: NullableStringFieldUpdateOperationsInput | string | null
    box_id?: NullableIntFieldUpdateOperationsInput | number | null
    attachment_id?: NullableIntFieldUpdateOperationsInput | number | null
    attachment2_id?: NullableIntFieldUpdateOperationsInput | number | null
    remain?: StringFieldUpdateOperationsInput | string
    garansi?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type serial_checkUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    serial?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    line?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    orderno?: StringFieldUpdateOperationsInput | string
    area?: NullableStringFieldUpdateOperationsInput | string | null
    jenis?: NullableStringFieldUpdateOperationsInput | string | null
    box_id?: NullableIntFieldUpdateOperationsInput | number | null
    attachment_id?: NullableIntFieldUpdateOperationsInput | number | null
    attachment2_id?: NullableIntFieldUpdateOperationsInput | number | null
    remain?: StringFieldUpdateOperationsInput | string
    garansi?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tahun_garansiCreateInput = {
    value: string
  }

  export type tahun_garansiUncheckedCreateInput = {
    id_garansi?: number
    value: string
  }

  export type tahun_garansiUpdateInput = {
    value?: StringFieldUpdateOperationsInput | string
  }

  export type tahun_garansiUncheckedUpdateInput = {
    id_garansi?: IntFieldUpdateOperationsInput | number
    value?: StringFieldUpdateOperationsInput | string
  }

  export type tahun_garansiCreateManyInput = {
    id_garansi?: number
    value: string
  }

  export type tahun_garansiUpdateManyMutationInput = {
    value?: StringFieldUpdateOperationsInput | string
  }

  export type tahun_garansiUncheckedUpdateManyInput = {
    id_garansi?: IntFieldUpdateOperationsInput | number
    value?: StringFieldUpdateOperationsInput | string
  }

  export type temp_indicatorCreateInput = {
    total: number
    total_ng: number
    total_ok: number
    timestamp?: Date | string
    status?: $Enums.temp_indicator_status
  }

  export type temp_indicatorUncheckedCreateInput = {
    id?: number
    total: number
    total_ng: number
    total_ok: number
    timestamp?: Date | string
    status?: $Enums.temp_indicator_status
  }

  export type temp_indicatorUpdateInput = {
    total?: IntFieldUpdateOperationsInput | number
    total_ng?: IntFieldUpdateOperationsInput | number
    total_ok?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: Enumtemp_indicator_statusFieldUpdateOperationsInput | $Enums.temp_indicator_status
  }

  export type temp_indicatorUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    total?: IntFieldUpdateOperationsInput | number
    total_ng?: IntFieldUpdateOperationsInput | number
    total_ok?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: Enumtemp_indicator_statusFieldUpdateOperationsInput | $Enums.temp_indicator_status
  }

  export type temp_indicatorCreateManyInput = {
    id?: number
    total: number
    total_ng: number
    total_ok: number
    timestamp?: Date | string
    status?: $Enums.temp_indicator_status
  }

  export type temp_indicatorUpdateManyMutationInput = {
    total?: IntFieldUpdateOperationsInput | number
    total_ng?: IntFieldUpdateOperationsInput | number
    total_ok?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: Enumtemp_indicator_statusFieldUpdateOperationsInput | $Enums.temp_indicator_status
  }

  export type temp_indicatorUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    total?: IntFieldUpdateOperationsInput | number
    total_ng?: IntFieldUpdateOperationsInput | number
    total_ok?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: Enumtemp_indicator_statusFieldUpdateOperationsInput | $Enums.temp_indicator_status
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type area_listCountOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
  }

  export type area_listAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type area_listMaxOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
  }

  export type area_listMinOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
  }

  export type area_listSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type attachmentCountOrderByAggregateInput = {
    id?: SortOrder
    nomor?: SortOrder
    timestamp?: SortOrder
    type?: SortOrder
    no_do?: SortOrder
    no_order?: SortOrder
    tgl_order?: SortOrder
    area?: SortOrder
    status?: SortOrder
    active?: SortOrder
    qty?: SortOrder
    used_qty?: SortOrder
  }

  export type attachmentAvgOrderByAggregateInput = {
    id?: SortOrder
    qty?: SortOrder
    used_qty?: SortOrder
  }

  export type attachmentMaxOrderByAggregateInput = {
    id?: SortOrder
    nomor?: SortOrder
    timestamp?: SortOrder
    type?: SortOrder
    no_do?: SortOrder
    no_order?: SortOrder
    tgl_order?: SortOrder
    area?: SortOrder
    status?: SortOrder
    active?: SortOrder
    qty?: SortOrder
    used_qty?: SortOrder
  }

  export type attachmentMinOrderByAggregateInput = {
    id?: SortOrder
    nomor?: SortOrder
    timestamp?: SortOrder
    type?: SortOrder
    no_do?: SortOrder
    no_order?: SortOrder
    tgl_order?: SortOrder
    area?: SortOrder
    status?: SortOrder
    active?: SortOrder
    qty?: SortOrder
    used_qty?: SortOrder
  }

  export type attachmentSumOrderByAggregateInput = {
    id?: SortOrder
    qty?: SortOrder
    used_qty?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type attachment2CountOrderByAggregateInput = {
    id?: SortOrder
    nomor?: SortOrder
    timestamp?: SortOrder
    type?: SortOrder
    no_do?: SortOrder
    no_order?: SortOrder
    tgl_order?: SortOrder
    area?: SortOrder
    status?: SortOrder
    active?: SortOrder
  }

  export type attachment2AvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type attachment2MaxOrderByAggregateInput = {
    id?: SortOrder
    nomor?: SortOrder
    timestamp?: SortOrder
    type?: SortOrder
    no_do?: SortOrder
    no_order?: SortOrder
    tgl_order?: SortOrder
    area?: SortOrder
    status?: SortOrder
    active?: SortOrder
  }

  export type attachment2MinOrderByAggregateInput = {
    id?: SortOrder
    nomor?: SortOrder
    timestamp?: SortOrder
    type?: SortOrder
    no_do?: SortOrder
    no_order?: SortOrder
    tgl_order?: SortOrder
    area?: SortOrder
    status?: SortOrder
    active?: SortOrder
  }

  export type attachment2SumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type boxCountOrderByAggregateInput = {
    id?: SortOrder
    serial?: SortOrder
    timestamp?: SortOrder
    line?: SortOrder
    type?: SortOrder
    pallete_id?: SortOrder
    attachment_id?: SortOrder
    attachment2_id?: SortOrder
    remain?: SortOrder
  }

  export type boxAvgOrderByAggregateInput = {
    id?: SortOrder
    pallete_id?: SortOrder
    attachment_id?: SortOrder
    attachment2_id?: SortOrder
  }

  export type boxMaxOrderByAggregateInput = {
    id?: SortOrder
    serial?: SortOrder
    timestamp?: SortOrder
    line?: SortOrder
    type?: SortOrder
    pallete_id?: SortOrder
    attachment_id?: SortOrder
    attachment2_id?: SortOrder
    remain?: SortOrder
  }

  export type boxMinOrderByAggregateInput = {
    id?: SortOrder
    serial?: SortOrder
    timestamp?: SortOrder
    line?: SortOrder
    type?: SortOrder
    pallete_id?: SortOrder
    attachment_id?: SortOrder
    attachment2_id?: SortOrder
    remain?: SortOrder
  }

  export type boxSumOrderByAggregateInput = {
    id?: SortOrder
    pallete_id?: SortOrder
    attachment_id?: SortOrder
    attachment2_id?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type configRootBranchCompoundUniqueInput = {
    root: string
    branch: string
  }

  export type configCountOrderByAggregateInput = {
    root?: SortOrder
    branch?: SortOrder
    value?: SortOrder
    tanggal?: SortOrder
  }

  export type configMaxOrderByAggregateInput = {
    root?: SortOrder
    branch?: SortOrder
    value?: SortOrder
    tanggal?: SortOrder
  }

  export type configMinOrderByAggregateInput = {
    root?: SortOrder
    branch?: SortOrder
    value?: SortOrder
    tanggal?: SortOrder
  }

  export type defect_listCountOrderByAggregateInput = {
    id?: SortOrder
    defect_name?: SortOrder
  }

  export type defect_listAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type defect_listMaxOrderByAggregateInput = {
    id?: SortOrder
    defect_name?: SortOrder
  }

  export type defect_listMinOrderByAggregateInput = {
    id?: SortOrder
    defect_name?: SortOrder
  }

  export type defect_listSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type fct_notpassCountOrderByAggregateInput = {
    id?: SortOrder
    serial?: SortOrder
    type?: SortOrder
    line?: SortOrder
    timestamp?: SortOrder
  }

  export type fct_notpassAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type fct_notpassMaxOrderByAggregateInput = {
    id?: SortOrder
    serial?: SortOrder
    type?: SortOrder
    line?: SortOrder
    timestamp?: SortOrder
  }

  export type fct_notpassMinOrderByAggregateInput = {
    id?: SortOrder
    serial?: SortOrder
    type?: SortOrder
    line?: SortOrder
    timestamp?: SortOrder
  }

  export type fct_notpassSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type fct_passCountOrderByAggregateInput = {
    id?: SortOrder
    serial?: SortOrder
    type?: SortOrder
    line?: SortOrder
    timestamp?: SortOrder
  }

  export type fct_passAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type fct_passMaxOrderByAggregateInput = {
    id?: SortOrder
    serial?: SortOrder
    type?: SortOrder
    line?: SortOrder
    timestamp?: SortOrder
  }

  export type fct_passMinOrderByAggregateInput = {
    id?: SortOrder
    serial?: SortOrder
    type?: SortOrder
    line?: SortOrder
    timestamp?: SortOrder
  }

  export type fct_passSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type fct_tempCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    line?: SortOrder
    timestamp?: SortOrder
    total_output?: SortOrder
    total_defect?: SortOrder
    target?: SortOrder
  }

  export type fct_tempAvgOrderByAggregateInput = {
    id?: SortOrder
    total_output?: SortOrder
    total_defect?: SortOrder
    target?: SortOrder
  }

  export type fct_tempMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    line?: SortOrder
    timestamp?: SortOrder
    total_output?: SortOrder
    total_defect?: SortOrder
    target?: SortOrder
  }

  export type fct_tempMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    line?: SortOrder
    timestamp?: SortOrder
    total_output?: SortOrder
    total_defect?: SortOrder
    target?: SortOrder
  }

  export type fct_tempSumOrderByAggregateInput = {
    id?: SortOrder
    total_output?: SortOrder
    total_defect?: SortOrder
    target?: SortOrder
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type Enumfilestore_file_deletedFilter<$PrismaModel = never> = {
    equals?: $Enums.filestore_file_deleted | Enumfilestore_file_deletedFieldRefInput<$PrismaModel>
    in?: $Enums.filestore_file_deleted[]
    notIn?: $Enums.filestore_file_deleted[]
    not?: NestedEnumfilestore_file_deletedFilter<$PrismaModel> | $Enums.filestore_file_deleted
  }

  export type filestore_fileCountOrderByAggregateInput = {
    id?: SortOrder
    filestore_type_id?: SortOrder
    filestore_volume_id?: SortOrder
    filename?: SortOrder
    original_filename?: SortOrder
    filesize?: SortOrder
    filenum?: SortOrder
    deleted?: SortOrder
  }

  export type filestore_fileAvgOrderByAggregateInput = {
    id?: SortOrder
    filestore_type_id?: SortOrder
    filestore_volume_id?: SortOrder
    filesize?: SortOrder
    filenum?: SortOrder
  }

  export type filestore_fileMaxOrderByAggregateInput = {
    id?: SortOrder
    filestore_type_id?: SortOrder
    filestore_volume_id?: SortOrder
    filename?: SortOrder
    original_filename?: SortOrder
    filesize?: SortOrder
    filenum?: SortOrder
    deleted?: SortOrder
  }

  export type filestore_fileMinOrderByAggregateInput = {
    id?: SortOrder
    filestore_type_id?: SortOrder
    filestore_volume_id?: SortOrder
    filename?: SortOrder
    original_filename?: SortOrder
    filesize?: SortOrder
    filenum?: SortOrder
    deleted?: SortOrder
  }

  export type filestore_fileSumOrderByAggregateInput = {
    id?: SortOrder
    filestore_type_id?: SortOrder
    filestore_volume_id?: SortOrder
    filesize?: SortOrder
    filenum?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type Enumfilestore_file_deletedWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.filestore_file_deleted | Enumfilestore_file_deletedFieldRefInput<$PrismaModel>
    in?: $Enums.filestore_file_deleted[]
    notIn?: $Enums.filestore_file_deleted[]
    not?: NestedEnumfilestore_file_deletedWithAggregatesFilter<$PrismaModel> | $Enums.filestore_file_deleted
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumfilestore_file_deletedFilter<$PrismaModel>
    _max?: NestedEnumfilestore_file_deletedFilter<$PrismaModel>
  }

  export type filestore_typeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    mime_type?: SortOrder
    extension?: SortOrder
  }

  export type filestore_typeAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type filestore_typeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    mime_type?: SortOrder
    extension?: SortOrder
  }

  export type filestore_typeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    mime_type?: SortOrder
    extension?: SortOrder
  }

  export type filestore_typeSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type Enumfilestore_volume_enabledNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.filestore_volume_enabled | Enumfilestore_volume_enabledFieldRefInput<$PrismaModel> | null
    in?: $Enums.filestore_volume_enabled[] | null
    notIn?: $Enums.filestore_volume_enabled[] | null
    not?: NestedEnumfilestore_volume_enabledNullableFilter<$PrismaModel> | $Enums.filestore_volume_enabled | null
  }

  export type filestore_volumeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    dirname?: SortOrder
    total_space?: SortOrder
    used_space?: SortOrder
    stored_files_cnt?: SortOrder
    enabled?: SortOrder
    last_filenum?: SortOrder
  }

  export type filestore_volumeAvgOrderByAggregateInput = {
    id?: SortOrder
    total_space?: SortOrder
    used_space?: SortOrder
    stored_files_cnt?: SortOrder
    last_filenum?: SortOrder
  }

  export type filestore_volumeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    dirname?: SortOrder
    total_space?: SortOrder
    used_space?: SortOrder
    stored_files_cnt?: SortOrder
    enabled?: SortOrder
    last_filenum?: SortOrder
  }

  export type filestore_volumeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    dirname?: SortOrder
    total_space?: SortOrder
    used_space?: SortOrder
    stored_files_cnt?: SortOrder
    enabled?: SortOrder
    last_filenum?: SortOrder
  }

  export type filestore_volumeSumOrderByAggregateInput = {
    id?: SortOrder
    total_space?: SortOrder
    used_space?: SortOrder
    stored_files_cnt?: SortOrder
    last_filenum?: SortOrder
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type Enumfilestore_volume_enabledNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.filestore_volume_enabled | Enumfilestore_volume_enabledFieldRefInput<$PrismaModel> | null
    in?: $Enums.filestore_volume_enabled[] | null
    notIn?: $Enums.filestore_volume_enabled[] | null
    not?: NestedEnumfilestore_volume_enabledNullableWithAggregatesFilter<$PrismaModel> | $Enums.filestore_volume_enabled | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumfilestore_volume_enabledNullableFilter<$PrismaModel>
    _max?: NestedEnumfilestore_volume_enabledNullableFilter<$PrismaModel>
  }

  export type audit_logsCountOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    entity_id?: SortOrder
    details?: SortOrder
    user?: SortOrder
    ip_address?: SortOrder
  }

  export type audit_logsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type audit_logsMaxOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    entity_id?: SortOrder
    details?: SortOrder
    user?: SortOrder
    ip_address?: SortOrder
  }

  export type audit_logsMinOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    entity_id?: SortOrder
    details?: SortOrder
    user?: SortOrder
    ip_address?: SortOrder
  }

  export type audit_logsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type logs_editCountOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
    desc?: SortOrder
    code?: SortOrder
    line?: SortOrder
    user?: SortOrder
  }

  export type logs_editAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type logs_editMaxOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
    desc?: SortOrder
    code?: SortOrder
    line?: SortOrder
    user?: SortOrder
  }

  export type logs_editMinOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
    desc?: SortOrder
    code?: SortOrder
    line?: SortOrder
    user?: SortOrder
  }

  export type logs_editSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type Enummeter_type_card_validationFilter<$PrismaModel = never> = {
    equals?: $Enums.meter_type_card_validation | Enummeter_type_card_validationFieldRefInput<$PrismaModel>
    in?: $Enums.meter_type_card_validation[]
    notIn?: $Enums.meter_type_card_validation[]
    not?: NestedEnummeter_type_card_validationFilter<$PrismaModel> | $Enums.meter_type_card_validation
  }

  export type Enummeter_type_validation_typeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.meter_type_validation_type | Enummeter_type_validation_typeFieldRefInput<$PrismaModel> | null
    in?: $Enums.meter_type_validation_type[] | null
    notIn?: $Enums.meter_type_validation_type[] | null
    not?: NestedEnummeter_type_validation_typeNullableFilter<$PrismaModel> | $Enums.meter_type_validation_type | null
  }

  export type Enummeter_type_daily_resetFilter<$PrismaModel = never> = {
    equals?: $Enums.meter_type_daily_reset | Enummeter_type_daily_resetFieldRefInput<$PrismaModel>
    in?: $Enums.meter_type_daily_reset[]
    notIn?: $Enums.meter_type_daily_reset[]
    not?: NestedEnummeter_type_daily_resetFilter<$PrismaModel> | $Enums.meter_type_daily_reset
  }

  export type Enummeter_type_numeric_onlyFilter<$PrismaModel = never> = {
    equals?: $Enums.meter_type_numeric_only | Enummeter_type_numeric_onlyFieldRefInput<$PrismaModel>
    in?: $Enums.meter_type_numeric_only[]
    notIn?: $Enums.meter_type_numeric_only[]
    not?: NestedEnummeter_type_numeric_onlyFilter<$PrismaModel> | $Enums.meter_type_numeric_only
  }

  export type Enummeter_type_surpass_targetFilter<$PrismaModel = never> = {
    equals?: $Enums.meter_type_surpass_target | Enummeter_type_surpass_targetFieldRefInput<$PrismaModel>
    in?: $Enums.meter_type_surpass_target[]
    notIn?: $Enums.meter_type_surpass_target[]
    not?: NestedEnummeter_type_surpass_targetFilter<$PrismaModel> | $Enums.meter_type_surpass_target
  }

  export type Enummeter_type_run_by_sequenceFilter<$PrismaModel = never> = {
    equals?: $Enums.meter_type_run_by_sequence | Enummeter_type_run_by_sequenceFieldRefInput<$PrismaModel>
    in?: $Enums.meter_type_run_by_sequence[]
    notIn?: $Enums.meter_type_run_by_sequence[]
    not?: NestedEnummeter_type_run_by_sequenceFilter<$PrismaModel> | $Enums.meter_type_run_by_sequence
  }

  export type meter_typeCountOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    phase?: SortOrder
    validation?: SortOrder
    validation_length?: SortOrder
    length?: SortOrder
    pln_code?: SortOrder
    card_validation?: SortOrder
    validation_type?: SortOrder
    daily_reset?: SortOrder
    numeric_only?: SortOrder
    surpass_target?: SortOrder
    run_by_sequence?: SortOrder
    start_reset?: SortOrder
    end_reset?: SortOrder
  }

  export type meter_typeAvgOrderByAggregateInput = {
    id?: SortOrder
    validation_length?: SortOrder
    length?: SortOrder
  }

  export type meter_typeMaxOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    phase?: SortOrder
    validation?: SortOrder
    validation_length?: SortOrder
    length?: SortOrder
    pln_code?: SortOrder
    card_validation?: SortOrder
    validation_type?: SortOrder
    daily_reset?: SortOrder
    numeric_only?: SortOrder
    surpass_target?: SortOrder
    run_by_sequence?: SortOrder
    start_reset?: SortOrder
    end_reset?: SortOrder
  }

  export type meter_typeMinOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    phase?: SortOrder
    validation?: SortOrder
    validation_length?: SortOrder
    length?: SortOrder
    pln_code?: SortOrder
    card_validation?: SortOrder
    validation_type?: SortOrder
    daily_reset?: SortOrder
    numeric_only?: SortOrder
    surpass_target?: SortOrder
    run_by_sequence?: SortOrder
    start_reset?: SortOrder
    end_reset?: SortOrder
  }

  export type meter_typeSumOrderByAggregateInput = {
    id?: SortOrder
    validation_length?: SortOrder
    length?: SortOrder
  }

  export type Enummeter_type_card_validationWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.meter_type_card_validation | Enummeter_type_card_validationFieldRefInput<$PrismaModel>
    in?: $Enums.meter_type_card_validation[]
    notIn?: $Enums.meter_type_card_validation[]
    not?: NestedEnummeter_type_card_validationWithAggregatesFilter<$PrismaModel> | $Enums.meter_type_card_validation
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnummeter_type_card_validationFilter<$PrismaModel>
    _max?: NestedEnummeter_type_card_validationFilter<$PrismaModel>
  }

  export type Enummeter_type_validation_typeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.meter_type_validation_type | Enummeter_type_validation_typeFieldRefInput<$PrismaModel> | null
    in?: $Enums.meter_type_validation_type[] | null
    notIn?: $Enums.meter_type_validation_type[] | null
    not?: NestedEnummeter_type_validation_typeNullableWithAggregatesFilter<$PrismaModel> | $Enums.meter_type_validation_type | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnummeter_type_validation_typeNullableFilter<$PrismaModel>
    _max?: NestedEnummeter_type_validation_typeNullableFilter<$PrismaModel>
  }

  export type Enummeter_type_daily_resetWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.meter_type_daily_reset | Enummeter_type_daily_resetFieldRefInput<$PrismaModel>
    in?: $Enums.meter_type_daily_reset[]
    notIn?: $Enums.meter_type_daily_reset[]
    not?: NestedEnummeter_type_daily_resetWithAggregatesFilter<$PrismaModel> | $Enums.meter_type_daily_reset
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnummeter_type_daily_resetFilter<$PrismaModel>
    _max?: NestedEnummeter_type_daily_resetFilter<$PrismaModel>
  }

  export type Enummeter_type_numeric_onlyWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.meter_type_numeric_only | Enummeter_type_numeric_onlyFieldRefInput<$PrismaModel>
    in?: $Enums.meter_type_numeric_only[]
    notIn?: $Enums.meter_type_numeric_only[]
    not?: NestedEnummeter_type_numeric_onlyWithAggregatesFilter<$PrismaModel> | $Enums.meter_type_numeric_only
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnummeter_type_numeric_onlyFilter<$PrismaModel>
    _max?: NestedEnummeter_type_numeric_onlyFilter<$PrismaModel>
  }

  export type Enummeter_type_surpass_targetWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.meter_type_surpass_target | Enummeter_type_surpass_targetFieldRefInput<$PrismaModel>
    in?: $Enums.meter_type_surpass_target[]
    notIn?: $Enums.meter_type_surpass_target[]
    not?: NestedEnummeter_type_surpass_targetWithAggregatesFilter<$PrismaModel> | $Enums.meter_type_surpass_target
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnummeter_type_surpass_targetFilter<$PrismaModel>
    _max?: NestedEnummeter_type_surpass_targetFilter<$PrismaModel>
  }

  export type Enummeter_type_run_by_sequenceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.meter_type_run_by_sequence | Enummeter_type_run_by_sequenceFieldRefInput<$PrismaModel>
    in?: $Enums.meter_type_run_by_sequence[]
    notIn?: $Enums.meter_type_run_by_sequence[]
    not?: NestedEnummeter_type_run_by_sequenceWithAggregatesFilter<$PrismaModel> | $Enums.meter_type_run_by_sequence
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnummeter_type_run_by_sequenceFilter<$PrismaModel>
    _max?: NestedEnummeter_type_run_by_sequenceFilter<$PrismaModel>
  }

  export type module_listCountOrderByAggregateInput = {
    module_id?: SortOrder
    module_serial?: SortOrder
  }

  export type module_listAvgOrderByAggregateInput = {
    module_id?: SortOrder
  }

  export type module_listMaxOrderByAggregateInput = {
    module_id?: SortOrder
    module_serial?: SortOrder
  }

  export type module_listMinOrderByAggregateInput = {
    module_id?: SortOrder
    module_serial?: SortOrder
  }

  export type module_listSumOrderByAggregateInput = {
    module_id?: SortOrder
  }

  export type order_numCountOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    counter?: SortOrder
  }

  export type order_numAvgOrderByAggregateInput = {
    id?: SortOrder
    counter?: SortOrder
  }

  export type order_numMaxOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    counter?: SortOrder
  }

  export type order_numMinOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    counter?: SortOrder
  }

  export type order_numSumOrderByAggregateInput = {
    id?: SortOrder
    counter?: SortOrder
  }

  export type out_110SerialQr_serialReceive_idCompoundUniqueInput = {
    serial: string
    qr_serial: string
    receive_id: number
  }

  export type out_110CountOrderByAggregateInput = {
    id?: SortOrder
    serial?: SortOrder
    qr_serial?: SortOrder
    timestamp?: SortOrder
    receive_id?: SortOrder
  }

  export type out_110AvgOrderByAggregateInput = {
    id?: SortOrder
    receive_id?: SortOrder
  }

  export type out_110MaxOrderByAggregateInput = {
    id?: SortOrder
    serial?: SortOrder
    qr_serial?: SortOrder
    timestamp?: SortOrder
    receive_id?: SortOrder
  }

  export type out_110MinOrderByAggregateInput = {
    id?: SortOrder
    serial?: SortOrder
    qr_serial?: SortOrder
    timestamp?: SortOrder
    receive_id?: SortOrder
  }

  export type out_110SumOrderByAggregateInput = {
    id?: SortOrder
    receive_id?: SortOrder
  }

  export type output_targetCountOrderByAggregateInput = {
    id?: SortOrder
    output?: SortOrder
    type?: SortOrder
    waktu?: SortOrder
    line?: SortOrder
    timestamp?: SortOrder
  }

  export type output_targetAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type output_targetMaxOrderByAggregateInput = {
    id?: SortOrder
    output?: SortOrder
    type?: SortOrder
    waktu?: SortOrder
    line?: SortOrder
    timestamp?: SortOrder
  }

  export type output_targetMinOrderByAggregateInput = {
    id?: SortOrder
    output?: SortOrder
    type?: SortOrder
    waktu?: SortOrder
    line?: SortOrder
    timestamp?: SortOrder
  }

  export type output_targetSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type output_tempCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    total_output?: SortOrder
    line?: SortOrder
    tahun?: SortOrder
    timestamp?: SortOrder
    total_bigbox?: SortOrder
    total_pallet?: SortOrder
    target?: SortOrder
    target_hour?: SortOrder
    hour1?: SortOrder
    hour2?: SortOrder
    hour3?: SortOrder
    hour4?: SortOrder
    hour5?: SortOrder
    hour6?: SortOrder
    hour7?: SortOrder
    hour8?: SortOrder
    hour9?: SortOrder
    hour10?: SortOrder
    hour11?: SortOrder
    hour12?: SortOrder
  }

  export type output_tempAvgOrderByAggregateInput = {
    id?: SortOrder
    total_output?: SortOrder
    total_bigbox?: SortOrder
    total_pallet?: SortOrder
    target?: SortOrder
    target_hour?: SortOrder
    hour1?: SortOrder
    hour2?: SortOrder
    hour3?: SortOrder
    hour4?: SortOrder
    hour5?: SortOrder
    hour6?: SortOrder
    hour7?: SortOrder
    hour8?: SortOrder
    hour9?: SortOrder
    hour10?: SortOrder
    hour11?: SortOrder
    hour12?: SortOrder
  }

  export type output_tempMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    total_output?: SortOrder
    line?: SortOrder
    tahun?: SortOrder
    timestamp?: SortOrder
    total_bigbox?: SortOrder
    total_pallet?: SortOrder
    target?: SortOrder
    target_hour?: SortOrder
    hour1?: SortOrder
    hour2?: SortOrder
    hour3?: SortOrder
    hour4?: SortOrder
    hour5?: SortOrder
    hour6?: SortOrder
    hour7?: SortOrder
    hour8?: SortOrder
    hour9?: SortOrder
    hour10?: SortOrder
    hour11?: SortOrder
    hour12?: SortOrder
  }

  export type output_tempMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    total_output?: SortOrder
    line?: SortOrder
    tahun?: SortOrder
    timestamp?: SortOrder
    total_bigbox?: SortOrder
    total_pallet?: SortOrder
    target?: SortOrder
    target_hour?: SortOrder
    hour1?: SortOrder
    hour2?: SortOrder
    hour3?: SortOrder
    hour4?: SortOrder
    hour5?: SortOrder
    hour6?: SortOrder
    hour7?: SortOrder
    hour8?: SortOrder
    hour9?: SortOrder
    hour10?: SortOrder
    hour11?: SortOrder
    hour12?: SortOrder
  }

  export type output_tempSumOrderByAggregateInput = {
    id?: SortOrder
    total_output?: SortOrder
    total_bigbox?: SortOrder
    total_pallet?: SortOrder
    target?: SortOrder
    target_hour?: SortOrder
    hour1?: SortOrder
    hour2?: SortOrder
    hour3?: SortOrder
    hour4?: SortOrder
    hour5?: SortOrder
    hour6?: SortOrder
    hour7?: SortOrder
    hour8?: SortOrder
    hour9?: SortOrder
    hour10?: SortOrder
    hour11?: SortOrder
    hour12?: SortOrder
  }

  export type palleteCountOrderByAggregateInput = {
    id?: SortOrder
    serial?: SortOrder
    timestamp?: SortOrder
    line?: SortOrder
    type?: SortOrder
    location?: SortOrder
  }

  export type palleteAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type palleteMaxOrderByAggregateInput = {
    id?: SortOrder
    serial?: SortOrder
    timestamp?: SortOrder
    line?: SortOrder
    type?: SortOrder
    location?: SortOrder
  }

  export type palleteMinOrderByAggregateInput = {
    id?: SortOrder
    serial?: SortOrder
    timestamp?: SortOrder
    line?: SortOrder
    type?: SortOrder
    location?: SortOrder
  }

  export type palleteSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type pln_codeCountOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
  }

  export type pln_codeAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type pln_codeMaxOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
  }

  export type pln_codeMinOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
  }

  export type pln_codeSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type productCountOrderByAggregateInput = {
    id?: SortOrder
    serial?: SortOrder
    module_serial?: SortOrder
    timestamp?: SortOrder
    line?: SortOrder
    type?: SortOrder
    orderno?: SortOrder
    area?: SortOrder
    jenis?: SortOrder
    box_id?: SortOrder
    attachment_id?: SortOrder
    attachment2_id?: SortOrder
    remain?: SortOrder
    garansi?: SortOrder
  }

  export type productAvgOrderByAggregateInput = {
    id?: SortOrder
    box_id?: SortOrder
    attachment_id?: SortOrder
    attachment2_id?: SortOrder
  }

  export type productMaxOrderByAggregateInput = {
    id?: SortOrder
    serial?: SortOrder
    module_serial?: SortOrder
    timestamp?: SortOrder
    line?: SortOrder
    type?: SortOrder
    orderno?: SortOrder
    area?: SortOrder
    jenis?: SortOrder
    box_id?: SortOrder
    attachment_id?: SortOrder
    attachment2_id?: SortOrder
    remain?: SortOrder
    garansi?: SortOrder
  }

  export type productMinOrderByAggregateInput = {
    id?: SortOrder
    serial?: SortOrder
    module_serial?: SortOrder
    timestamp?: SortOrder
    line?: SortOrder
    type?: SortOrder
    orderno?: SortOrder
    area?: SortOrder
    jenis?: SortOrder
    box_id?: SortOrder
    attachment_id?: SortOrder
    attachment2_id?: SortOrder
    remain?: SortOrder
    garansi?: SortOrder
  }

  export type productSumOrderByAggregateInput = {
    id?: SortOrder
    box_id?: SortOrder
    attachment_id?: SortOrder
    attachment2_id?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type production_ngCountOrderByAggregateInput = {
    id?: SortOrder
    meter_type?: SortOrder
    serial?: SortOrder
    tanggal?: SortOrder
    station?: SortOrder
    line?: SortOrder
    defect?: SortOrder
    category?: SortOrder
    department?: SortOrder
    action?: SortOrder
    keterangan?: SortOrder
    update_date?: SortOrder
    user?: SortOrder
  }

  export type production_ngAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type production_ngMaxOrderByAggregateInput = {
    id?: SortOrder
    meter_type?: SortOrder
    serial?: SortOrder
    tanggal?: SortOrder
    station?: SortOrder
    line?: SortOrder
    defect?: SortOrder
    category?: SortOrder
    department?: SortOrder
    action?: SortOrder
    keterangan?: SortOrder
    update_date?: SortOrder
    user?: SortOrder
  }

  export type production_ngMinOrderByAggregateInput = {
    id?: SortOrder
    meter_type?: SortOrder
    serial?: SortOrder
    tanggal?: SortOrder
    station?: SortOrder
    line?: SortOrder
    defect?: SortOrder
    category?: SortOrder
    department?: SortOrder
    action?: SortOrder
    keterangan?: SortOrder
    update_date?: SortOrder
    user?: SortOrder
  }

  export type production_ngSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type productionorderCountOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
    ponum?: SortOrder
    area?: SortOrder
    provinsi?: SortOrder
    count_qty?: SortOrder
    qty?: SortOrder
    status?: SortOrder
    keterangan?: SortOrder
  }

  export type productionorderAvgOrderByAggregateInput = {
    id?: SortOrder
    qty?: SortOrder
    status?: SortOrder
    keterangan?: SortOrder
  }

  export type productionorderMaxOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
    ponum?: SortOrder
    area?: SortOrder
    provinsi?: SortOrder
    count_qty?: SortOrder
    qty?: SortOrder
    status?: SortOrder
    keterangan?: SortOrder
  }

  export type productionorderMinOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
    ponum?: SortOrder
    area?: SortOrder
    provinsi?: SortOrder
    count_qty?: SortOrder
    qty?: SortOrder
    status?: SortOrder
    keterangan?: SortOrder
  }

  export type productionorderSumOrderByAggregateInput = {
    id?: SortOrder
    qty?: SortOrder
    status?: SortOrder
    keterangan?: SortOrder
  }

  export type Enumreceive_110_resultFilter<$PrismaModel = never> = {
    equals?: $Enums.receive_110_result | Enumreceive_110_resultFieldRefInput<$PrismaModel>
    in?: $Enums.receive_110_result[]
    notIn?: $Enums.receive_110_result[]
    not?: NestedEnumreceive_110_resultFilter<$PrismaModel> | $Enums.receive_110_result
  }

  export type receive_110CountOrderByAggregateInput = {
    id?: SortOrder
    serial?: SortOrder
    qr_serial?: SortOrder
    timestamp?: SortOrder
    result?: SortOrder
  }

  export type receive_110AvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type receive_110MaxOrderByAggregateInput = {
    id?: SortOrder
    serial?: SortOrder
    qr_serial?: SortOrder
    timestamp?: SortOrder
    result?: SortOrder
  }

  export type receive_110MinOrderByAggregateInput = {
    id?: SortOrder
    serial?: SortOrder
    qr_serial?: SortOrder
    timestamp?: SortOrder
    result?: SortOrder
  }

  export type receive_110SumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type Enumreceive_110_resultWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.receive_110_result | Enumreceive_110_resultFieldRefInput<$PrismaModel>
    in?: $Enums.receive_110_result[]
    notIn?: $Enums.receive_110_result[]
    not?: NestedEnumreceive_110_resultWithAggregatesFilter<$PrismaModel> | $Enums.receive_110_result
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumreceive_110_resultFilter<$PrismaModel>
    _max?: NestedEnumreceive_110_resultFilter<$PrismaModel>
  }

  export type rework_amrCountOrderByAggregateInput = {
    id?: SortOrder
    serial?: SortOrder
    qr_serial?: SortOrder
    timestamp?: SortOrder
  }

  export type rework_amrAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type rework_amrMaxOrderByAggregateInput = {
    id?: SortOrder
    serial?: SortOrder
    qr_serial?: SortOrder
    timestamp?: SortOrder
  }

  export type rework_amrMinOrderByAggregateInput = {
    id?: SortOrder
    serial?: SortOrder
    qr_serial?: SortOrder
    timestamp?: SortOrder
  }

  export type rework_amrSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type rework_boxCountOrderByAggregateInput = {
    id?: SortOrder
    serial?: SortOrder
    timestamp?: SortOrder
    line?: SortOrder
    type?: SortOrder
    pallete_id?: SortOrder
    attachment_id?: SortOrder
    attachment2_id?: SortOrder
  }

  export type rework_boxAvgOrderByAggregateInput = {
    id?: SortOrder
    pallete_id?: SortOrder
    attachment_id?: SortOrder
    attachment2_id?: SortOrder
  }

  export type rework_boxMaxOrderByAggregateInput = {
    id?: SortOrder
    serial?: SortOrder
    timestamp?: SortOrder
    line?: SortOrder
    type?: SortOrder
    pallete_id?: SortOrder
    attachment_id?: SortOrder
    attachment2_id?: SortOrder
  }

  export type rework_boxMinOrderByAggregateInput = {
    id?: SortOrder
    serial?: SortOrder
    timestamp?: SortOrder
    line?: SortOrder
    type?: SortOrder
    pallete_id?: SortOrder
    attachment_id?: SortOrder
    attachment2_id?: SortOrder
  }

  export type rework_boxSumOrderByAggregateInput = {
    id?: SortOrder
    pallete_id?: SortOrder
    attachment_id?: SortOrder
    attachment2_id?: SortOrder
  }

  export type rework_hxe110CountOrderByAggregateInput = {
    id?: SortOrder
    meter_type?: SortOrder
    meter_serial?: SortOrder
    tanggal?: SortOrder
    modem?: SortOrder
    baterai?: SortOrder
    defect?: SortOrder
  }

  export type rework_hxe110AvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type rework_hxe110MaxOrderByAggregateInput = {
    id?: SortOrder
    meter_type?: SortOrder
    meter_serial?: SortOrder
    tanggal?: SortOrder
    modem?: SortOrder
    baterai?: SortOrder
    defect?: SortOrder
  }

  export type rework_hxe110MinOrderByAggregateInput = {
    id?: SortOrder
    meter_type?: SortOrder
    meter_serial?: SortOrder
    tanggal?: SortOrder
    modem?: SortOrder
    baterai?: SortOrder
    defect?: SortOrder
  }

  export type rework_hxe110SumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type rework_palleteCountOrderByAggregateInput = {
    id?: SortOrder
    serial?: SortOrder
    timestamp?: SortOrder
    line?: SortOrder
    type?: SortOrder
    location?: SortOrder
  }

  export type rework_palleteAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type rework_palleteMaxOrderByAggregateInput = {
    id?: SortOrder
    serial?: SortOrder
    timestamp?: SortOrder
    line?: SortOrder
    type?: SortOrder
    location?: SortOrder
  }

  export type rework_palleteMinOrderByAggregateInput = {
    id?: SortOrder
    serial?: SortOrder
    timestamp?: SortOrder
    line?: SortOrder
    type?: SortOrder
    location?: SortOrder
  }

  export type rework_palleteSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type serial_checkCountOrderByAggregateInput = {
    id?: SortOrder
    serial?: SortOrder
    timestamp?: SortOrder
    line?: SortOrder
    type?: SortOrder
    orderno?: SortOrder
    area?: SortOrder
    jenis?: SortOrder
    box_id?: SortOrder
    attachment_id?: SortOrder
    attachment2_id?: SortOrder
    remain?: SortOrder
    garansi?: SortOrder
  }

  export type serial_checkAvgOrderByAggregateInput = {
    id?: SortOrder
    box_id?: SortOrder
    attachment_id?: SortOrder
    attachment2_id?: SortOrder
  }

  export type serial_checkMaxOrderByAggregateInput = {
    id?: SortOrder
    serial?: SortOrder
    timestamp?: SortOrder
    line?: SortOrder
    type?: SortOrder
    orderno?: SortOrder
    area?: SortOrder
    jenis?: SortOrder
    box_id?: SortOrder
    attachment_id?: SortOrder
    attachment2_id?: SortOrder
    remain?: SortOrder
    garansi?: SortOrder
  }

  export type serial_checkMinOrderByAggregateInput = {
    id?: SortOrder
    serial?: SortOrder
    timestamp?: SortOrder
    line?: SortOrder
    type?: SortOrder
    orderno?: SortOrder
    area?: SortOrder
    jenis?: SortOrder
    box_id?: SortOrder
    attachment_id?: SortOrder
    attachment2_id?: SortOrder
    remain?: SortOrder
    garansi?: SortOrder
  }

  export type serial_checkSumOrderByAggregateInput = {
    id?: SortOrder
    box_id?: SortOrder
    attachment_id?: SortOrder
    attachment2_id?: SortOrder
  }

  export type tahun_garansiCountOrderByAggregateInput = {
    id_garansi?: SortOrder
    value?: SortOrder
  }

  export type tahun_garansiAvgOrderByAggregateInput = {
    id_garansi?: SortOrder
  }

  export type tahun_garansiMaxOrderByAggregateInput = {
    id_garansi?: SortOrder
    value?: SortOrder
  }

  export type tahun_garansiMinOrderByAggregateInput = {
    id_garansi?: SortOrder
    value?: SortOrder
  }

  export type tahun_garansiSumOrderByAggregateInput = {
    id_garansi?: SortOrder
  }

  export type Enumtemp_indicator_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.temp_indicator_status | Enumtemp_indicator_statusFieldRefInput<$PrismaModel>
    in?: $Enums.temp_indicator_status[]
    notIn?: $Enums.temp_indicator_status[]
    not?: NestedEnumtemp_indicator_statusFilter<$PrismaModel> | $Enums.temp_indicator_status
  }

  export type temp_indicatorCountOrderByAggregateInput = {
    id?: SortOrder
    total?: SortOrder
    total_ng?: SortOrder
    total_ok?: SortOrder
    timestamp?: SortOrder
    status?: SortOrder
  }

  export type temp_indicatorAvgOrderByAggregateInput = {
    id?: SortOrder
    total?: SortOrder
    total_ng?: SortOrder
    total_ok?: SortOrder
  }

  export type temp_indicatorMaxOrderByAggregateInput = {
    id?: SortOrder
    total?: SortOrder
    total_ng?: SortOrder
    total_ok?: SortOrder
    timestamp?: SortOrder
    status?: SortOrder
  }

  export type temp_indicatorMinOrderByAggregateInput = {
    id?: SortOrder
    total?: SortOrder
    total_ng?: SortOrder
    total_ok?: SortOrder
    timestamp?: SortOrder
    status?: SortOrder
  }

  export type temp_indicatorSumOrderByAggregateInput = {
    id?: SortOrder
    total?: SortOrder
    total_ng?: SortOrder
    total_ok?: SortOrder
  }

  export type Enumtemp_indicator_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.temp_indicator_status | Enumtemp_indicator_statusFieldRefInput<$PrismaModel>
    in?: $Enums.temp_indicator_status[]
    notIn?: $Enums.temp_indicator_status[]
    not?: NestedEnumtemp_indicator_statusWithAggregatesFilter<$PrismaModel> | $Enums.temp_indicator_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumtemp_indicator_statusFilter<$PrismaModel>
    _max?: NestedEnumtemp_indicator_statusFilter<$PrismaModel>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type Enumfilestore_file_deletedFieldUpdateOperationsInput = {
    set?: $Enums.filestore_file_deleted
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type NullableEnumfilestore_volume_enabledFieldUpdateOperationsInput = {
    set?: $Enums.filestore_volume_enabled | null
  }

  export type Enummeter_type_card_validationFieldUpdateOperationsInput = {
    set?: $Enums.meter_type_card_validation
  }

  export type NullableEnummeter_type_validation_typeFieldUpdateOperationsInput = {
    set?: $Enums.meter_type_validation_type | null
  }

  export type Enummeter_type_daily_resetFieldUpdateOperationsInput = {
    set?: $Enums.meter_type_daily_reset
  }

  export type Enummeter_type_numeric_onlyFieldUpdateOperationsInput = {
    set?: $Enums.meter_type_numeric_only
  }

  export type Enummeter_type_surpass_targetFieldUpdateOperationsInput = {
    set?: $Enums.meter_type_surpass_target
  }

  export type Enummeter_type_run_by_sequenceFieldUpdateOperationsInput = {
    set?: $Enums.meter_type_run_by_sequence
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type Enumreceive_110_resultFieldUpdateOperationsInput = {
    set?: $Enums.receive_110_result
  }

  export type Enumtemp_indicator_statusFieldUpdateOperationsInput = {
    set?: $Enums.temp_indicator_status
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumfilestore_file_deletedFilter<$PrismaModel = never> = {
    equals?: $Enums.filestore_file_deleted | Enumfilestore_file_deletedFieldRefInput<$PrismaModel>
    in?: $Enums.filestore_file_deleted[]
    notIn?: $Enums.filestore_file_deleted[]
    not?: NestedEnumfilestore_file_deletedFilter<$PrismaModel> | $Enums.filestore_file_deleted
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedEnumfilestore_file_deletedWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.filestore_file_deleted | Enumfilestore_file_deletedFieldRefInput<$PrismaModel>
    in?: $Enums.filestore_file_deleted[]
    notIn?: $Enums.filestore_file_deleted[]
    not?: NestedEnumfilestore_file_deletedWithAggregatesFilter<$PrismaModel> | $Enums.filestore_file_deleted
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumfilestore_file_deletedFilter<$PrismaModel>
    _max?: NestedEnumfilestore_file_deletedFilter<$PrismaModel>
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedEnumfilestore_volume_enabledNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.filestore_volume_enabled | Enumfilestore_volume_enabledFieldRefInput<$PrismaModel> | null
    in?: $Enums.filestore_volume_enabled[] | null
    notIn?: $Enums.filestore_volume_enabled[] | null
    not?: NestedEnumfilestore_volume_enabledNullableFilter<$PrismaModel> | $Enums.filestore_volume_enabled | null
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type NestedEnumfilestore_volume_enabledNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.filestore_volume_enabled | Enumfilestore_volume_enabledFieldRefInput<$PrismaModel> | null
    in?: $Enums.filestore_volume_enabled[] | null
    notIn?: $Enums.filestore_volume_enabled[] | null
    not?: NestedEnumfilestore_volume_enabledNullableWithAggregatesFilter<$PrismaModel> | $Enums.filestore_volume_enabled | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumfilestore_volume_enabledNullableFilter<$PrismaModel>
    _max?: NestedEnumfilestore_volume_enabledNullableFilter<$PrismaModel>
  }

  export type NestedEnummeter_type_card_validationFilter<$PrismaModel = never> = {
    equals?: $Enums.meter_type_card_validation | Enummeter_type_card_validationFieldRefInput<$PrismaModel>
    in?: $Enums.meter_type_card_validation[]
    notIn?: $Enums.meter_type_card_validation[]
    not?: NestedEnummeter_type_card_validationFilter<$PrismaModel> | $Enums.meter_type_card_validation
  }

  export type NestedEnummeter_type_validation_typeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.meter_type_validation_type | Enummeter_type_validation_typeFieldRefInput<$PrismaModel> | null
    in?: $Enums.meter_type_validation_type[] | null
    notIn?: $Enums.meter_type_validation_type[] | null
    not?: NestedEnummeter_type_validation_typeNullableFilter<$PrismaModel> | $Enums.meter_type_validation_type | null
  }

  export type NestedEnummeter_type_daily_resetFilter<$PrismaModel = never> = {
    equals?: $Enums.meter_type_daily_reset | Enummeter_type_daily_resetFieldRefInput<$PrismaModel>
    in?: $Enums.meter_type_daily_reset[]
    notIn?: $Enums.meter_type_daily_reset[]
    not?: NestedEnummeter_type_daily_resetFilter<$PrismaModel> | $Enums.meter_type_daily_reset
  }

  export type NestedEnummeter_type_numeric_onlyFilter<$PrismaModel = never> = {
    equals?: $Enums.meter_type_numeric_only | Enummeter_type_numeric_onlyFieldRefInput<$PrismaModel>
    in?: $Enums.meter_type_numeric_only[]
    notIn?: $Enums.meter_type_numeric_only[]
    not?: NestedEnummeter_type_numeric_onlyFilter<$PrismaModel> | $Enums.meter_type_numeric_only
  }

  export type NestedEnummeter_type_surpass_targetFilter<$PrismaModel = never> = {
    equals?: $Enums.meter_type_surpass_target | Enummeter_type_surpass_targetFieldRefInput<$PrismaModel>
    in?: $Enums.meter_type_surpass_target[]
    notIn?: $Enums.meter_type_surpass_target[]
    not?: NestedEnummeter_type_surpass_targetFilter<$PrismaModel> | $Enums.meter_type_surpass_target
  }

  export type NestedEnummeter_type_run_by_sequenceFilter<$PrismaModel = never> = {
    equals?: $Enums.meter_type_run_by_sequence | Enummeter_type_run_by_sequenceFieldRefInput<$PrismaModel>
    in?: $Enums.meter_type_run_by_sequence[]
    notIn?: $Enums.meter_type_run_by_sequence[]
    not?: NestedEnummeter_type_run_by_sequenceFilter<$PrismaModel> | $Enums.meter_type_run_by_sequence
  }

  export type NestedEnummeter_type_card_validationWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.meter_type_card_validation | Enummeter_type_card_validationFieldRefInput<$PrismaModel>
    in?: $Enums.meter_type_card_validation[]
    notIn?: $Enums.meter_type_card_validation[]
    not?: NestedEnummeter_type_card_validationWithAggregatesFilter<$PrismaModel> | $Enums.meter_type_card_validation
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnummeter_type_card_validationFilter<$PrismaModel>
    _max?: NestedEnummeter_type_card_validationFilter<$PrismaModel>
  }

  export type NestedEnummeter_type_validation_typeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.meter_type_validation_type | Enummeter_type_validation_typeFieldRefInput<$PrismaModel> | null
    in?: $Enums.meter_type_validation_type[] | null
    notIn?: $Enums.meter_type_validation_type[] | null
    not?: NestedEnummeter_type_validation_typeNullableWithAggregatesFilter<$PrismaModel> | $Enums.meter_type_validation_type | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnummeter_type_validation_typeNullableFilter<$PrismaModel>
    _max?: NestedEnummeter_type_validation_typeNullableFilter<$PrismaModel>
  }

  export type NestedEnummeter_type_daily_resetWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.meter_type_daily_reset | Enummeter_type_daily_resetFieldRefInput<$PrismaModel>
    in?: $Enums.meter_type_daily_reset[]
    notIn?: $Enums.meter_type_daily_reset[]
    not?: NestedEnummeter_type_daily_resetWithAggregatesFilter<$PrismaModel> | $Enums.meter_type_daily_reset
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnummeter_type_daily_resetFilter<$PrismaModel>
    _max?: NestedEnummeter_type_daily_resetFilter<$PrismaModel>
  }

  export type NestedEnummeter_type_numeric_onlyWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.meter_type_numeric_only | Enummeter_type_numeric_onlyFieldRefInput<$PrismaModel>
    in?: $Enums.meter_type_numeric_only[]
    notIn?: $Enums.meter_type_numeric_only[]
    not?: NestedEnummeter_type_numeric_onlyWithAggregatesFilter<$PrismaModel> | $Enums.meter_type_numeric_only
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnummeter_type_numeric_onlyFilter<$PrismaModel>
    _max?: NestedEnummeter_type_numeric_onlyFilter<$PrismaModel>
  }

  export type NestedEnummeter_type_surpass_targetWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.meter_type_surpass_target | Enummeter_type_surpass_targetFieldRefInput<$PrismaModel>
    in?: $Enums.meter_type_surpass_target[]
    notIn?: $Enums.meter_type_surpass_target[]
    not?: NestedEnummeter_type_surpass_targetWithAggregatesFilter<$PrismaModel> | $Enums.meter_type_surpass_target
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnummeter_type_surpass_targetFilter<$PrismaModel>
    _max?: NestedEnummeter_type_surpass_targetFilter<$PrismaModel>
  }

  export type NestedEnummeter_type_run_by_sequenceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.meter_type_run_by_sequence | Enummeter_type_run_by_sequenceFieldRefInput<$PrismaModel>
    in?: $Enums.meter_type_run_by_sequence[]
    notIn?: $Enums.meter_type_run_by_sequence[]
    not?: NestedEnummeter_type_run_by_sequenceWithAggregatesFilter<$PrismaModel> | $Enums.meter_type_run_by_sequence
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnummeter_type_run_by_sequenceFilter<$PrismaModel>
    _max?: NestedEnummeter_type_run_by_sequenceFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumreceive_110_resultFilter<$PrismaModel = never> = {
    equals?: $Enums.receive_110_result | Enumreceive_110_resultFieldRefInput<$PrismaModel>
    in?: $Enums.receive_110_result[]
    notIn?: $Enums.receive_110_result[]
    not?: NestedEnumreceive_110_resultFilter<$PrismaModel> | $Enums.receive_110_result
  }

  export type NestedEnumreceive_110_resultWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.receive_110_result | Enumreceive_110_resultFieldRefInput<$PrismaModel>
    in?: $Enums.receive_110_result[]
    notIn?: $Enums.receive_110_result[]
    not?: NestedEnumreceive_110_resultWithAggregatesFilter<$PrismaModel> | $Enums.receive_110_result
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumreceive_110_resultFilter<$PrismaModel>
    _max?: NestedEnumreceive_110_resultFilter<$PrismaModel>
  }

  export type NestedEnumtemp_indicator_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.temp_indicator_status | Enumtemp_indicator_statusFieldRefInput<$PrismaModel>
    in?: $Enums.temp_indicator_status[]
    notIn?: $Enums.temp_indicator_status[]
    not?: NestedEnumtemp_indicator_statusFilter<$PrismaModel> | $Enums.temp_indicator_status
  }

  export type NestedEnumtemp_indicator_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.temp_indicator_status | Enumtemp_indicator_statusFieldRefInput<$PrismaModel>
    in?: $Enums.temp_indicator_status[]
    notIn?: $Enums.temp_indicator_status[]
    not?: NestedEnumtemp_indicator_statusWithAggregatesFilter<$PrismaModel> | $Enums.temp_indicator_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumtemp_indicator_statusFilter<$PrismaModel>
    _max?: NestedEnumtemp_indicator_statusFilter<$PrismaModel>
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use area_listDefaultArgs instead
     */
    export type area_listArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = area_listDefaultArgs<ExtArgs>
    /**
     * @deprecated Use attachmentDefaultArgs instead
     */
    export type attachmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = attachmentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use attachment2DefaultArgs instead
     */
    export type attachment2Args<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = attachment2DefaultArgs<ExtArgs>
    /**
     * @deprecated Use boxDefaultArgs instead
     */
    export type boxArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = boxDefaultArgs<ExtArgs>
    /**
     * @deprecated Use configDefaultArgs instead
     */
    export type configArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = configDefaultArgs<ExtArgs>
    /**
     * @deprecated Use defect_listDefaultArgs instead
     */
    export type defect_listArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = defect_listDefaultArgs<ExtArgs>
    /**
     * @deprecated Use fct_notpassDefaultArgs instead
     */
    export type fct_notpassArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = fct_notpassDefaultArgs<ExtArgs>
    /**
     * @deprecated Use fct_passDefaultArgs instead
     */
    export type fct_passArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = fct_passDefaultArgs<ExtArgs>
    /**
     * @deprecated Use fct_tempDefaultArgs instead
     */
    export type fct_tempArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = fct_tempDefaultArgs<ExtArgs>
    /**
     * @deprecated Use filestore_fileDefaultArgs instead
     */
    export type filestore_fileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = filestore_fileDefaultArgs<ExtArgs>
    /**
     * @deprecated Use filestore_typeDefaultArgs instead
     */
    export type filestore_typeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = filestore_typeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use filestore_volumeDefaultArgs instead
     */
    export type filestore_volumeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = filestore_volumeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use audit_logsDefaultArgs instead
     */
    export type audit_logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = audit_logsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use logs_editDefaultArgs instead
     */
    export type logs_editArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = logs_editDefaultArgs<ExtArgs>
    /**
     * @deprecated Use meter_typeDefaultArgs instead
     */
    export type meter_typeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = meter_typeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use module_listDefaultArgs instead
     */
    export type module_listArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = module_listDefaultArgs<ExtArgs>
    /**
     * @deprecated Use order_numDefaultArgs instead
     */
    export type order_numArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = order_numDefaultArgs<ExtArgs>
    /**
     * @deprecated Use out_110DefaultArgs instead
     */
    export type out_110Args<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = out_110DefaultArgs<ExtArgs>
    /**
     * @deprecated Use output_targetDefaultArgs instead
     */
    export type output_targetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = output_targetDefaultArgs<ExtArgs>
    /**
     * @deprecated Use output_tempDefaultArgs instead
     */
    export type output_tempArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = output_tempDefaultArgs<ExtArgs>
    /**
     * @deprecated Use palleteDefaultArgs instead
     */
    export type palleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = palleteDefaultArgs<ExtArgs>
    /**
     * @deprecated Use pln_codeDefaultArgs instead
     */
    export type pln_codeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = pln_codeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use productDefaultArgs instead
     */
    export type productArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = productDefaultArgs<ExtArgs>
    /**
     * @deprecated Use production_ngDefaultArgs instead
     */
    export type production_ngArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = production_ngDefaultArgs<ExtArgs>
    /**
     * @deprecated Use productionorderDefaultArgs instead
     */
    export type productionorderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = productionorderDefaultArgs<ExtArgs>
    /**
     * @deprecated Use receive_110DefaultArgs instead
     */
    export type receive_110Args<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = receive_110DefaultArgs<ExtArgs>
    /**
     * @deprecated Use rework_amrDefaultArgs instead
     */
    export type rework_amrArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = rework_amrDefaultArgs<ExtArgs>
    /**
     * @deprecated Use rework_boxDefaultArgs instead
     */
    export type rework_boxArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = rework_boxDefaultArgs<ExtArgs>
    /**
     * @deprecated Use rework_hxe110DefaultArgs instead
     */
    export type rework_hxe110Args<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = rework_hxe110DefaultArgs<ExtArgs>
    /**
     * @deprecated Use rework_palleteDefaultArgs instead
     */
    export type rework_palleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = rework_palleteDefaultArgs<ExtArgs>
    /**
     * @deprecated Use serial_checkDefaultArgs instead
     */
    export type serial_checkArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = serial_checkDefaultArgs<ExtArgs>
    /**
     * @deprecated Use tahun_garansiDefaultArgs instead
     */
    export type tahun_garansiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = tahun_garansiDefaultArgs<ExtArgs>
    /**
     * @deprecated Use temp_indicatorDefaultArgs instead
     */
    export type temp_indicatorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = temp_indicatorDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}